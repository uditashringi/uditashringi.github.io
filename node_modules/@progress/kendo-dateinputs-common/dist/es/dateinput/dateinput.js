import * as tslib_1 from "tslib";
var _a;
import { DateObject } from '../common/dateobject';
import { approximateStringMatching } from './utils';
import { KeyCode } from '../common/keycode';
import { Key } from '../common/key';
import { extend, isPresent, isDocumentAvailable, millisecondDigitsInFormat, millisecondStepFor, isValidDate } from '../common/utils';
import { Observable } from '../common/observable';
import { DateInputInteractionMode } from './interaction-mode';
import { isEqual, cloneDate } from '@progress/kendo-date-math';
import { Constants } from '../common/constants';
var DEFAULT_SEGMENT_STEP = 1;
var DRAG_START = "dragStart";
var DROP = "drop";
var TOUCH_START = "touchstart";
var MOUSE_DOWN = "mousedown";
var MOUSE_UP = "mouseup";
var CLICK = "click";
var INPUT = "input";
var KEY_DOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var PASTE = "paste";
var MOUSE_SCROLL = "DOMMouseScroll";
var MOUSE_WHEEL = "mousewheel";
var VALUE_CHANGE = "valueChange";
var INPUT_END = "inputEnd";
var BLUR_END = "blurEnd";
var FOCUS_END = "focusEnd";
var CHANGE = "change";
var defaultDateInputOptions = {
    format: "d",
    hasPlaceholder: false,
    placeholder: null,
    cycleTime: true,
    locale: null,
    steps: {
        millisecond: DEFAULT_SEGMENT_STEP,
        second: DEFAULT_SEGMENT_STEP,
        minute: DEFAULT_SEGMENT_STEP,
        hour: DEFAULT_SEGMENT_STEP,
        day: DEFAULT_SEGMENT_STEP,
        month: DEFAULT_SEGMENT_STEP,
        year: DEFAULT_SEGMENT_STEP
    },
    formatPlaceholder: null,
    events: (_a = {},
        _a[VALUE_CHANGE] = null,
        _a[INPUT] = null,
        _a[INPUT_END] = null,
        _a[FOCUS] = null,
        _a[FOCUS_END] = null,
        _a[BLUR] = null,
        _a[BLUR_END] = null,
        _a[KEY_DOWN] = null,
        _a[MOUSE_WHEEL] = null,
        _a[CHANGE] = null,
        _a),
    selectNearestSegmentOnFocus: false,
    selectPreviousSegmentOnBackspace: false,
    enableMouseWheel: false,
    allowCaretMode: false,
    autoSwitchParts: true,
    autoSwitchKeys: [],
    twoDigitYearMax: Constants.twoDigitYearMax,
    autoCorrectParts: true,
    autoFill: false,
    toggleDayPeriod: false
};
var DateInput = /** @class */ (function (_super) {
    tslib_1.__extends(DateInput, _super);
    function DateInput(element, options) {
        var _this = _super.call(this, options) || this;
        _this.dateObject = null;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        _this.currentText = '';
        _this.currentFormat = '';
        _this.interactionMode = DateInputInteractionMode.None;
        _this.previousElementSelection = { start: 0, end: 0 };
        _this.init(element, options);
        return _this;
    }
    Object.defineProperty(DateInput.prototype, "value", {
        get: function () {
            return this.dateObject && this.dateObject.getValue();
        },
        enumerable: true,
        configurable: true
    });
    DateInput.prototype.init = function (element, options) {
        var dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);
        if (!isValidDate(dateValue)) {
            dateValue = null;
        }
        this.element = element;
        // this.element._kendoWidget = this;
        this.options = extend({}, defaultDateInputOptions, options, { steps: tslib_1.__assign({}, defaultDateInputOptions.steps, options.steps) });
        this.intl = this.options.intlService;
        this.dateObject = this.createDateObject();
        this.dateObject.setValue(dateValue);
        this.setTextAndFormat();
        this.bindEvents();
        this.resetSegmentValue = true;
        this.interactionMode = DateInputInteractionMode.None;
        this.forceUpdate();
    };
    DateInput.prototype.destroy = function () {
        this.unbindEvents();
        this.dateObject = null;
        _super.prototype.destroy.call(this);
    };
    DateInput.prototype.bindEvents = function () {
        this.onElementDragStart = this.onElementDragStart.bind(this);
        this.element.addEventListener(DRAG_START, this.onElementDragStart);
        this.onElementDrop = this.onElementDrop.bind(this);
        this.element.addEventListener(DROP, this.onElementDrop);
        this.onElementClick = this.onElementClick.bind(this);
        this.element.addEventListener(CLICK, this.onElementClick);
        this.onElementMouseDown = this.onElementMouseDown.bind(this);
        this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);
        this.element.addEventListener(TOUCH_START, this.onElementMouseDown);
        this.onElementMouseUp = this.onElementMouseUp.bind(this);
        this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);
        this.onElementInput = this.onElementInput.bind(this);
        this.element.addEventListener(INPUT, this.onElementInput);
        this.onElementKeyDown = this.onElementKeyDown.bind(this);
        this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);
        this.onElementFocus = this.onElementFocus.bind(this);
        this.element.addEventListener(FOCUS, this.onElementFocus);
        this.onElementBlur = this.onElementBlur.bind(this);
        this.element.addEventListener(BLUR, this.onElementBlur);
        this.onElementChange = this.onElementChange.bind(this);
        this.element.addEventListener(CHANGE, this.onElementChange);
        this.onElementPaste = this.onElementPaste.bind(this);
        this.element.addEventListener(PASTE, this.onElementPaste);
        this.onElementMouseWheel = this.onElementMouseWheel.bind(this);
        this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
        this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput.prototype.unbindEvents = function () {
        this.element.removeEventListener(DRAG_START, this.onElementDragStart);
        this.element.removeEventListener(DROP, this.onElementDrop);
        this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);
        this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);
        this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);
        this.element.removeEventListener(CLICK, this.onElementClick);
        this.element.removeEventListener(INPUT, this.onElementInput);
        this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);
        this.element.removeEventListener(FOCUS, this.onElementFocus);
        this.element.removeEventListener(BLUR, this.onElementBlur);
        this.element.removeEventListener(CHANGE, this.onElementChange);
        this.element.removeEventListener(PASTE, this.onElementPaste);
        this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
        this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput.prototype.setOptions = function (options, refresh) {
        if (refresh === void 0) { refresh = false; }
        this.options = extend({}, this.options, options, { steps: tslib_1.__assign({}, defaultDateInputOptions.steps, options.steps) });
        this.setDateObjectOptions();
        if (refresh) {
            this.unbindEvents();
            this.init(this.element, this.options);
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.setDateObjectOptions = function () {
        if (this.dateObject) {
            var newOptions = this.getDateObjectOptions();
            this.dateObject.setOptions(newOptions);
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.resetLocale = function () {
        this.unbindEvents();
        this.init(this.element, this.options);
    };
    /**
     * @hidden
     */
    DateInput.prototype.isInCaretMode = function () {
        return this.interactionMode === DateInputInteractionMode.Caret;
    };
    DateInput.prototype.focus = function () {
        this.element.focus();
        if (this.options.selectNearestSegmentOnFocus) {
            this.selectNearestSegment(0);
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementDragStart = function (e) {
        e.preventDefault();
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementDrop = function (e) {
        e.preventDefault();
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementMouseDown = function () {
        this.mouseDownStarted = true;
        this.focusedPriorToMouseDown = this.isActive;
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementMouseUp = function (e) {
        this.mouseDownStarted = false;
        e.preventDefault();
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementClick = function (e) {
        this.mouseDownStarted = false;
        this.switchedPartOnPreviousKeyAction = false;
        var selection = this.selection;
        if (this.isInCaretMode()) {
            // explicitly refresh the input element value
            // caret mode can change the number of symbols in the element
            // thus clicking on a segment can result in incorrect selection
            this.forceUpdate();
        }
        if (e.detail === 3) {
            // when 3 clicks occur, leave the native event to handle the change
            // this results in selecting the whole element value
        }
        else {
            if (this.isActive && this.options.selectNearestSegmentOnFocus) {
                var selectionPresent = this.element.selectionStart !== this.element.selectionEnd;
                var placeholderToggled = isPresent(this.options.placeholder) &&
                    !this.dateObject.hasValue() &&
                    !this.focusedPriorToMouseDown;
                // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled
                var selectFirstSegment = !selectionPresent && placeholderToggled;
                var index = selectFirstSegment ? 0 : this.caret()[0];
                this.selectNearestSegment(index);
            }
            else {
                this.setSelection(this.selectionByIndex(selection.start));
            }
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementInput = function (e) {
        this.triggerInput({ event: e });
        var oldElementValue = this.elementValue;
        if (!this.element || !this.dateObject) {
            return;
        }
        var switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;
        if (this.isPasteInProgress) {
            if (this.options.allowCaretMode) {
                // pasting should leave the input with caret
                // thus allow direct input instead of selection mode
                this.resetSegmentValue = false;
            }
            this.updateOnPaste(e);
            this.isPasteInProgress = false;
            return;
        }
        var keyDownEvent = this.keyDownEvent || {};
        var isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;
        var isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;
        var originalInteractionMode = this.interactionMode;
        if (this.options.allowCaretMode &&
            originalInteractionMode !== DateInputInteractionMode.Caret &&
            !isDeleteKey && !isBackspaceKey) {
            this.resetSegmentValue = true;
        }
        if (this.options.allowCaretMode) {
            this.interactionMode = DateInputInteractionMode.Caret;
        }
        else {
            this.interactionMode = DateInputInteractionMode.Selection;
        }
        var hasCaret = this.isInCaretMode();
        if (hasCaret && this.keyDownEvent.key === Key.SPACE) {
            // do not allow custom "holes" in the date segments
            this.restorePreviousInputEventState();
            return;
        }
        var oldExistingDateValue = this.dateObject && this.dateObject.getValue();
        var oldDateValue = this.dateObject ? this.dateObject.value : null;
        var _a = this.dateObject.getTextAndFormat(), currentText = _a.text, currentFormat = _a.format;
        this.currentFormat = currentFormat;
        var oldText = "";
        if (hasCaret) {
            if (isBackspaceKey || isDeleteKey) {
                oldText = this.previousElementValue;
            }
            else if (originalInteractionMode === DateInputInteractionMode.Caret) {
                oldText = this.previousElementValue;
            }
            else {
                oldText = currentText;
            }
        }
        else {
            oldText = currentText;
        }
        var newText = this.elementValue;
        var diff = approximateStringMatching({
            oldText: oldText,
            newText: newText,
            formatPattern: this.currentFormat,
            selectionStart: this.selection.start,
            isInCaretMode: hasCaret,
            keyEvent: this.keyDownEvent
        });
        if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {
            this.switchedPartOnPreviousKeyAction = false;
        }
        if (hasCaret && (!diff || diff.length === 0)) {
            this.restorePreviousInputEventState();
            return;
        }
        else if (hasCaret && diff.length === 1) {
            if (!diff[0] || !diff[0][0]) {
                this.restorePreviousInputEventState();
                return;
            }
            else if (hasCaret && diff[0] &&
                (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {
                this.restorePreviousInputEventState();
                return;
            }
        }
        var navigationOnly = (diff.length === 1 && diff[0][1] === Constants.formatSeparator);
        var parsePartsResults = [];
        var switchPart = false;
        var error = null;
        if (!navigationOnly) {
            for (var i = 0; i < diff.length; i++) {
                var parsePartResult = this.dateObject.parsePart({
                    symbol: diff[i][0],
                    currentChar: diff[i][1],
                    resetSegmentValue: this.resetSegmentValue,
                    cycleSegmentValue: !this.isInCaretMode(),
                    rawTextValue: this.element.value,
                    isDeleting: isBackspaceKey || isDeleteKey,
                    originalFormat: this.currentFormat
                });
                parsePartsResults.push(parsePartResult);
                if (!parsePartResult.value) {
                    error = { type: "parse" };
                }
                switchPart = parsePartResult.switchToNext;
            }
        }
        if (!this.options.autoSwitchParts) {
            switchPart = false;
        }
        this.resetSegmentValue = false;
        var hasFixedFormat = this.options.format === this.currentFormat ||
            // all not fixed formats are 1 symbol, e.g. "d"
            (isPresent(this.options.format) && this.options.format.length > 1);
        var lastParseResult = parsePartsResults[parsePartsResults.length - 1];
        var lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);
        var parsingFailedOnDelete = (hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue);
        var resetPart = lastParseResult ? lastParseResult.resetPart : false;
        var newExistingDateValue = this.dateObject.getValue();
        var hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);
        var newDateValue = this.dateObject.value;
        var symbolForSelection;
        var currentSelection = this.selection;
        if (hasCaret) {
            var diffChar = diff && diff.length > 0 ? diff[0][0] : null;
            var hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];
            if (diff.length && diff[0][0] !== Constants.formatSeparator) {
                if (switchPart) {
                    this.forceUpdateWithSelection();
                    this.switchDateSegment(1);
                }
                else if (resetPart) {
                    symbolForSelection = this.currentFormat[currentSelection.start];
                    if (symbolForSelection) {
                        this.forceUpdate();
                        this.setSelection(this.selectionBySymbol(symbolForSelection));
                    }
                    else {
                        this.restorePreviousInputEventState();
                    }
                }
                else if (parsingFailedOnDelete) {
                    this.forceUpdate();
                    if (diff.length && diff[0][0] !== Constants.formatSeparator) {
                        this.setSelection(this.selectionBySymbol(diff[0][0]));
                    }
                }
                else if (lastParseResultHasNoValue) {
                    if (e.data === "0" && hasLeadingZero) {
                        // do not reset element value on a leading zero
                        // wait for consecutive input to determine the value
                    }
                    else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {
                        this.restorePreviousInputEventState();
                    }
                    else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {
                        this.forceUpdateWithSelection();
                    }
                    else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {
                        if (hasExistingDateValueChanged) {
                            this.forceUpdateWithSelection();
                        }
                        else {
                            this.restorePreviousInputEventState();
                        }
                    }
                    else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {
                        this.forceUpdateWithSelection();
                    }
                    else if (oldDateValue !== newDateValue) {
                        // this can happen on auto correct when no valid value is parsed
                    }
                    else {
                        this.restorePreviousInputEventState();
                    }
                }
                else if (!lastParseResultHasNoValue) {
                    // the user types a valid but incomplete date (e.g. year "123" with format "yyyy")
                    // let them continue typing, but refresh for not fixed formats
                    if (!hasFixedFormat) {
                        this.forceUpdateWithSelection();
                    }
                }
            }
            else {
                if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {
                    // do not change the selection when a separator is pressed
                    // this should happen only if autoSwitchKeys contains the separator explicitly
                }
                else {
                    this.setSelection(this.selectionBySymbol(diff[0][0]));
                }
            }
        }
        else if (!hasCaret) {
            this.forceUpdate();
            if (diff.length && diff[0][0] !== Constants.formatSeparator) {
                this.setSelection(this.selectionBySymbol(diff[0][0]));
            }
            if (this.options.autoSwitchParts) {
                if (navigationOnly) {
                    this.resetSegmentValue = true;
                    if (!switchedPartOnPreviousKeyAction) {
                        this.switchDateSegment(1);
                    }
                    this.switchedPartOnPreviousKeyAction = true;
                }
                else if (switchPart) {
                    this.switchDateSegment(1);
                    this.switchedPartOnPreviousKeyAction = true;
                }
            }
            else {
                if (lastParseResult && lastParseResult.switchToNext) {
                    // the value is complete and should be switched, but the "autoSwitchParts" option prevents this
                    // ensure that the segment value can be reset on next input
                    this.resetSegmentValue = true;
                }
                else if (navigationOnly) {
                    this.resetSegmentValue = true;
                    if (!switchedPartOnPreviousKeyAction) {
                        this.switchDateSegment(1);
                    }
                    this.switchedPartOnPreviousKeyAction = true;
                }
            }
            if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {
                // kendo angular have this UX
                this.switchDateSegment(-1);
            }
        }
        this.tryTriggerValueChange({
            oldValue: oldExistingDateValue,
            event: e
        });
        this.triggerInputEnd({ event: e, error: error, oldElementValue: oldElementValue, newElementValue: this.elementValue });
        if (hasCaret) {
            // a format like "F" can dynamically change the resolved format pattern based on the value, e.g.
            // "Tuesday, February 1, 2022 3:04:05 AM" becomes
            // "Wednesday, February 2, 2022 3:04:05 AM" giving a diff of 2 ("Tuesday".length - "Wednesday".length)
            this.setTextAndFormat();
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementFocus = function (e) {
        if (this.triggerFocus({ event: e })) {
            return;
        }
        this.isActive = true;
        this.interactionMode = DateInputInteractionMode.None;
        this.switchedPartOnPreviousKeyAction = false;
        this.refreshElementValue();
        if (!this.mouseDownStarted) {
            this.caret(0, this.elementValue.length);
        }
        this.mouseDownStarted = false;
        this.triggerFocusEnd({ event: e });
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementBlur = function (e) {
        this.resetSegmentValue = true;
        this.isActive = false;
        if (this.triggerBlur({ event: e })) {
            return;
        }
        if (this.options.autoFill) {
            this.autoFill();
        }
        this.interactionMode = DateInputInteractionMode.None;
        this.switchedPartOnPreviousKeyAction = false;
        this.refreshElementValue();
        this.triggerBlurEnd({ event: e });
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementChange = function (e) {
        this.triggerChange({ event: e });
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementKeyDown = function (e) {
        if (this.triggerKeyDown({ event: e })) {
            return;
        }
        var _a = this.selection, start = _a.start, end = _a.end;
        var event = e;
        this.keyDownEvent = e;
        this.previousElementValue = this.element.value;
        this.previousElementSelection = { start: start, end: end };
        if (this.keyEventMatchesAutoSwitchKeys(e)) {
            var isTabKey = e.keyCode === KeyCode.TAB;
            if (isTabKey) {
                var _b = this.selection, selectionStart = _b.start, selectionEnd = _b.end;
                if (e.shiftKey && isTabKey) {
                    this.switchDateSegment(-1);
                }
                else {
                    this.switchDateSegment(1);
                }
                if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {
                    // when the selection changes, prevent the default Tab behavior
                    e.preventDefault();
                    return;
                }
            }
            else {
                // do not allow the "input" event to be triggered
                e.preventDefault();
                this.switchDateSegment(1);
                return;
            }
        }
        var symbol = this.currentFormat[this.selection.start];
        var step = this.getStepFromSymbol(symbol);
        var shouldPreventDefault = false;
        var oldElementValue = this.elementValue;
        if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {
            return;
        }
        switch (e.keyCode) {
            case KeyCode.ARROW_LEFT:
                this.switchDateSegment(-1);
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                break;
            case KeyCode.ARROW_UP:
                this.modifyDateSegmentValue(step, symbol, event);
                if (oldElementValue !== this.elementValue) {
                    this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });
                }
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                break;
            case KeyCode.ARROW_RIGHT:
                this.switchDateSegment(1);
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                break;
            case KeyCode.ARROW_DOWN:
                this.modifyDateSegmentValue(-step, symbol, event);
                if (oldElementValue !== this.elementValue) {
                    this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });
                }
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                break;
            case KeyCode.ENTER:
                // todo: handle "change" event
                break;
            case KeyCode.HOME:
                this.selectNearestSegment(0);
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                this.resetSegmentValue = true;
                break;
            case KeyCode.END:
                this.selectNearestSegment(this.elementValue.length);
                shouldPreventDefault = true;
                this.switchedPartOnPreviousKeyAction = false;
                this.resetSegmentValue = true;
                break;
            default:
                // allow the "input" event to handle the change
                return;
        }
        if (shouldPreventDefault) {
            e.preventDefault();
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementPaste = function () {
        this.isPasteInProgress = true;
    };
    /**
     * @hidden
     */
    DateInput.prototype.onElementMouseWheel = function (e) {
        var oldElementValue = this.elementValue;
        if (!this.options.enableMouseWheel || this.triggerMouseWheel({ event: e })) {
            return;
        }
        if (!this.isActive) {
            return;
        }
        var event = e;
        if (event.shiftKey) {
            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);
        }
        else {
            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);
        }
        event.returnValue = false;
        if (event.preventDefault) {
            event.preventDefault();
        }
        if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue: oldElementValue });
        }
    };
    DateInput.prototype.updateOnPaste = function (e) {
        var value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;
        if (isPresent(value) && this.dateObject.shouldNormalizeCentury()) {
            value = this.dateObject.normalizeCentury(value);
        }
        var oldDateObjectValue = this.dateObject && this.dateObject.getValue();
        this.writeValue(value);
        this.tryTriggerValueChange({
            oldValue: oldDateObjectValue,
            event: e
        });
    };
    Object.defineProperty(DateInput.prototype, "elementValue", {
        get: function () {
            return (this.element || {}).value || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateInput.prototype, "inputFormat", {
        get: function () {
            if (!this.options.format) {
                return Constants.defaultDateFormat;
            }
            if (typeof this.options.format === 'string') {
                return this.options.format;
            }
            else {
                return this.options.format.inputFormat;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateInput.prototype, "displayFormat", {
        get: function () {
            if (!this.options.format) {
                return Constants.defaultDateFormat;
            }
            if (typeof this.options.format === 'string') {
                return this.options.format;
            }
            else {
                return this.options.format.displayFormat;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateInput.prototype, "selection", {
        get: function () {
            var returnValue = { start: 0, end: 0 };
            if (this.element !== null && this.element.selectionStart !== undefined) {
                returnValue = {
                    start: this.element.selectionStart,
                    end: this.element.selectionEnd
                };
            }
            return returnValue;
        },
        enumerable: true,
        configurable: true
    });
    DateInput.prototype.setSelection = function (selection) {
        if (this.element && document.activeElement === this.element) {
            this.element.setSelectionRange(selection.start, selection.end);
            if (selection.start !== selection.end) {
                this.interactionMode = DateInputInteractionMode.Selection;
            }
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.selectionBySymbol = function (symbol) {
        var start = -1;
        var end = 0;
        for (var i = 0; i < this.currentFormat.length; i++) {
            if (this.currentFormat[i] === symbol) {
                end = i + 1;
                if (start === -1) {
                    start = i;
                }
            }
        }
        if (start < 0) {
            start = 0;
        }
        if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {
            if (this.currentFormat.length < this.currentText.length) {
                end += this.currentText.length - this.currentFormat.length;
            }
            else {
                end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));
            }
        }
        return { start: start, end: end };
    };
    /**
     * @hidden
     */
    DateInput.prototype.selectionByIndex = function (index) {
        var selection = { start: index, end: index };
        for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
            if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {
                selection = this.selectionBySymbol(this.currentFormat[i]);
                break;
            }
            if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {
                selection = this.selectionBySymbol(this.currentFormat[j]);
                break;
            }
        }
        return selection;
    };
    DateInput.prototype.switchDateSegment = function (offset) {
        var selection = this.selection;
        if (this.isInCaretMode()) {
            var start = selection.start;
            var currentSymbol = this.currentFormat[start - 1];
            var symbol = "";
            var symbolCandidate = "";
            if (offset < 0) {
                for (var i = start + offset; i >= 0; i--) {
                    symbolCandidate = this.currentFormat[i];
                    if (symbolCandidate !== Constants.formatSeparator &&
                        symbolCandidate !== currentSymbol) {
                        start = i;
                        symbol = symbolCandidate;
                        break;
                    }
                }
            }
            else {
                for (var i = start + offset; i < this.currentFormat.length; i++) {
                    symbolCandidate = this.currentFormat[i];
                    if (symbolCandidate !== Constants.formatSeparator &&
                        symbolCandidate !== currentSymbol) {
                        start = i;
                        symbol = symbolCandidate;
                        break;
                    }
                }
            }
            if (symbol) {
                this.forceUpdate();
                this.setSelection(this.selectionBySymbol(symbol));
                this.interactionMode = DateInputInteractionMode.Selection;
                return;
            }
        }
        this.interactionMode = DateInputInteractionMode.None;
        var _a = this.selection, selectionStart = _a.start, selectionEnd = _a.end;
        if (selectionStart < selectionEnd &&
            this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {
            this.setSelection(this.selectionByIndex(offset > 0 ? selectionStart : selectionEnd - 1));
            this.resetSegmentValue = true;
            this.interactionMode = DateInputInteractionMode.None;
            return;
        }
        var previousFormatSymbol = this.currentFormat[selectionStart];
        var a = selectionStart + offset;
        while (a > 0 && a < this.currentFormat.length) {
            if (this.currentFormat[a] !== previousFormatSymbol &&
                this.currentFormat[a] !== Constants.formatSeparator) {
                break;
            }
            a += offset;
        }
        if (this.currentFormat[a] === Constants.formatSeparator) {
            // no known symbol is found
            return;
        }
        var b = a;
        while (b >= 0 && b < this.currentFormat.length) {
            if (this.currentFormat[b] !== this.currentFormat[a]) {
                break;
            }
            b += offset;
        }
        if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {
            this.setSelection({ start: b + 1, end: a + 1 });
            this.resetSegmentValue = true;
        }
        else if (a < b && (a !== selectionStart || b !== selectionEnd)) {
            this.setSelection({ start: a, end: b });
            this.resetSegmentValue = true;
        }
        this.interactionMode = DateInputInteractionMode.None;
    };
    DateInput.prototype.modifyDateSegmentValue = function (offset, symbol, event) {
        if (symbol === void 0) { symbol = ""; }
        if (event === void 0) { event = {}; }
        if (!this.dateObject || this.options.readonly) {
            return;
        }
        var oldValue = this.value;
        var step = DEFAULT_SEGMENT_STEP;
        var caret = this.caret();
        symbol = symbol || this.currentFormat[caret[0]];
        if (symbol === "S" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {
            var msDigits = millisecondDigitsInFormat(this.inputFormat);
            step = millisecondStepFor(msDigits);
        }
        this.dateObject.modifyPart(symbol, step * offset);
        this.tryTriggerValueChange({
            oldValue: oldValue,
            event: event
        });
        this.forceUpdate();
        this.setSelection(this.selectionBySymbol(symbol));
    };
    /**
     * @hidden
     */
    DateInput.prototype.tryTriggerValueChange = function (args) {
        if (args === void 0) { args = { oldValue: null, event: {} }; }
        if (!isEqual(this.value, args.oldValue)) {
            return this.triggerValueChange(args);
        }
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerValueChange = function (args) {
        if (args === void 0) { args = { oldValue: null, event: {} }; }
        return this.trigger(VALUE_CHANGE, extend(args, {
            value: this.value
        }));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerInput = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(INPUT, extend(args, {
            value: this.value
        }));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerInputEnd = function (args) {
        if (args === void 0) { args = { event: {}, error: null, oldElementValue: '', newElementValue: '' }; }
        return this.trigger(INPUT_END, extend(args, {
            value: this.value
        }));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerFocus = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(FOCUS, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerFocusEnd = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(FOCUS_END, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerBlur = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(BLUR, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerBlurEnd = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(BLUR_END, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerChange = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(CHANGE, extend(args, {
            value: this.value
        }));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerKeyDown = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(KEY_DOWN, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.triggerMouseWheel = function (args) {
        if (args === void 0) { args = { event: {} }; }
        return this.trigger(MOUSE_WHEEL, extend({}, args));
    };
    /**
     * @hidden
     */
    DateInput.prototype.forceUpdate = function () {
        this.setTextAndFormat();
        this.refreshElementValue();
    };
    /**
     * @hidden
     */
    DateInput.prototype.forceUpdateWithSelection = function () {
        var _a = this.selection, start = _a.start, end = _a.end;
        var elementValueLength = this.elementValue.length;
        this.forceUpdate();
        var selectionOffset = this.elementValue.length - elementValueLength;
        this.setSelection({
            start: start + selectionOffset,
            end: end + selectionOffset
        });
    };
    /**
     * @hidden
     */
    DateInput.prototype.setTextAndFormat = function () {
        var _a = this.dateObject.getTextAndFormat(), currentText = _a.text, currentFormat = _a.format;
        this.currentFormat = currentFormat;
        this.currentText = currentText;
    };
    /**
     * @hidden
     */
    DateInput.prototype.setElementValue = function (value) {
        this.element.value = value;
    };
    /**
     * @hidden
     */
    DateInput.prototype.getStepFromSymbol = function (symbol) {
        /* eslint-disable no-fallthrough */
        switch (symbol) {
            case "S":
                return Number(this.options.steps.millisecond);
            case "s":
                return Number(this.options.steps.second);
            case "m":
                return Number(this.options.steps.minute);
            // represents hour as value from 01 through 12
            case "h":
            // represents hour as value from 01 through 23
            case "H":
                return Number(this.options.steps.hour);
            case "M":
                return Number(this.options.steps.month);
            // there is no 'D' format specifier for day
            case "d":
            // used for formats such as "EEEE, MMMM d, yyyy",
            // where "EEEE" stands for full name of the day e.g. Monday
            case "E":
                return Number(this.options.steps.day);
            // there is no 'Y' format specifier for year
            case "y":
                return Number(this.options.steps.year);
            default:
                return DEFAULT_SEGMENT_STEP;
        }
        /* eslint-enable no-fallthrough */
    };
    /**
     * @hidden
     */
    DateInput.prototype.restorePreviousInputEventState = function () {
        this.restorePreviousElementValue();
        this.restorePreviousElementSelection();
    };
    /**
     * @hidden
     */
    DateInput.prototype.restorePreviousElementValue = function () {
        this.setElementValue(this.previousElementValue || '');
    };
    /**
     * @hidden
     */
    DateInput.prototype.restorePreviousElementSelection = function () {
        var _a = this.previousElementSelection, start = _a.start, end = _a.end;
        this.setSelection({ start: start || 0, end: end || 0 });
    };
    DateInput.prototype.writeValue = function (value) {
        this.verifyValue(value);
        this.dateObject = this.getDateObject(value);
        this.refreshElementValue();
    };
    DateInput.prototype.verifyValue = function (value) {
        if (value && !isValidDate(value)) {
            throw new Error("The 'value' should be a valid JavaScript Date instance.");
        }
    };
    DateInput.prototype.refreshElementValue = function () {
        var element = this.element;
        var format = this.isActive ? this.inputFormat : this.displayFormat;
        var _a = this.dateObject.getTextAndFormat(format), currentText = _a.text, currentFormat = _a.format;
        this.currentFormat = currentFormat;
        this.currentText = currentText;
        var hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);
        var showPlaceholder = !this.isActive &&
            hasPlaceholder &&
            !this.dateObject.hasValue();
        if (hasPlaceholder && isPresent(this.options.placeholder)) {
            element.placeholder = this.options.placeholder;
        }
        var newElementValue = showPlaceholder ? "" : currentText;
        this.previousElementValue = this.elementValue;
        this.setElementValue(newElementValue);
    };
    /**
     * @hidden
     */
    DateInput.prototype.caret = function (start, end) {
        if (end === void 0) { end = start; }
        var isPosition = start !== undefined;
        var returnValue = [start, start];
        var element = this.element;
        if (isPosition && (this.options.disabled || this.options.readonly)) {
            return undefined;
        }
        try {
            if (element.selectionStart !== undefined) {
                if (isPosition) {
                    if (isDocumentAvailable() && document.activeElement !== element) {
                        element.focus();
                    }
                    element.setSelectionRange(start, end);
                }
                returnValue = [element.selectionStart, element.selectionEnd];
            }
        }
        catch (e) {
            returnValue = [];
        }
        return returnValue;
    };
    DateInput.prototype.selectNearestSegment = function (index) {
        // Finds the nearest (in both directions) known part.
        for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
            if (i < this.currentFormat.length && this.currentFormat[i] !== "_") {
                this.selectDateSegment(this.currentFormat[i]);
                return;
            }
            if (j >= 0 && this.currentFormat[j] !== "_") {
                this.selectDateSegment(this.currentFormat[j]);
                return;
            }
        }
    };
    DateInput.prototype.selectDateSegment = function (symbol) {
        var begin = -1;
        var end = 0;
        for (var i = 0; i < this.currentFormat.length; i++) {
            if (this.currentFormat[i] === symbol) {
                end = i + 1;
                if (begin === -1) {
                    begin = i;
                }
            }
        }
        if (begin < 0) {
            begin = 0;
        }
        this.caret(0, 0);
        this.caret(begin, end);
    };
    /**
     * @hidden
     */
    DateInput.prototype.getDateObject = function (value) {
        var leadingZero = ((this.dateObject || {}) || null).leadingZero;
        this.options.value = value;
        var dateObject = this.createDateObject();
        dateObject.setLeadingZero(this.isActive ? leadingZero : null);
        return dateObject;
    };
    /* tslint:disable:align */
    /**
     * @hidden
     */
    DateInput.prototype.createDateObject = function () {
        var defaultOptions = this.getDateObjectOptions();
        var dateObject = new DateObject(extend({}, defaultOptions));
        return dateObject;
    };
    /**
     * @hidden
     */
    DateInput.prototype.getDateObjectOptions = function () {
        var newOptions = {
            intlService: this.options.intlService,
            formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : 'formatPattern',
            format: this.inputFormat,
            cycleTime: this.options.cycleTime,
            twoDigitYearMax: this.options.twoDigitYearMax,
            autoCorrectParts: this.options.autoCorrectParts,
            value: this.options.value,
            toggleDayPeriod: this.options.toggleDayPeriod
        };
        return newOptions;
    };
    /* tslint:enable:align */
    /**
     * @hidden
     */
    DateInput.prototype.keyEventMatchesAutoSwitchKeys = function (keyObject) {
        var autoSwitchKeys = (this.options.autoSwitchKeys || [])
            .map(function (x) { return x.toString().toLowerCase().trim(); });
        if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 ||
            autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 ||
            autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {
            return true;
        }
        return false;
    };
    /**
     * @hidden
     */
    DateInput.prototype.autoFill = function () {
        var dateObject = this.dateObject, currentDate = new Date(), day, month, year, hours, minutes, seconds;
        if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {
            year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(),
                month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(),
                day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(),
                hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(),
                minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(),
                seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();
            dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));
            this.refreshElementValue();
            this.triggerValueChange();
        }
    };
    return DateInput;
}(Observable));
export { DateInput };
