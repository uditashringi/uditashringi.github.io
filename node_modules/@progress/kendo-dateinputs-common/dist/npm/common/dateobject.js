"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_date_math_1 = require("@progress/kendo-date-math");
var mask_1 = require("./mask");
var utils_1 = require("../dateinput/utils");
var utils_2 = require("./utils");
var constants_1 = require("./constants");
var MONTH_INDEX_FEBRUARY = 1;
var DEFAULT_LEAP_YEAR = 2000;
var PREVIOUS_CENTURY_BASE = 1900;
var CURRENT_CENTURY_BASE = 2000;
var SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;
var MONTH_PART_WITH_WORDS_THRESHOLD = 2;
var MONTH_SYMBOL = "M";
// JS months start from 0 (January) instead of 1 (January)
var JS_MONTH_OFFSET = 1;
var DateObject = /** @class */ (function () {
    function DateObject(_a) {
        var intlService = _a.intlService, formatPlaceholder = _a.formatPlaceholder, format = _a.format, _b = _a.cycleTime, cycleTime = _b === void 0 ? false : _b, _c = _a.twoDigitYearMax, twoDigitYearMax = _c === void 0 ? constants_1.Constants.twoDigitYearMax : _c, _d = _a.value, value = _d === void 0 ? null : _d, _e = _a.autoCorrectParts, autoCorrectParts = _e === void 0 ? true : _e, _f = _a.toggleDayPeriod, toggleDayPeriod = _f === void 0 ? false : _f;
        this.year = true;
        this.month = true;
        this.date = true;
        this.hours = true;
        this.minutes = true;
        this.seconds = true;
        this.milliseconds = true;
        this.dayperiod = true;
        this.leadingZero = null;
        this.typedMonthPart = '';
        this.knownParts = 'adHhmMsEyS';
        this.symbols = {
            'E': 'E',
            'H': 'H',
            'M': 'M',
            'a': 'a',
            'd': 'd',
            'h': 'h',
            'm': 'm',
            's': 's',
            'y': 'y',
            'S': 'S'
        };
        this._value = this.getDefaultDate();
        this.cycleTime = false;
        this._partiallyInvalidDate = {
            startDate: null,
            invalidDateParts: {
                'E': { value: null, date: null, startDateOffset: 0 },
                'H': { value: null, date: null, startDateOffset: 0 },
                'M': { value: null, date: null, startDateOffset: 0 },
                'a': { value: null, date: null, startDateOffset: 0 },
                'd': { value: null, date: null, startDateOffset: 0 },
                'h': { value: null, date: null, startDateOffset: 0 },
                'm': { value: null, date: null, startDateOffset: 0 },
                's': { value: null, date: null, startDateOffset: 0 },
                'y': { value: null, date: null, startDateOffset: 0 },
                'S': { value: null, date: null, startDateOffset: 0 }
            }
        };
        this.setOptions({
            intlService: intlService,
            formatPlaceholder: formatPlaceholder,
            format: format,
            cycleTime: cycleTime,
            twoDigitYearMax: twoDigitYearMax,
            value: value,
            autoCorrectParts: autoCorrectParts,
            toggleDayPeriod: toggleDayPeriod
        });
        if (!value) {
            this._value = this.getDefaultDate();
            var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
            for (var i = 0; i < sampleFormat.length; i++) {
                this.setExisting(sampleFormat[i], false);
            }
        }
        else {
            this._value = kendo_date_math_1.cloneDate(value);
        }
    }
    Object.defineProperty(DateObject.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (value) {
            if (value && !(value instanceof Date)) {
                // throw new Error("The 'value' should be a valid JavaScript Date instance.");
                return;
            }
            this._value = value;
            this.resetInvalidDate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateObject.prototype, "localeId", {
        get: function () {
            var localeId = constants_1.Constants.defaultLocaleId;
            var cldrKeys = Object.keys(this.intl.cldr);
            for (var i = 0; i < cldrKeys.length; i++) {
                var key = cldrKeys[i];
                var value = this.intl.cldr[key];
                if (value.name && value.calendar && value.numbers &&
                    value.name !== constants_1.Constants.defaultLocaleId) {
                    localeId = value.name;
                    break;
                }
            }
            return localeId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DateObject.prototype.setOptions = function (options) {
        this.intl = options.intlService;
        this.formatPlaceholder = options.formatPlaceholder || 'wide';
        this.format = options.format;
        this.cycleTime = options.cycleTime;
        this.monthNames = this.allFormattedMonths(this.localeId);
        this.dayPeriods = this.allDayPeriods(this.localeId);
        this.twoDigitYearMax = options.twoDigitYearMax;
        this.autoCorrectParts = options.autoCorrectParts;
        this.toggleDayPeriod = options.toggleDayPeriod;
    };
    DateObject.prototype.setValue = function (value) {
        if (!value) {
            this._value = this.getDefaultDate();
            this.modifyExisting(false);
        }
        else if (!kendo_date_math_1.isEqual(value, this._value)) {
            this._value = kendo_date_math_1.cloneDate(value);
            this.modifyExisting(true);
        }
        this.resetInvalidDate();
    };
    /**
     * @hidden
     */
    DateObject.prototype.hasValue = function () {
        var _this = this;
        var pred = function (a, p) { return a || p.type !== 'literal' && p.type !== 'dayperiod' && _this.getExisting(p.pattern[0]); };
        return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);
    };
    /**
     * @hidden
     */
    DateObject.prototype.getValue = function () {
        for (var i = 0; i < this.knownParts.length; i++) {
            if (!this.getExisting(this.knownParts[i])) {
                return null;
            }
        }
        return kendo_date_math_1.cloneDate(this.value);
    };
    /**
     * @hidden
     */
    DateObject.prototype.createDefaultDate = function () {
        // use the leap year 2000 that has 29th February
        // and a month that has 31 days
        // so that the default date can accommodate maximum date values
        // it is better to use a fixed date instead of new Date()
        // as otherwise the
        return kendo_date_math_1.createDate(DEFAULT_LEAP_YEAR, 0, 31);
    };
    /**
     * @hidden
     */
    DateObject.prototype.getDefaultDate = function () {
        return kendo_date_math_1.getDate(this.createDefaultDate());
    };
    /**
     * @hidden
     */
    DateObject.prototype.getFormattedDate = function (format) {
        return this.intl.formatDate(this.getValue(), format, this.localeId);
    };
    /**
     * @hidden
     */
    DateObject.prototype.getTextAndFormat = function (customFormat) {
        if (customFormat === void 0) { customFormat = ""; }
        var format = customFormat || this.format;
        var text = this.intl.formatDate(this.value, format, this.localeId);
        var mask = this.dateFormatString(this.value, format);
        if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {
            var partiallyInvalidText = "";
            var formattedDate = this.intl.formatDate(this.value, format, this.localeId);
            var formattedDates = this.getFormattedInvalidDates(format);
            for (var i = 0; i < formattedDate.length; i++) {
                var symbol = mask.symbols[i];
                if (mask.partMap[i].type === "literal") {
                    partiallyInvalidText += text[i];
                }
                else if (this.getInvalidDatePartValue(symbol)) {
                    var partsForSegment = this.getPartsForSegment(mask, i);
                    if (symbol === "M") {
                        var datePartText = (utils_2.parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                        if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                            partiallyInvalidText += formattedDates[symbol][i];
                        }
                        else {
                            if (this.getInvalidDatePartValue(symbol)) {
                                var formattedDatePart = utils_1.padZero(partsForSegment.length - datePartText.length) + datePartText;
                                partiallyInvalidText += formattedDatePart;
                                // add -1 as the first character in the segment is at index i
                                i += partsForSegment.length - 1;
                            }
                            else {
                                partiallyInvalidText += formattedDates[symbol][i];
                            }
                        }
                    }
                    else {
                        if (this.getInvalidDatePartValue(symbol)) {
                            var datePartText = this.getInvalidDatePartValue(symbol).toString();
                            var formattedDatePart = utils_1.padZero(partsForSegment.length - datePartText.length) + datePartText;
                            partiallyInvalidText += formattedDatePart;
                            // add -1 as the first character in the segment is at index i
                            i += partsForSegment.length - 1;
                        }
                        else {
                            partiallyInvalidText += formattedDates[symbol][i];
                        }
                    }
                }
                else {
                    partiallyInvalidText += text[i];
                }
            }
            text = partiallyInvalidText;
        }
        var result = this.merge(text, mask);
        return result;
    };
    /**
     * @hidden
     */
    DateObject.prototype.getFormattedInvalidDates = function (customFormat) {
        var _this = this;
        if (customFormat === void 0) { customFormat = ""; }
        var format = customFormat || this.format;
        var formattedDatesForSymbol = {
            'E': '',
            'H': '',
            'M': '',
            'a': '',
            'd': '',
            'h': '',
            'm': '',
            's': '',
            'y': '',
            'S': ''
        };
        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function (key) {
            var date = _this.getInvalidDatePart(key).date;
            if (date) {
                var formattedInvalidDate = _this.intl.formatDate(date, format, _this.localeId);
                formattedDatesForSymbol[key] = formattedInvalidDate;
            }
        });
        return formattedDatesForSymbol;
    };
    DateObject.prototype.modifyExisting = function (value) {
        var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
        for (var i = 0; i < sampleFormat.length; i++) {
            this.setExisting(sampleFormat[i], value);
        }
    };
    /**
     * @hidden
     */
    DateObject.prototype.getExisting = function (symbol) {
        switch (symbol) {
            case 'y': return this.year;
            case 'M':
            case 'L': return this.month;
            case 'd': return this.date;
            case 'E': return this.date && this.month && this.year;
            case 'h':
            case 'H': return this.hours;
            case 't':
            case 'a': return this.dayperiod;
            case 'm': return this.minutes;
            case 's': return this.seconds;
            case "S": return this.milliseconds;
            default:
                return true;
        }
    };
    DateObject.prototype.setExisting = function (symbol, value) {
        switch (symbol) {
            case 'y':
                // allow 2/29 dates
                this.year = value;
                if (value === false) {
                    this._value.setFullYear(DEFAULT_LEAP_YEAR);
                }
                break;
            case 'M':
                // make sure you can type 31 in the day part
                this.month = value;
                if (value === false) {
                    if (this.autoCorrectParts) {
                        this._value.setMonth(0);
                    }
                }
                break;
            case 'd':
                this.date = value;
                break;
            case 'h':
            case 'H':
                this.hours = value;
                break;
            case 't':
            case 'a':
                this.dayperiod = value;
                break;
            case 'm':
                this.minutes = value;
                break;
            case 's':
                this.seconds = value;
                break;
            case "S":
                this.milliseconds = value;
                break;
            default:
                break;
        }
        if (this.getValue()) {
            this.resetInvalidDate();
        }
    };
    DateObject.prototype.modifyPart = function (symbol, offset) {
        if (!utils_2.isPresent(symbol) || !utils_2.isPresent(offset) || offset === 0) {
            return;
        }
        var newValue = kendo_date_math_1.cloneDate(this.value);
        var timeModified = false;
        var invalidDateFound;
        var isMonth = symbol === "M";
        var isDay = symbol === "d" || symbol === "E";
        var symbolExists = this.getExisting(symbol);
        if (!this.autoCorrectParts && (isDay || isMonth)) {
            var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
            var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
            var year = invalidDateParts.y.value || newValue.getFullYear();
            var month = invalidDateParts.M.value || newValue.getMonth();
            var day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
            var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
            var minutes = invalidDateParts.m.value || newValue.getMinutes();
            var seconds = invalidDateParts.s.value || newValue.getSeconds();
            var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
            switch (symbol) {
                case 'y':
                    year += offset;
                    break;
                case 'M':
                    month += offset;
                    break;
                case 'd':
                case 'E':
                    day += offset;
                    break;
                // case 'h':
                // case 'H': hour += offset; break;
                // case 'm': minutes += offset; break;
                // case 's': seconds += offset; break;
                // case 'S': milliseconds += offset; break;
                default: break;
            }
            if (symbol === "M") {
                if ((month < 0 || month > 11)) {
                    if (symbolExists) {
                        this.setExisting(symbol, false);
                        this.resetInvalidDateSymbol(symbol);
                        return;
                    }
                }
                if (!symbolExists) {
                    if (month < 0) {
                        month = utils_2.clamp(11 + ((month % 11) + 1), 0, 11);
                    }
                    else {
                        var monthValue = utils_2.isPresent(invalidDatePartValue) ?
                            month :
                            ((offset - JS_MONTH_OFFSET) % 12);
                        month = utils_2.clamp(monthValue, 0, 11);
                    }
                    month = utils_2.clamp(month, 0, 11);
                }
                month = utils_2.clamp(month, 0, 11);
            }
            else if (symbol === "d") {
                if (symbolExists) {
                    if (day <= 0 || day > 31) {
                        this.setExisting(symbol, false);
                        this.resetInvalidDateSymbol(symbol);
                        return;
                    }
                }
                else if (!symbolExists) {
                    if (utils_2.isPresent(invalidDatePartValue)) {
                        if (day <= 0 || day > 31) {
                            this.setExisting(symbol, false);
                            this.resetInvalidDateSymbol(symbol);
                            return;
                        }
                    }
                    if (offset < 0) {
                        var dayValue = utils_2.isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset % 31));
                        day = utils_2.clamp(dayValue, 1, 31);
                    }
                    else {
                        var dayValue = utils_2.isPresent(invalidDatePartValue) ? day : offset % 31;
                        day = utils_2.clamp(dayValue, 1, 31);
                    }
                    day = utils_2.clamp(day, 1, 31);
                }
            }
            var dateCandidate = kendo_date_math_1.createDate(year, month, day, hour, minutes, seconds, milliseconds);
            var newValueCandidate = isMonth || isDay ?
                this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) :
                null;
            var dateCandidateExists = utils_2.areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
            if (this.getValue() && utils_2.areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {
                newValue = kendo_date_math_1.cloneDate(dateCandidate);
                this.markDatePartsAsExisting();
            }
            else if (isMonth && newValueCandidate) {
                if (newValueCandidate.getMonth() === month) {
                    if (this.getExisting("d")) {
                        if (dateCandidateExists) {
                            newValue = kendo_date_math_1.cloneDate(dateCandidate);
                            this.resetInvalidDateSymbol(symbol);
                        }
                        else {
                            invalidDateFound = true;
                            this.setInvalidDatePart(symbol, {
                                value: month,
                                date: kendo_date_math_1.cloneDate(newValueCandidate),
                                startDateOffset: offset,
                                startDate: kendo_date_math_1.cloneDate(this.value)
                            });
                            this.setExisting(symbol, false);
                        }
                    }
                    else if (dateCandidateExists) {
                        this.resetInvalidDateSymbol(symbol);
                        newValue = kendo_date_math_1.cloneDate(dateCandidate);
                        if (this.getExisting("M") && this.getExisting("y")) {
                            // changing from 28/Feb to 29/Feb to 29/March
                            this.setExisting("d", true);
                            this.resetInvalidDateSymbol("d");
                        }
                    }
                    else {
                        this.resetInvalidDateSymbol(symbol);
                        newValue = kendo_date_math_1.cloneDate(newValueCandidate);
                    }
                }
                else {
                    invalidDateFound = true;
                    this.setInvalidDatePart(symbol, {
                        value: month,
                        date: kendo_date_math_1.cloneDate(newValueCandidate),
                        startDateOffset: offset,
                        startDate: kendo_date_math_1.cloneDate(this.value)
                    });
                    this.setExisting(symbol, false);
                }
            }
            else if (isDay && newValueCandidate) {
                if (newValueCandidate.getDate() === day) {
                    if (this.getExisting("M")) {
                        if (dateCandidateExists) {
                            newValue = kendo_date_math_1.cloneDate(dateCandidate);
                            this.resetInvalidDateSymbol(symbol);
                        }
                        else {
                            invalidDateFound = true;
                            this.setInvalidDatePart(symbol, {
                                value: day,
                                date: kendo_date_math_1.cloneDate(newValueCandidate),
                                startDateOffset: offset,
                                startDate: kendo_date_math_1.cloneDate(this.value)
                            });
                            this.setExisting(symbol, false);
                        }
                    }
                    else if (dateCandidateExists) {
                        newValue = kendo_date_math_1.cloneDate(dateCandidate);
                        this.resetInvalidDateSymbol(symbol);
                        if (this.getExisting("d") && this.getExisting("y")) {
                            // changing from 31/Jan to 31/Feb to 28/Feb
                            this.setExisting("M", true);
                            this.resetInvalidDateSymbol("M");
                        }
                    }
                    else {
                        this.resetInvalidDateSymbol(symbol);
                        newValue = kendo_date_math_1.cloneDate(newValueCandidate);
                    }
                }
                else {
                    invalidDateFound = true;
                    this.setInvalidDatePart(symbol, {
                        value: day,
                        date: kendo_date_math_1.cloneDate(this.value),
                        startDateOffset: offset,
                        startDate: kendo_date_math_1.cloneDate(this.value)
                    });
                    this.setExisting(symbol, false);
                }
            }
        }
        else {
            switch (symbol) {
                case 'y':
                    newValue.setFullYear(newValue.getFullYear() + offset);
                    break;
                case 'M':
                    newValue = kendo_date_math_1.addMonths(this.value, offset);
                    break;
                case 'd':
                case 'E':
                    newValue.setDate(newValue.getDate() + offset);
                    break;
                case 'h':
                case 'H':
                    newValue.setHours(newValue.getHours() + offset);
                    timeModified = true;
                    break;
                case 'm':
                    newValue.setMinutes(newValue.getMinutes() + offset);
                    timeModified = true;
                    break;
                case 's':
                    newValue.setSeconds(newValue.getSeconds() + offset);
                    timeModified = true;
                    break;
                case "S":
                    newValue.setMilliseconds(newValue.getMilliseconds() + offset);
                    break;
                case 'a':
                    var hours = newValue.getHours();
                    if (this.toggleDayPeriod) {
                        newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);
                    }
                    else {
                        newValue.setHours(newValue.getHours() + (12 * offset));
                    }
                    timeModified = true;
                    break;
                default: break;
            }
        }
        if (this.shouldNormalizeCentury()) {
            newValue = this.normalizeCentury(newValue);
        }
        if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {
            // todo: blazor has this fix, but this fails a unit test
            // newValue.setDate(this._value.getDate());
            // newValue.setMonth(this._value.getMonth());
            // newValue.setFullYear(this._value.getFullYear());
        }
        if (!invalidDateFound) {
            this.setExisting(symbol, true);
            this._value = newValue;
            if (this.getValue()) {
                this.resetInvalidDate();
            }
        }
    };
    /**
     * @hidden
     */
    DateObject.prototype.parsePart = function (_a) {
        var symbol = _a.symbol, currentChar = _a.currentChar, resetSegmentValue = _a.resetSegmentValue, cycleSegmentValue = _a.cycleSegmentValue, rawInputValue = _a.rawTextValue, isDeleting = _a.isDeleting, originalFormat = _a.originalFormat;
        var isInCaretMode = !cycleSegmentValue;
        var dateParts = this.dateFormatString(this.value, this.format);
        var datePartsLiterals = dateParts.partMap
            .filter(function (x) { return x.type === "literal"; })
            .map(function (x, index) {
            return {
                datePartIndex: index,
                type: x.type,
                pattern: x.pattern,
                literal: ""
            };
        });
        var flatDateParts = dateParts.partMap
            .map(function (x) {
            return {
                type: x.type,
                pattern: x.pattern,
                text: ""
            };
        });
        for (var i = 0; i < datePartsLiterals.length; i++) {
            var datePart = datePartsLiterals[i];
            for (var j = 0; j < datePart.pattern.length; j++) {
                if (datePartsLiterals[i + j]) {
                    datePartsLiterals[i + j].literal = datePart.pattern[j];
                }
            }
            i += datePart.pattern.length - 1;
        }
        for (var i = 0; i < flatDateParts.length; i++) {
            var datePart = flatDateParts[i];
            for (var j = 0; j < datePart.pattern.length; j++) {
                if (flatDateParts[i + j]) {
                    flatDateParts[i + j].text = datePart.pattern[j];
                }
            }
            i += datePart.pattern.length - 1;
        }
        var shouldResetPart = isInCaretMode && symbol === "M" && dateParts.partMap
            .filter(function (x) { return x.type === "month"; })
            .some(function (x) { return x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD; });
        var parseResult = {
            value: null,
            switchToNext: false,
            resetPart: shouldResetPart,
            hasInvalidDatePart: false
        };
        if (!currentChar) {
            if (isInCaretMode) {
                for (var i = 0; i < datePartsLiterals.length; i++) {
                    var literal = datePartsLiterals[i].literal;
                    var rawValueStartsWithLiteral = rawInputValue.startsWith(literal);
                    var rawValueEndsWithLiteral = rawInputValue.endsWith(literal);
                    var rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;
                    if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {
                        this.resetLeadingZero();
                        this.setExisting(symbol, false);
                        this.resetInvalidDateSymbol(symbol);
                        return utils_2.extend(parseResult, { value: null, switchToNext: false });
                    }
                }
            }
            else {
                this.resetLeadingZero();
                this.setExisting(symbol, false);
                this.resetInvalidDateSymbol(symbol);
                return utils_2.extend(parseResult, { value: null, switchToNext: false });
            }
        }
        var baseDate = this.intl.formatDate(this.value, this.format, this.localeId);
        var baseFormat = dateParts.symbols;
        var replaced = false;
        var prefix = '';
        var current = '';
        var datePartText = '';
        var basePrefix = '';
        var baseSuffix = '';
        var suffix = '';
        var convertedBaseFormat = "";
        for (var i = 0; i < flatDateParts.length; i++) {
            convertedBaseFormat += flatDateParts[i].text;
        }
        var hasFixedFormat = (this.format === baseFormat) ||
            (this.format === convertedBaseFormat) ||
            (this.format === originalFormat) ||
            (this.format.length === originalFormat.length);
        var datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);
        var datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);
        var segmentLength = datePartEndIndex - datePartStartIndex + 1;
        var formatToTextLengthDiff = originalFormat.length - rawInputValue.length;
        if (isInCaretMode || (!isInCaretMode && !this.autoCorrectParts)) {
            for (var i = 0; i < baseDate.length; i++) {
                if (baseFormat[i] === symbol) {
                    var existing = this.getExisting(symbol);
                    current += existing ? baseDate[i] : '0';
                    if (formatToTextLengthDiff > 0) {
                        if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                            datePartText += rawInputValue[i] || "";
                        }
                    }
                    else {
                        datePartText += rawInputValue[i] || "";
                    }
                    replaced = true;
                }
                else if (!replaced) {
                    prefix += baseDate[i];
                    basePrefix += baseDate[i];
                }
                else {
                    suffix += baseDate[i];
                    baseSuffix += baseDate[i];
                }
            }
            if (hasFixedFormat) {
                if (convertedBaseFormat.length < rawInputValue.length) {
                    datePartText += currentChar;
                }
                else if (!isDeleting && originalFormat.length > rawInputValue.length) {
                    // let the parsing to determine if the incomplete value is valid
                }
                if (datePartText.length > segmentLength) {
                    return utils_2.extend(parseResult, { value: null, switchToNext: false });
                }
            }
            if (!hasFixedFormat || (hasFixedFormat && !this.autoCorrectParts)) {
                current = "";
                datePartText = "";
                prefix = "";
                suffix = "";
                replaced = false;
                for (var i = 0; i < originalFormat.length; i++) {
                    if (originalFormat[i] === symbol) {
                        var existing = this.getExisting(symbol);
                        current += existing ? baseDate[i] || "" : '0';
                        if (formatToTextLengthDiff > 0) {
                            if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                                datePartText += rawInputValue[i] || "";
                            }
                        }
                        else {
                            datePartText += rawInputValue[i] || "";
                        }
                        replaced = true;
                    }
                    else if (!replaced) {
                        prefix += rawInputValue[i] || "";
                    }
                    else {
                        suffix += rawInputValue[i - formatToTextLengthDiff] || "";
                    }
                }
                if (originalFormat.length < rawInputValue.length) {
                    datePartText += currentChar;
                }
            }
        }
        if (!isInCaretMode) {
            if (this.autoCorrectParts) {
                current = "";
                datePartText = "";
                prefix = "";
                suffix = "";
                replaced = false;
                for (var i = 0; i < baseDate.length; i++) {
                    if (baseFormat[i] === symbol) {
                        var existing = this.getExisting(symbol);
                        current += existing ? baseDate[i] : '0';
                        replaced = true;
                    }
                    else if (!replaced) {
                        prefix += baseDate[i];
                    }
                    else {
                        suffix += baseDate[i];
                    }
                }
            }
            else {
                current = resetSegmentValue ? datePartText : current;
            }
        }
        var parsedDate = null;
        var month = this.matchMonth(currentChar);
        var dayPeriod = this.matchDayPeriod(currentChar, symbol);
        var isZeroCurrentChar = currentChar === '0';
        var leadingZero = this.leadingZero || {};
        if (isZeroCurrentChar) {
            if (datePartText === "0") {
                datePartText = current;
            }
            var valueNumber = utils_2.parseToInt(resetSegmentValue ?
                currentChar :
                (isInCaretMode ? datePartText : current) + currentChar);
            if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {
                this.incrementLeadingZero(symbol);
            }
        }
        else {
            this.resetLeadingZero();
        }
        var partPattern = this.partPattern(dateParts.partMap, symbol);
        var patternValue = partPattern ? partPattern.pattern : null;
        var patternLength = this.patternLength(patternValue) || patternValue.length;
        if (isInCaretMode) {
            if (isDeleting && !datePartText) {
                this.setExisting(symbol, false);
                return utils_2.extend(parseResult, { value: null, switchToNext: false });
            }
        }
        var currentMaxLength = current.length - 3;
        var tryParse = true;
        var middle = isInCaretMode ? datePartText : current;
        for (var i = Math.max(0, currentMaxLength); i <= current.length; i++) {
            if (!tryParse) {
                break;
            }
            middle = resetSegmentValue ?
                currentChar :
                isInCaretMode ?
                    datePartText :
                    (current.substring(i) + currentChar);
            if (isInCaretMode || !this.autoCorrectParts) {
                tryParse = false;
                middle = utils_1.unpadZero(middle);
                // middle = padZero(segmentLength - middle.length) + middle;
                middle = utils_1.padZero(patternLength - middle.length) + middle;
            }
            var middleNumber = parseInt(middle, 10);
            var candidateDateString = prefix + middle + suffix;
            parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);
            var autoCorrectedPrefixAndSuffix = false;
            if (isInCaretMode && !utils_2.isValidDate(parsedDate)) {
                // if part of the date is not available, e.g. "d"
                // but an expanded format like "F" is used
                // the element value can be "EEEE, February 1, 2022 3:04:05 AM"
                // which is not parsable by intl
                // use the base prefix and suffix, e.g. convert the candidate date string
                // to "Thursday, February 1, 2022 3:04:05 AM"
                // as "EEEE, February..." is not parsable
                if (this.autoCorrectParts) {
                    parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
                    autoCorrectedPrefixAndSuffix = true;
                }
            }
            var isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || (isInCaretMode && isDeleting && currentChar === "");
            if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {
                if (symbol === MONTH_SYMBOL && !month) {
                    // JS months start from 0 (January) instead of 1 (January)
                    var monthNumber = middleNumber - JS_MONTH_OFFSET;
                    if (monthNumber > -1 && monthNumber < 12) {
                        parsedDate = kendo_date_math_1.cloneDate(this.value);
                        parsedDate.setMonth(monthNumber);
                        if (parsedDate.getMonth() !== monthNumber) {
                            parsedDate = kendo_date_math_1.lastDayOfMonth(kendo_date_math_1.addMonths(parsedDate, -1));
                        }
                    }
                }
                if (symbol === 'y') {
                    parsedDate = kendo_date_math_1.createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);
                    if (((isInCaretMode && utils_2.isValidDate(parsedDate)) ||
                        (!isInCaretMode && parsedDate)) && this.date && parsedDate.getDate() !== this.value.getDate()) {
                        parsedDate = kendo_date_math_1.lastDayOfMonth(kendo_date_math_1.addMonths(parsedDate, -1));
                    }
                }
            }
            if ((isInCaretMode && utils_2.isValidDate(parsedDate)) || (!isInCaretMode && parsedDate)) {
                // move to next segment if the part will overflow with next char
                // when start from empty date (01, then 010), padded zeros should be trimmed
                var peekResult = this.isPeekDateOverflowingDatePart({
                    useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,
                    middle: middle,
                    patternValue: patternValue,
                    basePrefix: basePrefix,
                    baseSuffix: baseSuffix,
                    prefix: prefix,
                    suffix: suffix,
                    symbol: symbol,
                    patternLength: patternLength,
                    leadingZero: leadingZero
                });
                var switchToNext = peekResult.switchToNext;
                if (this.shouldNormalizeCentury()) {
                    parsedDate = this.normalizeCentury(parsedDate);
                }
                if (symbol === 'H' && parsedDate.getHours() >= 12) {
                    this.setExisting('a', true);
                }
                this._value = parsedDate;
                this.setExisting(symbol, true);
                this.resetInvalidDateSymbol(symbol);
                if (!this.autoCorrectParts) {
                    if (symbol === "M") {
                        if (this.getExisting("M") && this.getExisting("y")) {
                            // changing from 28/Feb to 29/Feb to 29/March
                            this.setExisting("d", true);
                            this.resetInvalidDateSymbol("d");
                        }
                    }
                    else if (symbol === "d") {
                        if (this.getExisting("d") && this.getExisting("y")) {
                            // changing from 31/Jan to 31/Feb to 28/Feb
                            this.setExisting("M", true);
                            this.resetInvalidDateSymbol("M");
                        }
                    }
                    if (!this.hasInvalidDatePart()) {
                        this.markDatePartsAsExisting();
                        if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {
                            if (symbol === "M") {
                                // skip processing the month
                            }
                            else if (symbol === "d") {
                                if (peekResult.parsedPeekedValue === 30 &&
                                    this.value.getMonth() === MONTH_INDEX_FEBRUARY) {
                                    // the peekValue cannot be constructed
                                    // as there cannot be more than 29 days in February
                                    // still the segment should not be switched as autoCorrectParts="false"
                                    // should allow typing "30"
                                    switchToNext = false;
                                }
                            }
                        }
                    }
                }
                return utils_2.extend(parseResult, { value: this.value, switchToNext: switchToNext });
            }
        }
        if (month) {
            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format, this.localeId);
            if (parsedDate) {
                this._value = parsedDate;
                this.setExisting(symbol, true);
                return utils_2.extend(parseResult, { value: this.value, switchToNext: false });
            }
        }
        if (dayPeriod) {
            parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format) ||
                this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);
            if (parsedDate) {
                this._value = parsedDate;
                this.setExisting(symbol, true);
                return utils_2.extend(parseResult, { value: this.value, switchToNext: true });
            }
        }
        if (isZeroCurrentChar) {
            this.setExisting(symbol, false);
        }
        if (!this.autoCorrectParts) {
            var datePartValue = void 0;
            var textToParse = isInCaretMode ? datePartText : middle;
            var parsedValue = utils_2.parseToInt(textToParse);
            if (utils_2.isNumber(parsedValue) && utils_2.isParseableToInt(textToParse)) {
                if ((symbol === "d" && (parsedValue <= 0 || parsedValue > 31)) ||
                    (symbol === "M" && (parsedValue <= 0 || parsedValue > 11))) {
                    if (isInCaretMode) {
                        return utils_2.extend(parseResult, {
                            value: null,
                            switchToNext: false
                        });
                    }
                    else {
                        // the value overflows the possible value range
                        // thus reset the segment value regardless of the "resetSegmentValue" flag
                        // otherwise the input is ignored and you cannot change the value,
                        // e.g. "03->(press 2)->02" will not work and the user will be blocked on "03"
                        textToParse = currentChar;
                        parsedValue = utils_2.parseToInt(textToParse);
                    }
                }
                if (!utils_2.isNumber(parsedValue) || !utils_2.isParseableToInt(textToParse)) {
                    return utils_2.extend(parseResult, { value: null, switchToNext: false });
                }
                datePartValue = symbol === "M" ?
                    parsedValue - JS_MONTH_OFFSET :
                    parsedValue;
                var isMonth = symbol === "M";
                var isDay = symbol === "d";
                var newValue = kendo_date_math_1.cloneDate(this._value);
                var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
                var year = invalidDateParts.y.value || newValue.getFullYear();
                /* tslint:disable:no-shadowed-variable */
                var month_1 = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();
                /* tslint:enable:no-shadowed-variable */
                var day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
                var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
                var minutes = invalidDateParts.m.value || newValue.getMinutes();
                var seconds = invalidDateParts.s.value || newValue.getSeconds();
                var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
                var dateCandidate = kendo_date_math_1.createDate(year, month_1, day, hour, minutes, seconds, milliseconds);
                var dateCandidateExists = utils_2.areDatePartsEqualTo(dateCandidate, year, month_1, day, hour, minutes, seconds, milliseconds);
                var newValueCandidate = isMonth || isDay ?
                    this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month_1 : day) :
                    null;
                var invalidDateFound = false;
                if (isMonth && newValueCandidate) {
                    if (newValueCandidate.getMonth() === month_1) {
                        if (this.getExisting("d")) {
                            if (dateCandidateExists) {
                                newValue = kendo_date_math_1.cloneDate(dateCandidate);
                                this.resetInvalidDateSymbol(symbol);
                            }
                            else {
                                invalidDateFound = true;
                                this.setInvalidDatePart(symbol, {
                                    value: month_1,
                                    date: kendo_date_math_1.cloneDate(newValueCandidate),
                                    startDate: kendo_date_math_1.cloneDate(this.value)
                                });
                                this.setExisting(symbol, false);
                            }
                        }
                        else if (dateCandidateExists) {
                            this.resetInvalidDateSymbol(symbol);
                            newValue = kendo_date_math_1.cloneDate(dateCandidate);
                            if (this.getExisting("M") && this.getExisting("y")) {
                                // changing from 28/Feb to 29/Feb to 29/March
                                this.setExisting("d", true);
                                this.resetInvalidDateSymbol("d");
                            }
                        }
                        else {
                            this.resetInvalidDateSymbol(symbol);
                            newValue = kendo_date_math_1.cloneDate(newValueCandidate);
                        }
                    }
                    else {
                        invalidDateFound = true;
                        this.setInvalidDatePart(symbol, {
                            value: month_1,
                            date: kendo_date_math_1.cloneDate(newValueCandidate),
                            startDate: kendo_date_math_1.cloneDate(this.value)
                        });
                        this.setExisting(symbol, false);
                    }
                }
                else if (isDay && newValueCandidate) {
                    if (newValueCandidate.getDate() === day) {
                        if (this.getExisting("M")) {
                            if (dateCandidateExists) {
                                newValue = kendo_date_math_1.cloneDate(dateCandidate);
                                this.resetInvalidDateSymbol(symbol);
                            }
                            else {
                                invalidDateFound = true;
                                this.setInvalidDatePart(symbol, {
                                    value: day,
                                    date: kendo_date_math_1.cloneDate(newValueCandidate),
                                    startDate: kendo_date_math_1.cloneDate(this.value)
                                });
                                this.setExisting(symbol, false);
                            }
                        }
                        else if (dateCandidateExists) {
                            newValue = kendo_date_math_1.cloneDate(dateCandidate);
                            this.resetInvalidDateSymbol(symbol);
                            if (this.getExisting("d") && this.getExisting("y")) {
                                // changing from 31/Jan to 31/Feb to 28/Feb
                                this.setExisting("M", true);
                                this.resetInvalidDateSymbol("M");
                            }
                        }
                        else {
                            this.resetInvalidDateSymbol(symbol);
                            newValue = kendo_date_math_1.cloneDate(newValueCandidate);
                        }
                    }
                    else {
                        invalidDateFound = true;
                        this.setInvalidDatePart(symbol, {
                            value: day,
                            date: kendo_date_math_1.cloneDate(this.value),
                            startDate: kendo_date_math_1.cloneDate(this.value)
                        });
                        this.setExisting(symbol, false);
                    }
                }
                if (!invalidDateFound) {
                    this.setExisting(symbol, true);
                    if (isInCaretMode && !utils_2.isValidDate(parsedDate)) {
                        var valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
                        if (utils_2.isValidDate(valueCandidate)) {
                            this._value = valueCandidate;
                        }
                    }
                    else {
                        this._value = newValue;
                    }
                    if (this.getValue()) {
                        this.resetInvalidDate();
                    }
                }
                var switchToNext = false;
                if (symbol === "M") {
                    if (parsedValue >= 2 || textToParse.length >= 2) {
                        switchToNext = true;
                    }
                    else {
                        switchToNext = false;
                    }
                }
                else {
                    if (hasFixedFormat) {
                        var peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({
                            useBasePrefixAndSuffix: !this.autoCorrectParts,
                            middle: middle,
                            patternValue: patternValue,
                            basePrefix: basePrefix,
                            baseSuffix: baseSuffix,
                            prefix: prefix,
                            suffix: suffix,
                            symbol: symbol,
                            patternLength: patternLength,
                            leadingZero: leadingZero
                        }).switchToNext;
                        switchToNext = peekDateSwitchToNext;
                    }
                    else {
                        switchToNext = textToParse.length > segmentLength;
                    }
                }
                return utils_2.extend(parseResult, {
                    value: null,
                    switchToNext: switchToNext,
                    hasInvalidDatePart: invalidDateFound
                });
            }
        }
        return utils_2.extend(parseResult, { value: null, switchToNext: false });
    };
    /**
     * @hidden
     */
    DateObject.prototype.symbolMap = function (symbol) {
        return this.intl.splitDateFormat(this.format, this.localeId).reduce(utils_1.dateSymbolMap, {})[symbol];
    };
    /**
     * @hidden
     */
    DateObject.prototype.resetLeadingZero = function () {
        var hasLeadingZero = this.leadingZero !== null;
        this.setLeadingZero(null);
        return hasLeadingZero;
    };
    DateObject.prototype.setLeadingZero = function (leadingZero) {
        this.leadingZero = leadingZero;
    };
    /**
     * @hidden
     */
    DateObject.prototype.getLeadingZero = function () {
        return this.leadingZero || {};
    };
    /**
     * @hidden
     */
    DateObject.prototype.normalizeCentury = function (date) {
        if (!utils_2.isPresent(date)) {
            return date;
        }
        var twoDigitYear = utils_2.cropTwoDigitYear(date);
        var centuryBase = this.getNormalizedCenturyBase(twoDigitYear);
        var normalizedDate = utils_2.setYears(date, centuryBase + twoDigitYear);
        return normalizedDate;
    };
    DateObject.prototype.incrementLeadingZero = function (symbol) {
        var leadingZero = this.leadingZero || {};
        leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;
        this.leadingZero = leadingZero;
    };
    /**
     * @hidden
     */
    DateObject.prototype.isAbbrMonth = function (parts, symbol) {
        var pattern = this.partPattern(parts, symbol);
        return pattern.type === 'month' && pattern.names;
    };
    /**
     * @hidden
     */
    DateObject.prototype.partPattern = function (parts, symbol) {
        return parts.filter(function (part) { return part.pattern.indexOf(symbol) !== -1; })[0];
    };
    /**
     * @hidden
     */
    DateObject.prototype.peek = function (value, pattern) {
        var peekValue = value.replace(/^0*/, '') + '0';
        return utils_1.padZero(pattern.length - peekValue.length) + peekValue;
    };
    /**
     * @hidden
     */
    DateObject.prototype.matchMonth = function (typedChar) {
        this.typedMonthPart += typedChar.toLowerCase();
        if (this.monthNames.length === 0) {
            return '';
        }
        while (this.typedMonthPart.length > 0) {
            for (var i = 0; i < this.monthNames.length; i++) {
                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {
                    return this.monthNames[i];
                }
            }
            var monthAsNum = parseInt(this.typedMonthPart, 10);
            /* ensure they exact match */
            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {
                return this.monthNames[monthAsNum - 1];
            }
            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
        }
        return '';
    };
    /**
     * @hidden
     */
    DateObject.prototype.matchDayPeriod = function (typedChar, symbol) {
        var lowerChart = typedChar.toLowerCase();
        if (symbol === 'a' && this.dayPeriods) {
            if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {
                return this.dayPeriods.am;
            }
            else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {
                return this.dayPeriods.pm;
            }
        }
        return '';
    };
    /**
     * @hidden
     */
    DateObject.prototype.allFormattedMonths = function (locale) {
        if (locale === void 0) { locale = "en"; }
        var dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);
        for (var i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {
                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
            }
        }
        return [];
    };
    /**
     * @hidden
     */
    DateObject.prototype.allDayPeriods = function (locale) {
        if (locale === void 0) { locale = "en"; }
        var dateFormatParts = this.intl.splitDateFormat(this.format);
        for (var i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].type === "dayperiod" && dateFormatParts[i].names) {
                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
            }
        }
        return null;
    };
    /**
     * @hidden
     */
    DateObject.prototype.patternLength = function (pattern) {
        if (pattern[0] === 'y') {
            return 4;
        }
        if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {
            return 2;
        }
        return 0;
    };
    /**
     * @hidden
     */
    DateObject.prototype.dateFormatString = function (date, format) {
        var dateFormatParts = this.intl.splitDateFormat(format, this.localeId);
        var parts = [];
        var partMap = [];
        for (var i = 0; i < dateFormatParts.length; i++) {
            var partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }, this.localeId).length;
            while (partLength > 0) {
                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || constants_1.Constants.formatSeparator);
                partMap.push(dateFormatParts[i]);
                partLength--;
            }
        }
        var returnValue = new mask_1.Mask();
        returnValue.symbols = parts.join('');
        returnValue.partMap = partMap;
        return returnValue;
    };
    /**
     * @hidden
     */
    DateObject.prototype.merge = function (text, mask) {
        // Important: right to left.
        var resultText = '';
        var resultFormat = '';
        var format = mask.symbols;
        var processTextSymbolsEnded = false;
        var ignoreFormatSymbolsCount = 0;
        var formattedDates = this.getFormattedInvalidDates(format);
        for (var formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {
            var partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);
            if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {
                if (this.autoCorrectParts) {
                    resultText = text[formatSymbolIndex] + resultText;
                }
                else {
                    if (text.length !== format.length) {
                        if (processTextSymbolsEnded) {
                            resultText = text[formatSymbolIndex] + resultText;
                        }
                        else if (ignoreFormatSymbolsCount > 0) {
                            resultText = text[formatSymbolIndex] + resultText;
                            ignoreFormatSymbolsCount--;
                            if (ignoreFormatSymbolsCount <= 0) {
                                processTextSymbolsEnded = true;
                            }
                        }
                        else {
                            resultText = (text[formatSymbolIndex + text.length - format.length] || "") + resultText;
                        }
                    }
                    else {
                        resultText = text[formatSymbolIndex] + resultText;
                    }
                }
                resultFormat = format[formatSymbolIndex] + resultFormat;
            }
            else {
                var symbol = format[formatSymbolIndex];
                var formatSymbolIndexModifier = 0;
                if (this.autoCorrectParts || (!this.autoCorrectParts && !this.getInvalidDatePartValue(symbol))) {
                    while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {
                        formatSymbolIndex--;
                    }
                    formatSymbolIndex++;
                }
                if (this.leadingZero && this.leadingZero[symbol]) {
                    resultText = '0' + resultText;
                }
                else {
                    if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {
                        var datePartText = this.getInvalidDatePartValue(symbol).toString();
                        if (symbol === "M") {
                            datePartText = (utils_2.parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                            if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                                resultText = formattedDates[symbol][formatSymbolIndex] + resultText;
                            }
                            else {
                                datePartText = (utils_2.parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                                var formattedDatePart = utils_1.padZero(partsForSegment.length - datePartText.length) + datePartText;
                                resultText = formattedDatePart + resultText;
                                formatSymbolIndexModifier = partsForSegment.length - 1;
                                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
                            }
                        }
                        else {
                            var formattedDatePart = utils_1.padZero(partsForSegment.length - datePartText.length) + datePartText;
                            resultText = formattedDatePart + resultText;
                            formatSymbolIndexModifier = partsForSegment.length - 1;
                            ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
                        }
                    }
                    else {
                        resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;
                    }
                }
                while (resultFormat.length < resultText.length) {
                    resultFormat = format[formatSymbolIndex] + resultFormat;
                }
                if (formatSymbolIndexModifier !== 0) {
                    formatSymbolIndex = (formatSymbolIndex - formatSymbolIndexModifier) + (text.length - format.length);
                }
            }
        }
        return { text: resultText, format: resultFormat };
    };
    /**
     * @hidden
     */
    DateObject.prototype.dateFieldName = function (part) {
        var formatPlaceholder = this.formatPlaceholder || 'wide';
        if (formatPlaceholder[part.type]) {
            return formatPlaceholder[part.type];
        }
        if (formatPlaceholder === 'formatPattern') {
            return part.pattern;
        }
        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));
    };
    /**
     * @hidden
     */
    DateObject.prototype.getNormalizedCenturyBase = function (twoDigitYear) {
        return twoDigitYear > this.twoDigitYearMax ?
            PREVIOUS_CENTURY_BASE :
            CURRENT_CENTURY_BASE;
    };
    /**
     * @hidden
     */
    DateObject.prototype.shouldNormalizeCentury = function () {
        return this.intl.splitDateFormat(this.format).some(function (part) { return part.pattern === 'yy'; });
    };
    DateObject.prototype.resetInvalidDate = function () {
        var _this = this;
        this._partiallyInvalidDate.startDate = null;
        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function (key) {
            _this.resetInvalidDatePart(key);
        });
    };
    DateObject.prototype.resetInvalidDateSymbol = function (symbol) {
        var _this = this;
        this.resetInvalidDatePart(symbol);
        var shouldResetInvalidDate = true;
        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function (key) {
            if (_this._partiallyInvalidDate.invalidDateParts[key] &&
                utils_2.isPresent(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
                shouldResetInvalidDate = false;
            }
        });
        if (shouldResetInvalidDate) {
            this.resetInvalidDate();
        }
    };
    DateObject.prototype.resetInvalidDatePart = function (symbol) {
        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
            this._partiallyInvalidDate.invalidDateParts[symbol] = {
                value: null,
                date: null,
                startDateOffset: 0
            };
        }
    };
    /**
     * @hidden
     */
    DateObject.prototype.getInvalidDatePart = function (symbol) {
        var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
        return invalidDatePart || {};
    };
    /**
     * @hidden
     */
    DateObject.prototype.getInvalidDatePartValue = function (symbol) {
        var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
        return (invalidDatePart || {}).value;
    };
    DateObject.prototype.setInvalidDatePart = function (symbol, _a) {
        var _b = _a.value, value = _b === void 0 ? null : _b, _c = _a.date, date = _c === void 0 ? null : _c, _d = _a.startDateOffset, startDateOffset = _d === void 0 ? 0 : _d, _e = _a.startDate, startDate = _e === void 0 ? null : _e;
        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
            this._partiallyInvalidDate.invalidDateParts[symbol].value = value;
            this._partiallyInvalidDate.invalidDateParts[symbol].date = date;
            this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;
            this._partiallyInvalidDate.startDate = startDate;
        }
    };
    /**
     * @hidden
     */
    DateObject.prototype.hasInvalidDatePart = function () {
        var _this = this;
        var hasInvalidDatePart = false;
        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function (key) {
            if (_this._partiallyInvalidDate.invalidDateParts[key] &&
                utils_2.isPresent(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
                hasInvalidDatePart = true;
            }
        });
        return hasInvalidDatePart;
    };
    /**
     * @hidden
     */
    DateObject.prototype.modifyDateSymbolWithOffset = function (date, symbol, offset) {
        var newValue = kendo_date_math_1.cloneDate(date);
        var timeModified = false;
        switch (symbol) {
            case 'y':
                newValue.setFullYear(newValue.getFullYear() + offset);
                break;
            case 'M':
                newValue = kendo_date_math_1.addMonths(this.value, offset);
                break;
            case 'd':
            case 'E':
                newValue.setDate(newValue.getDate() + offset);
                break;
            case 'h':
            case 'H':
                newValue.setHours(newValue.getHours() + offset);
                timeModified = true;
                break;
            case 'm':
                newValue.setMinutes(newValue.getMinutes() + offset);
                timeModified = true;
                break;
            case 's':
                newValue.setSeconds(newValue.getSeconds() + offset);
                timeModified = true;
                break;
            case "S":
                newValue.setMilliseconds(newValue.getMilliseconds() + offset);
                break;
            case 'a':
                newValue.setHours(newValue.getHours() + (12 * offset));
                timeModified = true;
                break;
            default: break;
        }
        return {
            date: newValue,
            timeModified: timeModified
        };
    };
    /**
     * @hidden
     */
    DateObject.prototype.modifyDateSymbolWithValue = function (date, symbol, value) {
        var newValue = kendo_date_math_1.cloneDate(date);
        switch (symbol) {
            case 'y':
                newValue.setFullYear(value);
                break;
            case 'M':
                newValue = kendo_date_math_1.addMonths(date, value - date.getMonth());
                break;
            case 'd':
            case 'E':
                newValue.setDate(value);
                break;
            case 'h':
            case 'H':
                newValue.setHours(value);
                break;
            case 'm':
                newValue.setMinutes(value);
                break;
            case 's':
                newValue.setSeconds(value);
                break;
            case "S":
                newValue.setMilliseconds(value);
                break;
            case 'a':
                newValue.setHours(value);
                break;
            default: break;
        }
        return newValue;
    };
    DateObject.prototype.markDatePartsAsExisting = function () {
        this.modifyExisting(true);
    };
    /**
     * @hidden
     */
    DateObject.prototype.getPartsForSegment = function (mask, partIndex) {
        var segmentPart = mask.partMap[partIndex];
        var partsForSegment = [];
        for (var maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {
            var part = mask.partMap[maskPartIndex];
            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
                partsForSegment.push(part);
            }
            else {
                break;
            }
        }
        for (var maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {
            var part = mask.partMap[maskPartIndex];
            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
                partsForSegment.unshift(part);
            }
            else {
                break;
            }
        }
        return partsForSegment;
    };
    /**
     * @hidden
     */
    DateObject.prototype.isPeekDateOverflowingDatePart = function (_a) {
        var useBasePrefixAndSuffix = _a.useBasePrefixAndSuffix, middle = _a.middle, patternValue = _a.patternValue, basePrefix = _a.basePrefix, baseSuffix = _a.baseSuffix, prefix = _a.prefix, suffix = _a.suffix, symbol = _a.symbol, patternLength = _a.patternLength, leadingZero = _a.leadingZero;
        // move to next segment if the part will overflow with next char
        // when start from empty date (01, then 010), padded zeros should be trimmed
        var peekedValue = this.peek(middle, patternValue);
        var peekedDateString = useBasePrefixAndSuffix ?
            "" + basePrefix + peekedValue + baseSuffix :
            "" + prefix + peekedValue + suffix;
        var peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);
        var leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;
        var patternSatisfied = (leadingZeroOffset + utils_1.unpadZero(middle).length) >= patternLength;
        var parsedPeekedValue = utils_2.parseToInt(peekedValue);
        if (symbol === "M") {
        }
        else if (symbol === "d") {
        }
        var switchToNext = peekedDate === null ||
            (leadingZero[symbol] ?
                patternValue.length <= middle.length :
                patternSatisfied);
        return {
            peekedDate: peekedDate,
            peekedDateString: peekedDateString,
            peekedValue: peekedValue,
            parsedPeekedValue: parsedPeekedValue,
            switchToNext: switchToNext
        };
    };
    return DateObject;
}());
exports.DateObject = DateObject;
