import { Mask } from './mask';
export declare class DateObject {
    year: boolean;
    month: boolean;
    date: boolean;
    hours: boolean;
    minutes: boolean;
    seconds: boolean;
    milliseconds: boolean;
    dayperiod: boolean;
    formatPlaceholder: any;
    format: string | any;
    intl: any;
    private leadingZero;
    private monthNames;
    private typedMonthPart;
    private knownParts;
    private symbols;
    private _value;
    value: Date;
    private readonly localeId;
    private cycleTime;
    private dayPeriods;
    private twoDigitYearMax;
    private autoCorrectParts;
    private toggleDayPeriod;
    private _partiallyInvalidDate;
    constructor({ intlService, formatPlaceholder, format, cycleTime, twoDigitYearMax, value, autoCorrectParts, toggleDayPeriod }: {
        intlService: any;
        formatPlaceholder: any;
        format: any;
        cycleTime?: boolean;
        twoDigitYearMax?: number;
        value?: any;
        autoCorrectParts?: boolean;
        toggleDayPeriod?: boolean;
    });
    /**
     * @hidden
     */
    setOptions(options: any): void;
    setValue(value: any): void;
    /**
     * @hidden
     */
    hasValue(): boolean;
    /**
     * @hidden
     */
    getValue(): Date;
    /**
     * @hidden
     */
    createDefaultDate(): Date;
    /**
     * @hidden
     */
    getDefaultDate(): Date;
    /**
     * @hidden
     */
    getFormattedDate(format: any): string;
    /**
     * @hidden
     */
    getTextAndFormat(customFormat?: string): any;
    /**
     * @hidden
     */
    getFormattedInvalidDates(customFormat?: string): any;
    modifyExisting(value: any): void;
    /**
     * @hidden
     */
    getExisting(symbol: any): boolean;
    setExisting(symbol: any, value: any): void;
    modifyPart(symbol: any, offset: any): void;
    /**
     * @hidden
     */
    parsePart({ symbol, currentChar, resetSegmentValue, cycleSegmentValue, rawTextValue: rawInputValue, isDeleting, originalFormat }: {
        symbol: any;
        currentChar: any;
        resetSegmentValue: any;
        cycleSegmentValue: any;
        rawTextValue: any;
        isDeleting: any;
        originalFormat: any;
    }): any;
    /**
     * @hidden
     */
    symbolMap(symbol: any): any;
    /**
     * @hidden
     */
    resetLeadingZero(): boolean;
    setLeadingZero(leadingZero: any): void;
    /**
     * @hidden
     */
    getLeadingZero(): any;
    /**
     * @hidden
     */
    normalizeCentury(date: Date): Date;
    incrementLeadingZero(symbol: any): void;
    /**
     * @hidden
     */
    isAbbrMonth(parts: any, symbol: any): any;
    /**
     * @hidden
     */
    partPattern(parts: any, symbol: any): any;
    /**
     * @hidden
     */
    peek(value: any, pattern: any): string;
    /**
     * @hidden
     */
    matchMonth(typedChar: any): string;
    /**
     * @hidden
     */
    matchDayPeriod(typedChar: any, symbol: any): string;
    /**
     * @hidden
     */
    allFormattedMonths(locale?: string): string[];
    /**
     * @hidden
     */
    allDayPeriods(locale?: string): string[];
    /**
     * @hidden
     */
    patternLength(pattern: string): number;
    /**
     * @hidden
     */
    dateFormatString(date: any, format: any): Mask;
    /**
     * @hidden
     */
    merge(text: any, mask: any): {
        text: string;
        format: string;
    };
    /**
     * @hidden
     */
    dateFieldName(part: any): string;
    /**
     * @hidden
     */
    getNormalizedCenturyBase(twoDigitYear: number): number;
    /**
     * @hidden
     */
    shouldNormalizeCentury(): boolean;
    resetInvalidDate(): void;
    resetInvalidDateSymbol(symbol: any): void;
    resetInvalidDatePart(symbol: any): void;
    /**
     * @hidden
     */
    getInvalidDatePart(symbol: any): any;
    /**
     * @hidden
     */
    getInvalidDatePartValue(symbol: any): any;
    setInvalidDatePart(symbol: any, { value, date, startDateOffset, startDate }: {
        value?: any;
        date?: any;
        startDateOffset?: number;
        startDate?: any;
    }): void;
    /**
     * @hidden
     */
    hasInvalidDatePart(): boolean;
    /**
     * @hidden
     */
    modifyDateSymbolWithOffset(date: any, symbol: any, offset: any): {
        date: Date;
        timeModified: boolean;
    };
    /**
     * @hidden
     */
    modifyDateSymbolWithValue(date: any, symbol: any, value: any): Date;
    markDatePartsAsExisting(): void;
    /**
     * @hidden
     */
    getPartsForSegment(mask: any, partIndex: any): any[];
    /**
     * @hidden
     */
    isPeekDateOverflowingDatePart({ useBasePrefixAndSuffix, middle, patternValue, basePrefix, baseSuffix, prefix, suffix, symbol, patternLength, leadingZero }: {
        useBasePrefixAndSuffix: any;
        middle: any;
        patternValue: any;
        basePrefix: any;
        baseSuffix: any;
        prefix: any;
        suffix: any;
        symbol: any;
        patternLength: any;
        leadingZero: any;
    }): {
        peekedDate: any;
        peekedDateString: string;
        peekedValue: string;
        parsedPeekedValue: number;
        switchToNext: boolean;
    };
}
