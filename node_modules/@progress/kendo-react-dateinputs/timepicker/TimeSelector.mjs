/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as s from "react";
import t from "prop-types";
import { cloneDate as u } from "@progress/kendo-date-math";
import { Keys as h, classNames as m, uTimePicker as x, uTime as v, getActiveElement as A } from "@progress/kendo-react-common";
import { provideIntlService as K, provideLocalizationService as M, registerForIntl as F, registerForLocalization as R } from "@progress/kendo-react-intl";
import { timePickerCancel as y, messages as B, timePickerSet as D } from "../messages/index.mjs";
import { MIDNIGHT_DATE as L, MIN_TIME as j, MAX_TIME as z } from "../utils.mjs";
import { getNow as w, valueMerger as V, generateGetters as G } from "./utils.mjs";
import { TimePart as H } from "./TimePart.mjs";
import { Button as O } from "@progress/kendo-react-buttons";
const r = class r extends s.Component {
  constructor(i) {
    super(i), this._element = null, this._cancelButton = null, this._acceptButton = null, this.timePart = null, this.focusActiveList = () => {
      this.timePart && this.timePart.focus({ preventScroll: !0 });
    }, this.handleKeyDown = (e) => {
      const { keyCode: n } = e;
      switch (n) {
        case h.enter:
          this.hasActiveButton() || this.handleAccept(e);
          return;
        default:
          return;
      }
    }, this.revertToNowButton = (e) => {
      const { keyCode: n, shiftKey: o } = e;
      !o && n === h.tab && (e.preventDefault(), this.props.nowButton !== !1 ? this.timePart && this.timePart.focus({ preventScroll: !0 }, !0) : this.timePart && this.timePart.focus({ preventScroll: !0 }));
    }, this.handleNowKeyDown = (e) => {
      var c;
      const { keyCode: n, shiftKey: o } = e;
      o && n === h.tab ? (e.preventDefault(), this._acceptButton && ((c = this._acceptButton.element) == null || c.focus({ preventScroll: !0 }))) : n === h.enter && (e.stopPropagation(), this.handleNowClick(e));
    }, this.handleAccept = (e) => {
      const n = this.mergeValue(
        u(this.value || w()),
        this.timePart ? this.timePart.value : this.current
      );
      this.setState({ value: n }), this.valueDuringOnChange = n;
      const { onChange: o } = this.props;
      o && o.call(void 0, {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        value: this.value,
        target: this
      }), this.valueDuringOnChange = void 0;
    }, this.handleReject = (e) => {
      this.setState({ current: this.value });
      const { onReject: n } = this.props;
      n && n.call(void 0, e);
    }, this.handleNowClick = (e) => {
      const n = this.mergeValue(u(this.value || w()), w());
      this.setState({
        current: n,
        value: n
      }), this.valueDuringOnChange = n;
      const { onChange: o } = this.props;
      o && o.call(void 0, {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        value: this.value,
        target: this
      }), this.valueDuringOnChange = void 0;
    }, this.handleChange = (e) => {
      this.setState({ current: e });
      const { handleTimeChange: n } = this.props;
      n && n.call(void 0, {
        time: e
      });
    }, this.dateFormatParts = this.intl.splitDateFormat(this.props.format || r.defaultProps.format), this.mergeValue = V(G(this.dateFormatParts)), this.hasActiveButton = this.hasActiveButton.bind(this), this.state = {
      current: this.props.value || L,
      value: this.props.value || r.defaultProps.value
    };
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  get value() {
    const i = this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
    return i !== null ? u(i) : null;
  }
  get intl() {
    return K(this);
  }
  get current() {
    return this.state.current !== null ? u(this.state.current) : null;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    clearTimeout(this.nextTickId);
  }
  /**
   * @hidden
   */
  render() {
    const {
      format: i,
      cancelButton: e,
      disabled: n,
      tabIndex: o,
      className: c,
      smoothScroll: P,
      min: N,
      max: k,
      boundRange: T,
      nowButton: E,
      steps: S,
      show: _,
      mobileMode: b,
      unstyled: l
    } = this.props, I = l && l.uTimePicker, d = l && l.uTime, C = M(this), f = C.toLanguageString(y, B[y]), g = C.toLanguageString(D, B[D]);
    return /* @__PURE__ */ s.createElement(s.Fragment, null, /* @__PURE__ */ s.createElement(
      "div",
      {
        ref: (a) => {
          this._element = a;
        },
        tabIndex: n ? void 0 : o || 0,
        className: m(
          x.timeSelector({
            c: I,
            mobileMode: b,
            disabled: n
          }),
          c
        ),
        onKeyDown: this.handleKeyDown
      },
      /* @__PURE__ */ s.createElement(
        H,
        {
          ref: (a) => {
            this.timePart = a;
          },
          value: this.current,
          onChange: this.handleChange,
          onNowClick: this.handleNowClick,
          format: i,
          smoothScroll: P,
          min: N,
          max: k,
          boundRange: T,
          disabled: n,
          nowButton: E,
          steps: S,
          show: _,
          mobileMode: b,
          onNowKeyDown: this.handleNowKeyDown,
          unstyled: l
        }
      )
    ), this.props.footer && /* @__PURE__ */ s.createElement("div", { className: m(v.footer({ c: d })) }, e && /* @__PURE__ */ s.createElement(
      O,
      {
        type: "button",
        ref: (a) => {
          this._cancelButton = a;
        },
        className: m(v.cancel({ c: d })),
        onClick: this.handleReject,
        title: f,
        "aria-label": f
      },
      f
    ), /* @__PURE__ */ s.createElement(
      O,
      {
        type: "button",
        ref: (a) => {
          this._acceptButton = a;
        },
        className: m(v.accept({ c: d })),
        themeColor: "primary",
        onClick: this.handleAccept,
        onKeyDown: this.revertToNowButton,
        title: g,
        "aria-label": g
      },
      g
    )));
  }
  nextTick(i) {
    clearTimeout(this.nextTickId), this.nextTickId = window.setTimeout(() => i());
  }
  hasActiveButton() {
    if (!this._acceptButton || !this._acceptButton.element)
      return !1;
    const i = A(document);
    return this._acceptButton && i === this._acceptButton.element || this._cancelButton && i === this._cancelButton.element;
  }
};
r.propTypes = {
  cancelButton: t.bool,
  className: t.string,
  disabled: t.bool,
  format: t.oneOfType([
    t.string,
    t.shape({
      skeleton: t.string,
      pattern: t.string,
      date: t.oneOf(["short", "medium", "long", "full"]),
      time: t.oneOf(["short", "medium", "long", "full"]),
      datetime: t.oneOf(["short", "medium", "long", "full"]),
      era: t.oneOf(["narrow", "short", "long"]),
      year: t.oneOf(["numeric", "2-digit"]),
      month: t.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: t.oneOf(["numeric", "2-digit"]),
      weekday: t.oneOf(["narrow", "short", "long"]),
      hour: t.oneOf(["numeric", "2-digit"]),
      hour12: t.bool,
      minute: t.oneOf(["numeric", "2-digit"]),
      second: t.oneOf(["numeric", "2-digit"]),
      timeZoneName: t.oneOf(["short", "long"])
    })
  ]),
  max: t.instanceOf(Date),
  min: t.instanceOf(Date),
  nowButton: t.bool,
  steps: t.shape({
    hour: t.number,
    minute: t.number,
    second: t.number
  }),
  smoothScroll: t.bool,
  tabIndex: t.number,
  value: t.instanceOf(Date),
  show: t.bool
}, r.defaultProps = {
  value: null,
  disabled: !1,
  cancelButton: !0,
  format: "t",
  min: j,
  max: z,
  boundRange: !1,
  footer: !0
};
let p = r;
F(p);
R(p);
export {
  p as TimeSelector
};
