/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import e from "prop-types";
import { Popup as Q } from "@progress/kendo-react-popup";
import { cloneDate as M } from "@progress/kendo-date-math";
import { Keys as d, validatePackage as $, canUseDOM as O, AsyncFocusBlur as ee, classNames as I, uDateTimePicker as D, createPropsContext as te, withIdHOC as ie, withPropsContext as se, withUnstyledHOC as oe } from "@progress/kendo-react-common";
import { calendarIcon as ae } from "@progress/kendo-svg-icons";
import { DateInput as ne } from "../dateinput/DateInput.mjs";
import { Button as re } from "@progress/kendo-react-buttons";
import { packageMetadata as le } from "../package-metadata.mjs";
import { MAX_DATE as he, MIN_DATE as de, isInDateRange as ue, MAX_TIME as pe, MIN_TIME as ce } from "../utils.mjs";
import { MOBILE_MEDIUM_DEVISE as me } from "../common/constants.mjs";
import { dateTimePickerCancel as P, messages as p, dateTimePickerSet as C, toggleDateTimeSelector as c } from "../messages/index.mjs";
import { provideLocalizationService as m, registerForLocalization as fe } from "@progress/kendo-react-intl";
import { DateTimeSelector as ge } from "./DateTimeSelector.mjs";
import { isInTimeRange as ve } from "../timepicker/utils.mjs";
import { PickerFloatingLabel as we } from "../hooks/usePickerFloatingLabel.mjs";
import { AdaptiveMode as be } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as ye } from "@progress/kendo-react-layout";
const o = class o extends n.Component {
  constructor(t) {
    super(t), this._element = null, this._dateInput = n.createRef(), this._dateTimeSelector = null, this.shouldFocusDateInput = !1, this.prevShow = !1, this.focus = () => {
      const i = this.dateInputElement();
      i && i.focus();
    }, this.renderPicker = () => {
      const { disabled: i, minTime: s, maxTime: a, format: h, calendar: l, cancelButton: r, weekNumber: u, focusedDate: g, unstyled: v } = this.props;
      return /* @__PURE__ */ n.createElement(
        ge,
        {
          ref: (w) => {
            this._dateTimeSelector = w;
          },
          cancelButton: r,
          steps: this.props.steps,
          value: this.value,
          onChange: this.handleValueChange,
          onReject: this.handleReject,
          disabled: i,
          weekNumber: u,
          min: this.min,
          max: this.max,
          minTime: s,
          maxTime: a,
          focusedDate: g,
          format: h,
          calendar: l,
          mobileMode: this.mobileMode,
          footerActions: !this.mobileMode,
          unstyled: v
        }
      );
    }, this.renderAdaptivePopup = () => {
      const { windowWidth: i = 0 } = this.state, s = m(this).toLanguageString(
        P,
        p[P]
      ), a = m(this).toLanguageString(
        C,
        p[C]
      ), h = {
        expand: this.show,
        onClose: this.handleBlur,
        adaptiveTitle: this.props.adaptiveTitle,
        windowWidth: i,
        footer: {
          cancelText: s,
          onCancel: (l) => {
            var r;
            return (r = this._dateTimeSelector) == null ? void 0 : r.handleReject(l);
          },
          applyText: a,
          onApply: (l) => {
            var r;
            return (r = this._dateTimeSelector) == null ? void 0 : r.handleAccept(l);
          }
        }
      };
      return /* @__PURE__ */ n.createElement(be, { ...h }, /* @__PURE__ */ n.createElement(ye, { overflowHidden: !0 }, this.renderPicker()));
    }, this.handleReject = () => {
      this.shouldFocusDateInput = !0, this.setShow(!1);
    }, this.handleValueChange = (i) => {
      this.setState({
        value: M(i.value || void 0)
      }), this.valueDuringOnChange = i.value, this.showDuringOnChange = !1, this.mobileMode || (this.shouldFocusDateInput = !0);
      const { onChange: s } = this.props;
      s && s.call(void 0, {
        syntheticEvent: i.syntheticEvent,
        nativeEvent: i.nativeEvent,
        value: this.value,
        show: this.show,
        target: this
      }), this.valueDuringOnChange = void 0, this.showDuringOnChange = void 0, this.setShow(!1);
    }, this.handleFocus = () => {
      this.setState({ focused: !0 });
    }, this.handleBlur = () => {
      this.setState({ focused: !1 }), this.setShow(!1);
    }, this.handleDateIconClick = () => {
      this.props.disabled || (this.shouldFocusDateInput = !0, this.setShow(!this.show));
    }, this.handleIconMouseDown = (i) => {
      i.preventDefault();
    }, this.handleKeyDown = (i) => {
      const { altKey: s, keyCode: a } = i;
      if (a === d.esc) {
        this.shouldFocusDateInput = !0, this.setShow(!1);
        return;
      }
      s && (a === d.up || a === d.down) && (i.preventDefault(), i.stopPropagation(), this.shouldFocusDateInput = a === d.up, this.setShow(a === d.down));
    }, this.dateInputElement = () => this.dateInput && this.dateInput.element || this.element && this.element.querySelector(".k-dateinput > input.k-input-inner"), $(le), this.state = {
      value: this.props.defaultValue || o.defaultProps.defaultValue,
      show: this.props.defaultShow || o.defaultProps.defaultShow,
      focused: !1
    };
  }
  get _popupId() {
    return this.props.id + "-popup-id";
  }
  get document() {
    if (O)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * Gets the wrapping element of the DateTimePicker.
   */
  get element() {
    return this._element;
  }
  /**
   * Gets the DateInput component inside the DateTimePicker component.
   */
  get dateInput() {
    return this._dateInput.current;
  }
  /**
   * Gets the value of the DateTimePicker.
   */
  get value() {
    const t = this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
    return t !== null ? M(t) : null;
  }
  /**
   * Gets the popup state of the DateTimePicker.
   */
  get show() {
    return this.showDuringOnChange !== void 0 ? this.showDuringOnChange : this.props.show !== void 0 ? this.props.show : this.state.show;
  }
  /**
   * Gets the `name` property of the DateTimePicker.
   */
  get name() {
    return this.props.name;
  }
  /**
   * The mobile mode of the ComboBox.
   */
  get mobileMode() {
    return !!(this.state.windowWidth && this.state.windowWidth <= me && this.props.adaptive);
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : o.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : o.defaultProps.max;
  }
  /**
   * Represents the validity state into which the DateTimePicker is set.
   */
  get validity() {
    const t = ue(this.value, this.min, this.max) && ve(this.value, this.props.minTime || ce, this.props.maxTime || pe), i = this.props.validationMessage !== void 0, s = (!this.required || this.value !== null) && t, a = this.props.valid !== void 0 ? this.props.valid : s;
    return {
      customError: i,
      rangeOverflow: this.value && this.max.getTime() < this.value.getTime() || !1,
      rangeUnderflow: this.value && this.value.getTime() < this.min.getTime() || !1,
      valid: a,
      valueMissing: this.value === null
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : o.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : !1;
  }
  /**
   * @hidden
   */
  get dateInputComp() {
    return this.props.dateInput || o.defaultProps.dateInput;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var t;
    this.observerResize = O && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.show && this.forceUpdate(), (t = this.document) != null && t.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    const t = this.dateInputElement();
    this._dateTimeSelector && this.show && !this.prevShow && this._dateTimeSelector.focus({ preventScroll: !0 }), t && !this.show && this.shouldFocusDateInput && t.focus({ preventScroll: !0 }), this.prevShow = this.show, this.shouldFocusDateInput = !1;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    var t;
    clearTimeout(this.nextTickId), (t = this.document) != null && t.body && this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: t = o.defaultProps.size,
      rounded: i = o.defaultProps.rounded,
      fillMode: s = o.defaultProps.fillMode,
      autoFocus: a = o.defaultProps.autoFocus,
      disabled: h,
      tabIndex: l,
      title: r,
      id: u,
      format: g,
      formatPlaceholder: v,
      min: w,
      max: x,
      className: E,
      width: k,
      name: F,
      validationMessage: R,
      required: B,
      validityStyles: z,
      minTime: A,
      maxTime: N,
      ariaLabelledBy: V,
      ariaDescribedBy: L,
      popup: _ = Q,
      unstyled: b,
      autoFill: q,
      twoDigitYearMax: K,
      enableMouseWheel: U,
      autoCorrectParts: j,
      autoSwitchParts: H,
      autoSwitchKeys: W,
      allowCaretMode: X
    } = this.props, y = b && b.uDateTimePicker, S = !this.validityStyles || this.validity.valid, Y = {
      id: u,
      ariaLabelledBy: V,
      ariaDescribedBy: L,
      format: g,
      formatPlaceholder: v,
      disabled: h,
      title: r,
      validityStyles: z,
      validationMessage: R,
      required: B,
      min: w,
      max: x,
      minTime: A,
      maxTime: N,
      name: F,
      tabIndex: this.show ? -1 : l,
      valid: this.validity.valid,
      value: this.value,
      onChange: this.handleValueChange,
      steps: this.props.steps,
      label: void 0,
      placeholder: this.state.focused ? null : this.props.placeholder,
      ariaExpanded: this.show,
      size: null,
      fillMode: null,
      rounded: null,
      unstyled: b,
      autoFill: q,
      twoDigitYearMax: K,
      enableMouseWheel: U,
      autoCorrectParts: j,
      autoSwitchParts: H,
      autoSwitchKeys: W,
      allowCaretMode: X
    }, T = /* @__PURE__ */ n.createElement(
      ee,
      {
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onSyncFocus: this.props.onFocus,
        onSyncBlur: this.props.onBlur
      },
      ({ onFocus: Z, onBlur: G }) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        "div",
        {
          ref: (J) => {
            this._element = J;
          },
          className: I(
            D.wrapper({
              c: y,
              size: t,
              fillMode: s,
              rounded: i,
              disabled: h,
              required: this.required,
              invalid: !S
            }),
            E
          ),
          onKeyDown: this.handleKeyDown,
          style: { width: k },
          onFocus: this.mobileMode ? void 0 : Z,
          onBlur: G,
          onClick: this.mobileMode ? this.handleDateIconClick : void 0
        },
        /* @__PURE__ */ n.createElement(
          this.dateInputComp,
          {
            _ref: this._dateInput,
            ariaRole: "combobox",
            ariaControls: this._popupId,
            ariaHasPopup: "dialog",
            readonly: this.mobileMode,
            autoFocus: a,
            ...Y
          }
        ),
        /* @__PURE__ */ n.createElement(
          re,
          {
            tabIndex: -1,
            type: "button",
            icon: "calendar",
            svgIcon: ae,
            onMouseDown: this.handleIconMouseDown,
            onClick: this.mobileMode ? void 0 : this.handleDateIconClick,
            title: m(this).toLanguageString(
              c,
              p[c]
            ),
            className: I(D.inputButton({ c: y })),
            rounded: null,
            fillMode: s,
            "aria-label": m(this).toLanguageString(
              c,
              p[c]
            )
          }
        ),
        /* @__PURE__ */ n.createElement(
          _,
          {
            show: this.show,
            animate: this.element !== null,
            anchor: this.element,
            popupClass: I(D.popup({ c: y })),
            id: this._popupId,
            anchorAlign: {
              horizontal: "left",
              vertical: "bottom"
            },
            popupAlign: {
              horizontal: "left",
              vertical: "top"
            }
          },
          !this.mobileMode && this.renderPicker()
        )
      ), this.mobileMode && this.renderAdaptivePopup())
    );
    return this.props.label ? /* @__PURE__ */ n.createElement(
      we,
      {
        dateInput: this._dateInput,
        label: this.props.label,
        editorId: u,
        editorValid: S,
        editorDisabled: this.props.disabled,
        children: T,
        style: { width: this.props.width }
      }
    ) : T;
  }
  setShow(t) {
    const { onOpen: i, onClose: s } = this.props;
    this.show !== t && (this.setState({ show: t }), t && i && i.call(void 0, {
      target: this
    }), !t && s && s.call(void 0, {
      target: this
    }));
  }
  nextTick(t) {
    clearTimeout(this.nextTickId), this.nextTickId = window.setTimeout(() => t());
  }
  calculateMedia(t) {
    for (const i of t)
      this.setState({ windowWidth: i.target.clientWidth });
  }
};
o.displayName = "DateTimePicker", o.propTypes = {
  className: e.string,
  defaultShow: e.bool,
  defaultValue: e.instanceOf(Date),
  disabled: e.bool,
  focusedDate: e.instanceOf(Date),
  format: e.oneOfType([
    e.string,
    e.shape({
      skeleton: e.string,
      pattern: e.string,
      date: e.oneOf(["short", "medium", "long", "full"]),
      time: e.oneOf(["short", "medium", "long", "full"]),
      datetime: e.oneOf(["short", "medium", "long", "full"]),
      era: e.oneOf(["narrow", "short", "long"]),
      year: e.oneOf(["numeric", "2-digit"]),
      month: e.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: e.oneOf(["numeric", "2-digit"]),
      weekday: e.oneOf(["narrow", "short", "long"]),
      hour: e.oneOf(["numeric", "2-digit"]),
      hour12: e.bool,
      minute: e.oneOf(["numeric", "2-digit"]),
      second: e.oneOf(["numeric", "2-digit"]),
      timeZoneName: e.oneOf(["short", "long"])
    })
  ]),
  formatPlaceholder: e.oneOfType([
    e.oneOf([
      "wide",
      "narrow",
      "short",
      "formatPattern"
    ]),
    e.shape({
      year: e.string,
      month: e.string,
      day: e.string,
      hour: e.string,
      minute: e.string,
      second: e.string
    })
  ]),
  id: e.string,
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  min: e.instanceOf(Date),
  max: e.instanceOf(Date),
  name: e.string,
  popupSettings: e.shape({
    animate: e.bool,
    appendTo: e.any,
    popupClass: e.string
  }),
  show: e.bool,
  tabIndex: e.number,
  title: e.string,
  value: e.instanceOf(Date),
  weekNumber: e.bool,
  width: e.oneOfType([e.number, e.string]),
  validationMessage: e.string,
  required: e.bool,
  validate: e.bool,
  valid: e.bool,
  cancelButton: e.bool,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: e.bool
}, o.defaultProps = {
  defaultShow: !1,
  defaultValue: null,
  disabled: !1,
  format: "g",
  // general date and time pattern (short time): "M/d/y h:mm a" for en.
  max: he,
  min: de,
  popupSettings: {},
  tabIndex: 0,
  weekNumber: !1,
  validityStyles: !0,
  cancelButton: !0,
  dateInput: ne,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: !1
};
let f = o;
const Ie = te(), De = ie(
  se(
    Ie,
    oe(f)
  )
);
De.displayName = "KendoReactDateTimePicker";
fe(f);
export {
  De as DateTimePicker,
  Ie as DateTimePickerPropsContext,
  f as DateTimePickerWithoutContext
};
