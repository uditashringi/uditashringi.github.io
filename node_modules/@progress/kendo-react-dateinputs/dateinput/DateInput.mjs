/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as l from "react";
import e from "prop-types";
import { cloneDate as c, isEqual as T } from "@progress/kendo-date-math";
import { Button as x } from "@progress/kendo-react-buttons";
import { caretAltUpIcon as L, caretAltDownIcon as _ } from "@progress/kendo-svg-icons";
import { provideLocalizationService as V, provideIntlService as S, registerForIntl as A, registerForLocalization as F } from "@progress/kendo-react-intl";
import { getActiveElement as P, validatePackage as N, classNames as p, uDateInput as u, createPropsContext as q, withIdHOC as B, withPropsContext as R, withUnstyledHOC as U } from "@progress/kendo-react-common";
import { FloatingLabel as z } from "@progress/kendo-react-labels";
import { DateInput as j } from "@progress/kendo-dateinputs-common";
import { DEFAULT_FORMAT as H, DEFAULT_FORMAT_PLACEHOLDER as K, isInRange as W } from "./utils.mjs";
import { packageMetadata as X } from "../package-metadata.mjs";
import { MAX_DATE as Y, MIN_DATE as G, MIN_TIME as Z, MAX_TIME as $ } from "../utils.mjs";
import { increaseValue as g, messages as f, decreaseValue as v } from "../messages/index.mjs";
import { isInTimeRange as J } from "../timepicker/utils.mjs";
import Q from "../common/ClearButton.mjs";
import { DateInputIntl as ee } from "./dateInputIntl.mjs";
const te = "Please enter a valid value!", a = class a extends l.Component {
  constructor(t) {
    super(t), this.kendoDate = null, this.kendoDateObject = null, this.mounted = !1, this._element = null, this._wrapper = null, this._nativeEvent = null, this.focus = () => {
      this._element && this._element.focus();
    }, this.setValidity = () => {
      this.element && this.element.setCustomValidity && this.element.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || a.defaultProps.validationMessage
      );
    }, this.updateOnPaste = (i) => {
      !this.element || !this.kendoDate || this.triggerChange(i);
    }, this.spinnersMouseDown = (i) => {
      i.preventDefault();
      const s = P(document);
      this.element && s !== this.element && this.element.focus({ preventScroll: !0 });
    }, this.handleClick = (i) => {
      this.props.onChange && this.props.onChange(i);
    }, this.nativeWheel = (i) => {
      P(document) === this.element && i.preventDefault();
    }, this.increasePart = (i) => {
      var s;
      (s = this.kendoDate) == null || s.modifyDateSegmentValue(1), this.onChange(i);
    }, this.decreasePart = (i) => {
      var s;
      (s = this.kendoDate) == null || s.modifyDateSegmentValue(-1), this.onChange(i);
    }, this.elementOnFocus = (i) => {
      this.wrapper && this.wrapper.classList.add("k-focus"), this.setState({ focused: !0 });
    }, this.elementOnBlur = (i) => {
      this.wrapper && this.wrapper.classList.remove("k-focus"), this.setState({ focused: !1 });
    }, N(X), this.state = {
      focused: !1
    };
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  /* Public Getters */
  /**
   * Gets the value of the DateInput.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.kendoDate && this.kendoDate.value;
  }
  /**
   * Gets the `name` property of the DateInput.
   */
  get name() {
    return this.props.name;
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : a.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : a.defaultProps.max;
  }
  get isInSegmentSelection() {
    const { year: t, month: i, day: s, hours: o, minutes: r, seconds: n } = this.kendoDateObject;
    return (!t || !i || !s || !o || !r || !n) && (t || i || s || o || r || n);
  }
  /**
   * @hidden
   */
  get text() {
    const { placeholder: t } = this.props, i = this.kendoDate && this.kendoDate.currentText || "";
    return t != null && !this.state.focused && !this.value ? t : i;
  }
  /**
   * Represents the validity state into which the DateInput is set.
   */
  get validity() {
    const t = W(this.value, this.min, this.max) && J(this.value, this.props.minTime, this.props.maxTime), i = this.props.validationMessage !== void 0, s = (!this.required || this.value !== null) && t, o = this.props.valid !== void 0 ? this.props.valid : s;
    return {
      customError: i,
      rangeOverflow: this.value && this.max.getTime() < this.value.getTime() || !1,
      rangeUnderflow: this.value && this.value.getTime() < this.min.getTime() || !1,
      valid: o,
      valueMissing: this.value === null
    };
  }
  /**
   * Gets the element of the DateInput.
   *
   * @return - An `HTMLInputElement`.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *     }
   *     element = null;
   *     render() {
   *         return (
   *             <div>
   *                 <DateInput
   *                     ref={(dateInput) =>
   *                         this.element = dateInput ? dateInput.element : null}
   *                 />
   *                 <button onClick={() => console.log(this.element)}>console.log the element</button>
   *             </div>
   *         );
   *     }
   * }
   *
   * ReactDOM.render(
   *     <App />,
   *     document.getElementsByTagName('my-app')[0]
   * );
   * ```
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : a.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : !1;
  }
  /**
   * @hidden
   */
  get wrapper() {
    return this._wrapper;
  }
  /**
   * @hidden
   */
  get options() {
    const {
      format: t,
      steps: i,
      placeholder: s,
      value: o,
      autoFill: r,
      enableMouseWheel: n,
      autoCorrectParts: h,
      autoSwitchParts: b,
      autoSwitchKeys: y,
      twoDigitYearMax: d,
      allowCaretMode: D,
      formatPlaceholder: C
    } = this.props;
    return {
      format: t,
      steps: i,
      formatPlaceholder: C,
      placeholder: s,
      selectPreviousSegmentOnBackspace: !0,
      value: o || this.value,
      intlService: this.intlCommon,
      autoFill: r !== void 0 ? r : !1,
      enableMouseWheel: n,
      autoCorrectParts: h,
      autoSwitchParts: b,
      autoSwitchKeys: y || [],
      twoDigitYearMax: d,
      allowCaretMode: D
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.setValidity(), this.mounted || (this.wrapper && this.wrapper.addEventListener("wheel", this.nativeWheel, { passive: !1 }), this.kendoDate = this.initKendoDate(), this.kendoDateObject = this.kendoDate.dateObject, this.mounted = !0);
  }
  /**
   * @hidden
   */
  componentDidUpdate(t) {
    this.setValidity(), this.kendoDate && ((t.format !== this.props.format || t.readonly !== this.props.readonly || t.steps !== this.props.steps || this.intlCommon.locale !== this.kendoDate.options.intlService.locale) && this.kendoDate.setOptions(this.options, !0), t.value !== this.props.value && (this.kendoDateObject.getValue() !== null || this.isInSegmentSelection && this.props.value !== null) && this.kendoDateObject.setValue(this.props.value), this.props.ariaExpanded !== void 0 && this.props.ariaExpanded && (this.kendoDate.options.placeholder = null), this.props.ariaExpanded !== void 0 && !this.props.ariaExpanded && (this.kendoDate.options.placeholder = this.props.placeholder), this.kendoDate.refreshElementValue());
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.wrapper && this.wrapper.removeEventListener("wheel", this.nativeWheel);
  }
  /**
   * @hidden
   */
  render() {
    var I;
    const {
      size: t = a.defaultProps.size,
      fillMode: i = a.defaultProps.fillMode,
      rounded: s = a.defaultProps.rounded,
      autoFocus: o = a.defaultProps.autoFocus,
      unstyled: r
    } = this.props, n = r && r.uDateInput;
    this.props._ref && (this.props._ref.current = this);
    const h = V(this), b = { ...a.defaultProps, ...this.props }, { name: y, label: d, id: D, disabled: C } = b, M = this.text, E = D || this._inputId, O = !this.validityStyles || this.validity.valid, k = /* @__PURE__ */ l.createElement(
      "span",
      {
        ref: (w) => {
          this._wrapper = w;
        },
        style: d ? void 0 : { width: this.props.width },
        dir: this.props.dir,
        className: p(
          u.wrapper({
            c: n,
            size: t,
            fillMode: i,
            rounded: s,
            disabled: C,
            required: this.required,
            invalid: !O
          }),
          this.props.className
        )
      },
      /* @__PURE__ */ l.createElement(
        "input",
        {
          role: this.props.ariaRole || "textbox",
          readOnly: this.props.readonly,
          tabIndex: this.props.tabIndex || 0,
          disabled: this.props.disabled,
          title: this.props.title !== void 0 ? this.props.title : M,
          type: "text",
          spellCheck: !1,
          autoComplete: "off",
          autoCorrect: "off",
          autoFocus: o,
          className: p(u.inputInner({ c: n })),
          id: E,
          "aria-label": this.props.ariaLabel,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-describedby": this.props.ariaDescribedBy,
          "aria-haspopup": this.props.ariaHasPopup,
          "aria-disabled": this.props.disabled,
          "aria-expanded": this.props.ariaExpanded,
          "aria-controls": this.props.ariaControls,
          "aria-required": this.props.required,
          "aria-invalid": !O,
          onKeyDown: this.onChange.bind(this),
          onChange: this.onChange.bind(this),
          onWheel: this.onChange.bind(this),
          onInput: this.onChange.bind(this),
          onClick: this.onChange.bind(this),
          name: y,
          ref: (w) => this._element = w
        }
      ),
      this.props.children,
      this.props.clearButton && this.props.value && /* @__PURE__ */ l.createElement(Q, { onClick: this.handleClick, key: "clearbutton" }),
      this.props.spinners && /* @__PURE__ */ l.createElement(
        "span",
        {
          className: p(u.inputSpinner({ c: n })),
          onMouseDown: this.spinnersMouseDown
        },
        /* @__PURE__ */ l.createElement(
          x,
          {
            tabIndex: -1,
            type: "button",
            rounded: null,
            className: p(u.spinnerIncrease({ c: n })),
            icon: "caret-alt-up",
            svgIcon: L,
            "aria-label": h.toLanguageString(g, f[g]),
            title: h.toLanguageString(g, f[g]),
            onClick: this.increasePart
          }
        ),
        /* @__PURE__ */ l.createElement(
          x,
          {
            tabIndex: -1,
            type: "button",
            rounded: null,
            className: p(u.spinnerDecrease({ c: n })),
            icon: "caret-alt-down",
            svgIcon: _,
            "aria-label": h.toLanguageString(v, f[v]),
            title: h.toLanguageString(v, f[v]),
            onClick: this.decreasePart
          }
        )
      )
    );
    return d ? /* @__PURE__ */ l.createElement(
      z,
      {
        label: d,
        editorId: E,
        editorValue: (I = this._element) == null ? void 0 : I.value,
        editorValid: O,
        editorDisabled: this.props.disabled,
        children: k,
        style: { width: this.props.width }
      }
    ) : k;
  }
  /**
   * @hidden
   */
  intl() {
    return S(this);
  }
  /**
   * @hidden
   */
  get intlCommon() {
    return new ee(S(this));
  }
  /*  end handlers */
  triggerChange(t) {
    this.valueDuringOnChange = this.value, this.forceUpdate(), this._nativeEvent = t, this.valueDuringOnChange = void 0;
  }
  onChange(t) {
    this._nativeEvent && this.props.onChange && !T(this._nativeEvent.oldValue, this.value) && this.props.onChange.call(void 0, {
      syntheticEvent: t,
      nativeEvent: this._nativeEvent.event,
      value: this._nativeEvent.value,
      target: this
    }), this._nativeEvent = null;
  }
  initKendoDate() {
    return new j(this._element, {
      ...this.options,
      events: {
        focus: this.elementOnFocus.bind(this),
        blur: this.elementOnBlur.bind(this),
        valueChange: this.triggerChange.bind(this),
        click: this.handleClick.bind(this)
      }
    });
  }
};
a.displayName = "DateInput", a.propTypes = {
  value: e.instanceOf(Date),
  format: e.oneOfType([
    e.string,
    e.shape({
      skeleton: e.string,
      pattern: e.string,
      date: e.oneOf(["short", "medium", "long", "full"]),
      time: e.oneOf(["short", "medium", "long", "full"]),
      datetime: e.oneOf(["short", "medium", "long", "full"]),
      era: e.oneOf(["narrow", "short", "long"]),
      year: e.oneOf(["numeric", "2-digit"]),
      month: e.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: e.oneOf(["numeric", "2-digit"]),
      weekday: e.oneOf(["narrow", "short", "long"]),
      hour: e.oneOf(["numeric", "2-digit"]),
      hour12: e.bool,
      minute: e.oneOf(["numeric", "2-digit"]),
      second: e.oneOf(["numeric", "2-digit"]),
      timeZoneName: e.oneOf(["short", "long"])
    })
  ]),
  formatPlaceholder: e.oneOfType([
    e.oneOf([
      "wide",
      "narrow",
      "short",
      "formatPattern"
    ]),
    e.shape({
      year: e.string,
      month: e.string,
      day: e.string,
      hour: e.string,
      minute: e.string,
      second: e.string
    })
  ]),
  width: e.oneOfType([e.string, e.number]),
  tabIndex: e.number,
  title: e.string,
  steps: e.shape({
    year: e.number,
    month: e.number,
    day: e.number,
    hour: e.number,
    minute: e.number,
    second: e.number
  }),
  min: e.instanceOf(Date),
  max: e.instanceOf(Date),
  disabled: e.bool,
  spinners: e.bool,
  name: e.string,
  dir: e.string,
  label: e.string,
  id: e.string,
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  ariaLabel: e.string,
  ariaRole: e.string,
  ariaHasPopup: e.oneOfType([e.bool, e.string]),
  ariaExpanded: e.oneOfType([e.bool]),
  onChange: e.func,
  validationMessage: e.string,
  required: e.bool,
  validate: e.bool,
  valid: e.bool,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: e.bool
}, a.defaultProps = {
  format: H,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  formatPlaceholder: K,
  spinners: !1,
  disabled: !1,
  max: c(Y),
  min: c(G),
  minTime: c(Z),
  maxTime: c($),
  validityStyles: !0,
  validationMessage: te,
  placeholder: null,
  enableMouseWheel: !0,
  autoCorrectParts: !0,
  autoSwitchParts: !0,
  allowCaretMode: !1,
  twoDigitYearMax: 68,
  // the rest of the properties are undefined by default
  ariaHasPopup: "grid",
  autoFocus: !1
};
let m = a;
const ie = q(), se = B(
  R(
    ie,
    U(m)
  )
);
se.displayName = "KendoReactDateInput";
A(m);
F(m);
export {
  se as DateInput,
  ie as DateInputPropsContext,
  m as DateInputWithoutContext
};
