/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { orderBy as s, filterBy as D } from "@progress/kendo-data-query";
import { extendDataItem as y, mapTree as v, getItemPath as P, getNestedValue as g } from "@progress/kendo-react-common";
function i(r, n, t) {
  return t ? { ...r, [n]: t.length ? [...t] : void 0 } : r && r[n] ? [...r[n]] : [];
}
function C(r, n, t) {
  if (r[t]) {
    const o = i(r, t, s(i(r, t), n)), e = i(o, t).map((c) => C(c, n, t));
    return { ...o, [t]: e };
  }
  return r;
}
function $(r, n, t) {
  let o = s(r, n);
  return o = o.map((e) => C(e, n, t)), o;
}
function B(r, n, t) {
  let o = i(r, t);
  if (o && o.length) {
    o = o.map((h) => B(h, n, t));
    const a = D(o, {
      filters: [{ filters: n, logic: "and" }, { operator: (h) => !!(h[t] || []).length }],
      logic: "or"
    });
    return i(r, t, a);
  }
  return r;
}
function k(r, n, t) {
  let o = { [t]: [...r] };
  return o = B(o, n, t), o[t] || [];
}
function N(r, n, t) {
  const o = [], e = [];
  for (let c = r.length - 1; c >= 0; c--) {
    const a = r[c];
    o.push({
      root: a,
      data: n(a),
      level: [c],
      levelCount: r.length
    });
  }
  for (; o.length > 0; ) {
    const c = o.pop();
    if (e.push({
      dataItem: c.root,
      level: [...c.level],
      ...t(c.root),
      levelCount: c.levelCount
    }), c.data.length)
      for (let a = c.data.length - 1; a >= 0; a--) {
        const h = c.data[a];
        o.push({
          root: h,
          data: n(h),
          level: [...c.level, a],
          levelCount: c.data.length
        });
      }
  }
  return e;
}
const S = (r, n, t) => {
  const o = (l) => !!g(n, l), e = (l) => !!g(t, l), c = (l) => {
    const f = [];
    return o(l) && e(l) && f.push(...g(t, l)), f;
  }, a = (l, f, p) => {
    f.push({ ...l, level: p }), c(l).forEach((x) => a(x, f, p + 1));
  }, h = [];
  return r.forEach((l) => a(l, h, 0)), h;
}, V = (r, n, t, o) => {
  let e = {}, c = [], a;
  return r.forEach((h) => e[n(h)] = { ...h }), r.forEach((h) => {
    a = e[t(h)], a ? (a[o] = a[o] || [], a[o].push(e[n(h)])) : c.push(e[n(h)]);
  }), c;
}, j = (r, n, t) => y(r, n, t), q = (r, n, t) => [...v(
  [{ [n]: [...r] }],
  n,
  (e) => T(e, t, n)
)[0][n]], T = (r, n, t) => {
  const o = r[t] || [], e = o.findIndex(n);
  if (e !== -1) {
    const c = [...o];
    return c.splice(e, 1), {
      ...r,
      [t]: c
    };
  }
  return r;
}, z = (r, n, t, o) => v(
  r,
  n,
  (e) => t(e) ? { ...e, [n]: o(e[n] || []) } : e
), u = (r, n, t) => P(r, n, t), A = (r, n, t, o) => {
  const e = [...r], c = u(e, n, o), a = c.pop(), h = c.pop(), l = n[n.length - 1];
  if (t) {
    const p = u(e, t, o).pop();
    (h ? h[o] : e).splice(l, 1), p[o] = p[o] || [], p[o].push(a);
  } else
    (h ? h[o] : e).splice(l, 1), e.push(a);
  return e;
};
export {
  V as createDataTree,
  j as extendDataItem,
  k as filterBy,
  N as flatData,
  u as getItemPath,
  z as modifySubItems,
  A as moveTreeItem,
  $ as orderBy,
  q as removeItems,
  S as treeToFlat
};
