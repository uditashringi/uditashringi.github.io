/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { generateNavigatableId as p } from "../../navigation/utils.mjs";
import { ColumnDefaultProps as g } from "../ColumnProps.mjs";
function c(t, n) {
  const d = t[n].depth;
  let i = null;
  for (let h = n + 1; h < t.length; h++)
    if (t[h].depth === d) {
      i = t[h];
      break;
    }
  return i;
}
const o = (t) => {
  let n = t.width ? parseFloat(t.width.toString()) : 0;
  return !n && t.children && t.children.length && (n = t.children.reduce((d, i) => o(i) + d, 0)), n;
};
function I(t, n) {
  const d = [[]];
  let i = 0;
  for (let e = t.length - 1; e >= 0; e--)
    i = Math.max(i, t[e].depth), t[e].colSpan = t[e].colSpan || 1, t[e].children.length > 0 && (t[e].colSpan = t[e].children.reduce(
      (l, a) => a.hidden ? l : l + a.colSpan,
      0
    ));
  const h = [];
  let r = 1;
  return t.forEach((e, l) => {
    d[e.depth] = d[e.depth] || [];
    let a = !1;
    d[e.depth].length === 0 && (r <= 1 ? r = 1 + (e.children.length > 0 ? 0 : i - e.depth) : (r--, a = !0)), e.rowSpan = 1 + (e.children.length > 0 ? 0 : i - e.depth), e.kFirst = a, e.index = d[e.depth].length, d[e.depth].push(l), e.ariaColumnIndex = h[e.depth] ? h[e.depth] + 1 : 1;
    for (let f = e.depth; f < e.depth + e.rowSpan; f++)
      h[f] = (h[f] || 0) + e.colSpan;
  }), s(d, t, n), x(d, t, n), d;
}
function s(t, n, d) {
  const i = new Array(t.length).fill(0);
  let h = 0;
  n.forEach((r) => {
    if (r.locked && (!r.left || d))
      if (r.left = i[r.depth], h = o(r), r.children.length === 0)
        for (let e = r.depth; e < i.length; e++)
          i[e] += h;
      else
        i[r.depth] += h;
  });
}
function x(t, n, d) {
  let i = 0;
  const h = new Array(t.length).fill(0);
  for (let r = n.length - 1; r >= 0; r--) {
    const e = n[r];
    if (e.locked && (!e.right || d)) {
      if (e.right = h[e.depth], i = o(e), e.children.length === 0)
        for (let a = e.depth; a < h.length; a++)
          h[a] += i;
      else
        h[e.depth] += i;
      const l = c(n, r);
      e.rightBorder = !(l && l.locked);
    }
  }
}
function w(t, n, d = 0) {
  const i = [];
  if (!t || !t.length)
    return [];
  t.forEach((r) => {
    const e = w(r.children || [], n, d + 1);
    i.push(
      Object.assign({}, { depth: d }, g, r, {
        id: r.id ? r.id : p(`${n.prevId++}`, n.idPrefix, "column"),
        declarationIndex: i.length,
        children: e,
        rowSpan: 0,
        colSpan: 0,
        isAccessible: !0
      })
    );
  });
  const h = (r, e) => r.orderIndex === e.orderIndex ? r.declarationIndex - e.declarationIndex : (r.orderIndex || 0) - (e.orderIndex || 0);
  if (i.sort(h), d === 0) {
    const r = [], e = (l, a) => l.forEach((f) => {
      f.parentIndex = a, e(f.children, r.push(f) - 1);
    });
    return e(i, -1), r;
  }
  return i;
}
function E(t) {
  return !!(t && getComputedStyle(t).direction === "rtl");
}
function k(t, n) {
  if (!n || !t || !t.originalEvent)
    return -1;
  const d = { x: t.clientX, y: t.originalEvent.clientY };
  let i = n.ownerDocument ? n.ownerDocument.elementFromPoint(d.x, d.y) : null;
  for (; i && i.parentElement !== n; )
    i = i.parentElement;
  if (!i && n.matches("tr")) {
    const r = (e) => {
      const l = e.getBoundingClientRect();
      return d.x > l.left && d.x < l.left + l.width && d.y > l.top && d.y < l.top + l.height;
    };
    i = Array.from(n.children).find(r) || null;
  }
  const h = n.children;
  for (let r = 0; r < h.length; r++)
    if (h[r] === i)
      return r;
  return -1;
}
export {
  k as getIndex,
  E as isRtl,
  I as mapColumns,
  c as nextColumn,
  w as readColumns,
  s as updateLeft,
  x as updateRight
};
