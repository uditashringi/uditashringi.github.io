/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { FOCUSABLE_ELEMENTS as b, TABBABLE_ELEMENTS as y } from "@progress/kendo-react-common";
import { KEYBOARD_NAV_DATA_LEVEL as f, KEYBOARD_NAV_DATA_ID as g, KEYBOARD_NAV_DATA_SCOPE as D, KEYBOARD_NAV_CANCEL_BUTTON_CLASS as w, KEYBOARD_NAV_EDIT_BUTTON_CLASS as B, KEYBOARD_NAV_DATA_HEADER as S, KEYBOARD_NAV_DATA_BODY as h, KEYBOARD_NAV_FILTER_COL_SUFFIX as T } from "./constants.mjs";
const $ = (e, t, r = "cell") => `${t}_${e}_${r}`, k = (e) => {
  if (e)
    return parseInt(e.getAttribute(f) || "", 10);
}, I = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(g);
  return t || void 0;
}, E = (e) => e ? !!e.getAttribute(g) : !1, F = (e, t = { level: 0 }) => e.querySelector(`[${f}='${t.level}']`), m = (e) => e && e.parentElement && e.parentElement.closest(`[${f}]`), p = (e, t) => e.querySelector(`[${g}='${t}']`), R = (e) => e && e.parentElement && e.parentElement.closest(`[${D}]`), L = (e) => {
  const t = e && e.parentElement && e.parentElement.closest(".k-grid-edit-row");
  return t && t.querySelector("." + w);
}, q = (e) => document.querySelector(`[aria-rowindex="${e}"] .k-grid-remove-command`), u = (e) => document.querySelector(`[data-keyboardnavid="${e}"]`), O = (e) => {
  var n;
  const t = e && e.parentElement && e.parentElement.closest(".k-table-row");
  let r;
  return (n = t == null ? void 0 : t.parentElement) == null || n.childNodes.forEach((o) => {
    if (t === o) {
      const l = o.previousSibling;
      r = {
        current: t.getAttribute("aria-rowindex"),
        prev: l && l.getAttribute("aria-rowindex")
      };
    }
  }), r;
};
async function _(e, t, r = 5e3) {
  const n = Date.now();
  if (t)
    for (; Date.now() - n < r; ) {
      const o = t.querySelector(e);
      if (o)
        return o;
      await new Promise((l) => setTimeout(l, 20));
    }
  return !1;
}
const K = async (e) => {
  const t = e && e.parentElement && e.parentElement.closest(".k-grid-edit-row");
  return await _("." + B, t);
}, V = (e) => (e == null ? void 0 : e.closest(".k-table-td")) || null, Y = (e) => e.querySelector(`[${S}]`), P = (e) => e.querySelector(`[${h}]`), oe = (e) => e.querySelector(".k-grid-norecords"), le = (e) => {
  const t = e.querySelector(".k-grid-edit-cell"), r = t && t.querySelector("input");
  r ? r.focus() : t && t.firstChild.focus();
}, U = (e, t) => {
  const { scope: r, navigationStateRef: n, contextStateRef: o } = e;
  if (!n.current || !r)
    return;
  const l = Q(n.current.navigationMatrix), s = p(r, l);
  x({ elementForFocus: s, contextStateRef: o, event: t });
}, j = (e, t = { focusable: !1 }) => {
  const r = t.focusable ? b : y;
  return Array.from(e.querySelectorAll(r.join(",")));
}, W = (e, t = { level: 0 }) => {
  if (!e)
    return [];
  const r = b.map((n) => n + `[${f}='${t.level}']`).join(",");
  return Array.from(e.querySelectorAll(r));
}, H = (e = { level: 0 }) => {
  const t = b.map((r) => r + `[${f}='${e.level}']`).join(",");
  return (r) => r.matches(t);
}, x = (e) => {
  const { elementForFocus: t, event: r, contextStateRef: n, prevElement: o } = e;
  if (n.current && t && t.focus) {
    r == null || r.preventDefault();
    const l = t.querySelector(".k-checkbox-wrap .k-checkbox");
    l && l.focus ? l.focus() : t.focus(), E(t) && (t.setAttribute("tabIndex", "0"), n.current.activeId = I(t)), o && E(o) && o.setAttribute("tabIndex", "-1");
  }
}, M = (e) => e.current ? e.current.idPrefix : "", X = (e, t, r, n, o) => {
  if (!r)
    return [];
  let l = e + (o ? -1 : 1);
  for (; l >= 0 && l < n.length; ) {
    const s = n[l][t];
    if (s !== r)
      return [s, [l, t]];
    l = l + (o ? -1 : 1);
  }
  return [];
}, d = (e, t, r, n, o) => {
  if (!r)
    return [];
  let l = t + (o ? -1 : 1);
  for (; l >= 0 && n[e] && l < n[e].length; ) {
    const s = n[e][l];
    if (s !== r)
      return [s, [e, l]];
    l = l + (o ? -1 : 1);
  }
  return [];
}, A = (e, t) => {
  if (t) {
    for (let r = 0; r < e.length; r++)
      for (let n = 0; n < e[r].length; n++)
        if (e[r][n] === t)
          return [r, n];
  }
}, C = (e, t, r) => {
  let n;
  do
    if (e = e + 1, n = t[r - e], n && n.editable)
      break;
  while (r - e >= 0);
  return n;
}, z = (e, t, r, n) => {
  var v;
  let o;
  const [l, s] = e;
  let i;
  const c = 0, a = t.length;
  return i = C(c, t, s), i ? o = d(l, i.ariaColumnIndex, r, n, !0) : (i = C(c, t, a), o = d(l - 1, i.ariaColumnIndex, r, n, !0)), {
    prevCell: o && o[0] && u(o[0]),
    elementToFocus: o && o[0] && ((v = u(o[0])) == null ? void 0 : v.getAttribute("role"))
  };
}, N = (e, t, r) => {
  let n;
  do
    if (e = e + 1, n = t[r + e], n && n.editable)
      break;
  while (r + e - 1 < t.length);
  return n;
}, G = (e, t, r, n) => {
  var l;
  let o;
  if (e) {
    const [s, i] = e;
    let c, a = 0;
    c = N(a, t, i), c ? o = d(s, c.ariaColumnIndex, r, n, !0) : (a = -1, c = N(a, t, 0), o = d(s + 1, c.ariaColumnIndex, r, n, !0));
  }
  return {
    nextCell: o && o[0] && u(o[0]),
    elementToFocus: o && o[0] && ((l = u(o[0])) == null ? void 0 : l.getAttribute("role"))
  };
}, J = (e) => e.current ? e.current.navigationMatrix.length : 0, Q = (e) => e.flat().find((t) => t.endsWith("cell")), se = (e) => e.flat().reverse().find((t) => t.endsWith("cell")), ce = (e, t) => e[t][0], ie = (e, t) => Array.from(e[t]).reverse()[0], Z = (e) => e ? `${e}${T}` : "", ae = (e, t, r) => {
  let n;
  if (e.current && e.current.prevNavigationIndexes) {
    const [o, l] = e.current.prevNavigationIndexes, s = t[o];
    s && s[l] === r ? n = e.current.prevNavigationIndexes : n = A(t, r);
  } else
    n = A(t, r);
  return n;
}, ee = (e) => {
  var t;
  return ((t = m(e)) == null ? void 0 : t.getAttribute("data-keyboardnavid")) || e.getAttribute("data-keyboardnavid");
}, ue = {
  generateNavigatableId: $,
  getNavigatableId: I,
  getNavigatableLevel: k,
  getNavigatableElement: F,
  getClosestNavigatableElement: m,
  getActiveNavDataElement: p,
  getClosestScope: R,
  getHeaderElement: Y,
  getBodyElement: P,
  getFocusableElements: j,
  getNavigatableElements: W,
  filterNavigatableElements: H,
  focusElement: x,
  getIdPrefix: M,
  isNavigatable: E,
  findNextIdByRowIndex: X,
  findNextIdByCellIndex: d,
  findId: A,
  getNextNavigationIndex: J,
  getFilterColumnId: Z,
  focusFirstDataElement: U,
  getClosestCancelButton: L,
  getClosestEditButton: K,
  getRowAriaRowIndex: O,
  getRemoveButtonByAriaRowIndex: q,
  getTableCellByKeyboardNavId: u,
  getParentCell: V,
  waitForElementToBeVisible: _,
  getNextEditableCell: G,
  getPrevEditableCell: z,
  getClosestCellNavId: ee
};
export {
  H as filterNavigatableElements,
  A as findId,
  d as findNextIdByCellIndex,
  X as findNextIdByRowIndex,
  x as focusElement,
  U as focusFirstDataElement,
  le as focusFirstEditor,
  $ as generateNavigatableId,
  p as getActiveNavDataElement,
  P as getBodyElement,
  L as getClosestCancelButton,
  ee as getClosestCellNavId,
  K as getClosestEditButton,
  m as getClosestNavigatableElement,
  R as getClosestScope,
  ae as getCurrentIdIndexes,
  Z as getFilterColumnId,
  Q as getFirstDataCell,
  ce as getFirstRowDataCell,
  j as getFocusableElements,
  Y as getHeaderElement,
  M as getIdPrefix,
  se as getLastDataCell,
  ie as getLastRowDataCell,
  F as getNavigatableElement,
  W as getNavigatableElements,
  I as getNavigatableId,
  k as getNavigatableLevel,
  G as getNextEditableCell,
  J as getNextNavigationIndex,
  oe as getNoRecordsElement,
  V as getParentCell,
  z as getPrevEditableCell,
  q as getRemoveButtonByAriaRowIndex,
  O as getRowAriaRowIndex,
  u as getTableCellByKeyboardNavId,
  E as isNavigatable,
  ue as tableKeyboardNavigationTools
};
