/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { guid as P, getActiveElement as H, enableNavigatableContainer as S, Keys as s, disableNavigatableContainer as O, keepFocusInContainer as U, TABBABLE_ELEMENTS as V } from "@progress/kendo-react-common";
import { focusFirstDataElement as w, getFirstDataCell as T, tableKeyboardNavigationTools as t, focusFirstEditor as q, getCurrentIdIndexes as G, getFirstRowDataCell as W, getLastRowDataCell as _, getLastDataCell as $, getHeaderElement as j, getBodyElement as z, getNoRecordsElement as J, getNavigatableId as Q, findNextIdByRowIndex as F, findNextIdByCellIndex as X } from "./utils.mjs";
import { NavigatableMode as D } from "./NavigatableSettings.mjs";
const M = (e) => {
  const { navigatable: l, contextStateRef: o, navigationStateRef: n, idPrefix: i } = e;
  l && (o.current = {
    activeId: "",
    level: 0
  }, n.current = {
    activeElementIsFocused: !1,
    prevNavigationIndexes: void 0,
    idPrefix: i || P(),
    navigationMatrix: [],
    lastHeaderIndex: -1
  });
}, L = (e) => {
  const { scope: l, contextStateRef: o, navigationStateRef: n } = e;
  if (o.current && n.current && l) {
    A(e);
    const i = T(n.current.navigationMatrix);
    if (i) {
      const f = t.getActiveNavDataElement(l, i);
      f && (o.current.activeId = i, f.setAttribute("tabIndex", "0"));
    }
  }
}, Y = (e) => {
  const { contextStateRef: l, navigationStateRef: o, document: n } = e;
  if (l.current && o.current && n) {
    const i = H(n), f = t.getNavigatableId(i);
    f && f === l.current.activeId && (o.current.activeElementIsFocused = !0);
  }
}, Z = (e) => {
  const {
    scope: l,
    contextStateRef: o,
    navigationStateRef: n,
    focusFirst: i,
    newEditableRow: f,
    singleEditRow: c,
    lastActiveElement: v,
    navigatable: a
  } = e;
  if (i && (M(e), L(e), w(e)), (!a || a && a.mode === D.inline) && (f && !c || f && c && !v) ? q(f) : a && a.mode === D.inline && f && c && v && v.focus(), A(e), o.current && n.current && l) {
    if (!t.getActiveNavDataElement(l, o.current.activeId)) {
      const E = l.className.indexOf("k-treelist") === -1 ? T(n.current.navigationMatrix) : n.current.navigationMatrix[0][0], I = t.getActiveNavDataElement(l, E);
      E && I && (o.current.activeId = E, I.setAttribute("tabIndex", "0"), n.current.activeElementIsFocused && I.focus());
    }
    n.current.activeElementIsFocused = !1;
  }
}, ee = (e, l) => {
  const { contextStateRef: o } = l;
  if (e.isDefaultPrevented() || !o.current)
    return;
  const n = e.target, i = t.getNavigatableId(n);
  if (i && i !== o.current.activeId) {
    const f = t.getClosestScope(n);
    if (!f)
      return;
    const c = t.getActiveNavDataElement(f, o.current.activeId);
    c && !e.target.classList.contains("k-table-td") && !e.target.classList.contains("k-detail-cell") && c.setAttribute("tabIndex", "-1"), n.setAttribute("tabIndex", "0"), o.current.activeId = i;
  } else if (n.closest(".k-filtercell") && l.navigatable) {
    const f = n.closest(".k-table-td");
    S(f);
  }
}, te = async (e, l) => {
  var N, p, R, h;
  const { contextStateRef: o, navigationStateRef: n, onNavigationAction: i, columns: f } = l;
  if (e.isDefaultPrevented() || !o.current || !n.current)
    return;
  let c;
  if (e.keyCode === s.esc && !l.navigatable.mode) {
    c = t.getClosestNavigatableElement(e.target), t.focusElement({ elementForFocus: c, event: e, contextStateRef: o }), e.target.closest(".k-filtercell") && c && l.navigatable && O(c);
    return;
  }
  const v = e.target, a = v.className.indexOf("k-checkbox") === -1 ? v : t.getClosestNavigatableElement(v), m = t.getNavigatableId(a) || ((N = t.getParentCell(a)) == null ? void 0 : N.getAttribute("data-keyboardnavid")), E = m == null ? void 0 : m.endsWith("column"), I = t.getNavigatableLevel(a), x = t.getClosestScope(a), y = n.current.navigationMatrix, k = e.metaKey || e.ctrlKey, u = G(n, y, m), C = a.closest(".k-table-td");
  if (l.navigatable && l.navigatable.mode === D.inline) {
    if (e.keyCode === s.enter) {
      const d = a.classList.contains("k-grid-remove-command"), r = a.classList.contains("k-grid-cancel-command"), g = t.getRowAriaRowIndex(a);
      if (d) {
        setTimeout(() => {
          const b = t.getRemoveButtonByAriaRowIndex(g.current) || t.getRemoveButtonByAriaRowIndex(g.prev);
          b && b.focus();
        });
        return;
      } else if (r && a.parentElement) {
        const b = (p = t.getClosestNavigatableElement(a)) == null ? void 0 : p.getAttribute("data-keyboardnavid");
        setTimeout(() => {
          b && t.getTableCellByKeyboardNavId(b).focus();
        });
        return;
      }
    }
    if (e.keyCode === s.esc) {
      const d = t.getClosestCancelButton(a);
      d && d.click();
      const r = await t.getClosestEditButton(a);
      r && r.focus();
      return;
    }
  } else if (l.navigatable && l.navigatable.mode === D.incell) {
    const d = (R = a.closest(".k-table-td")) == null ? void 0 : R.classList.contains("k-grid-edit-cell");
    if (e.keyCode === s.esc) {
      a.focus(), a.blur();
      const r = v && v.parentElement && v.parentElement.closest(".k-grid-edit-row"), g = t.getClosestCellNavId(a), b = await t.waitForElementToBeVisible(
        `[data-keyboardnavid='${g}']:not(.k-grid-edit-cell)`,
        r
      );
      b && b.focus();
    } else if (e.keyCode === s.enter) {
      let r;
      if (u) {
        const [g, b] = u;
        r = F(g, b, m, y, !1);
      }
      if (!d)
        (h = t.getParentCell(a)) == null || h.click();
      else if (d && r) {
        const g = r && r[0] && t.getTableCellByKeyboardNavId(r[0]);
        g && g.click();
      }
    } else if (e.keyCode === s.left) {
      if (d)
        return;
    } else if (e.keyCode === s.right) {
      if (d)
        return;
    } else if (e.keyCode === s.up) {
      if (d)
        return;
    } else if (e.keyCode === s.down) {
      if (d)
        return;
    } else if (e.keyCode === s.tab && d) {
      if (e.shiftKey) {
        const r = u && f && t.getPrevEditableCell(u, f, m, y);
        if (r && r.prevCell && r.prevCell.click(), r && r.elementToFocus !== "gridcell") {
          a.blur();
          const g = t.getClosestCellNavId(a);
          setTimeout(() => {
            g && t.getTableCellByKeyboardNavId(g).focus();
          });
        }
        e.preventDefault();
      } else {
        const r = u && f && t.getNextEditableCell(u, f, m, y);
        if (r && r.nextCell && r.elementToFocus === "gridcell" && r.nextCell.click(), r && r.elementToFocus !== "gridcell") {
          a.blur();
          const g = t.getClosestCellNavId(a);
          g && t.getTableCellByKeyboardNavId(g).focus();
          return;
        }
        e.preventDefault();
      }
      e.preventDefault();
    }
  }
  if (a.closest(".k-filtercell") && C && l.navigatable && U(e, C, V), I !== void 0 && x) {
    if (e.keyCode === s.enter) {
      const d = t.getNavigatableElement(a, { level: I + 1 });
      if (d) {
        t.focusElement({
          elementForFocus: d,
          event: e,
          contextStateRef: o,
          prevElement: a
        });
        return;
      }
      a.querySelector(".k-filtercell") && l.navigatable && S(a), c = t.getFocusableElements(a)[0], t.focusElement({ elementForFocus: c, event: e, contextStateRef: o, prevElement: a });
      return;
    }
    if (e.keyCode === s.home && u)
      if (k)
        w(
          {
            scope: x,
            navigationStateRef: n,
            contextStateRef: o
          },
          e
        );
      else {
        const d = W(
          n.current.navigationMatrix,
          u[0]
        );
        c = t.getActiveNavDataElement(x, d), t.focusElement({ elementForFocus: c, event: e, contextStateRef: o });
      }
    if (e.keyCode === s.end && u)
      if (k) {
        const d = $(n.current.navigationMatrix);
        c = t.getActiveNavDataElement(x, d), t.focusElement({ elementForFocus: c, event: e, contextStateRef: o });
      } else {
        const d = _(
          n.current.navigationMatrix,
          u[0]
        );
        c = t.getActiveNavDataElement(x, d), t.focusElement({ elementForFocus: c, event: e, contextStateRef: o });
      }
    if (e.keyCode === s.up || e.keyCode === s.down || e.keyCode === s.left || e.keyCode === s.right) {
      const d = e.keyCode === s.up || e.keyCode === s.left, r = e.keyCode === s.up || e.keyCode === s.down;
      if (u) {
        const [g, b] = u, [B, K] = r ? F(g, b, m, y, d) : X(g, b, m, y, d);
        B && (c = t.getActiveNavDataElement(x, B), t.focusElement({ elementForFocus: c, event: e, contextStateRef: o, prevElement: a }), n.current.prevNavigationIndexes = K);
      }
    }
    if (k && e.keyCode === s.left && E) {
      i && i({ focusElement: a, event: e, action: "reorderToLeft" }), e.preventDefault();
      return;
    }
    if (k && e.keyCode === s.right && E) {
      i && i({ focusElement: a, event: e, action: "reorderToRight" }), e.preventDefault();
      return;
    }
    if (e.keyCode === s.pageUp) {
      i && i({ focusElement: c, event: e, action: "moveToNextPage" }), e.preventDefault();
      return;
    }
    if (e.keyCode === s.pageDown) {
      i && i({ focusElement: c, event: e, action: "moveToPrevPage" }), e.preventDefault();
      return;
    }
    i && i({ focusElement: c, event: e });
  }
}, A = (e) => {
  const { navigationStateRef: l, scope: o } = e;
  if (!l.current || !o)
    return;
  const n = [], i = j(o), f = z(o), c = J(o) || { children: [] };
  if (!i || !f)
    return;
  const v = Array.from(i.children), a = Array.from(f.children);
  [...v, ...a, c].forEach((m, E) => {
    Array.from(m.children).forEach((I) => {
      const x = Q(I);
      if (!x)
        return;
      const y = I.rowSpan || 1, k = I.colSpan || 1;
      let u;
      for (let C = E, N = E + y; C < N; C++) {
        if (n[C] || (n[C] = []), u === void 0) {
          const p = n[C].findIndex((R) => !R);
          u = p > -1 ? p : n[C].length;
        }
        n[C][u] = x || "";
      }
      for (let C = u + 1, N = u + k; C < N; C++)
        n[E][C] = x || "";
    });
  }), l.current.navigationMatrix = n.filter((m) => !!m), l.current.lastHeaderIndex = v.length - 1;
}, le = {
  onConstructor: M,
  onComponentDidMount: L,
  onGetSnapshotBeforeUpdate: Y,
  onComponentDidUpdate: Z,
  onFocus: ee,
  onKeyDown: te,
  generateMatrix: A,
  focusFirstDataElement: w
};
export {
  le as tableKeyboardNavigation
};
