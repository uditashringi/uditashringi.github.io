/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import s from "prop-types";
import { Button as P } from "../Button.mjs";
import { Keys as r, dispatchEvent as d, getActiveElement as m, validatePackage as A, svgIconPropType as M, classNames as u, uDropDownButton as l, UnstyledContext as R } from "@progress/kendo-react-common";
import { navigate as N } from "./utils/navigation.mjs";
import { DropDownButtonItem as T } from "./DropDownButtonItem.mjs";
import { ButtonItem as z } from "./ButtonItem.mjs";
import { Popup as U } from "@progress/kendo-react-popup";
import { getAnchorAlign as $, getPopupAlign as L } from "./utils/popup.mjs";
import { packageMetadata as j } from "../package-metadata.mjs";
const c = class c extends a.Component {
  constructor(i) {
    super(i), this.state = {
      opened: !1,
      focused: !1,
      focusedIndex: -1
    }, this.mainButton = null, this.list = null, this.skipFocus = !1, this.buttonsData = [], this.onKeyDown = (t) => {
      const { focusedIndex: e } = this.state;
      if (t.altKey) {
        !this.opened && t.keyCode === r.down ? (t.preventDefault(), this.setOpen(!0, t), this.setState({ focusedIndex: 0 })) : this.opened && t.keyCode === r.up && (t.preventDefault(), this.setState({ focusedIndex: -1 }), this.setOpen(!1, t));
        return;
      }
      const o = { ...this.state };
      if (t.keyCode === r.enter || t.keyCode === r.space) {
        t.preventDefault(), e >= 0 && this.dispatchClickEvent(t, e);
        const n = !this.opened;
        this.setState({
          focused: !0,
          focusedIndex: n ? 0 : -1
        }), this.setOpen(n, t);
        return;
      }
      if (this.opened && t.keyCode === r.esc) {
        this.setState({ focusedIndex: -1 }), this.setOpen(!1, t);
        return;
      }
      if (this.opened) {
        const n = N(e, t.keyCode, t.altKey, this.buttonsData.length);
        o.focusedIndex = n;
        const h = t.keyCode === r.up || t.keyCode === r.down || t.keyCode === r.left || t.keyCode === r.right;
        !t.altKey && (h || t.keyCode === r.home || t.keyCode === r.end) && t.preventDefault();
      }
      this.setState(o);
    }, this.switchFocus = (t) => {
      this.skipFocus = !0, t(), window.setTimeout(() => this.skipFocus = !1, 0);
    }, this.handleFocus = (t) => {
      this.skipFocus || (this.setState({ focused: !0, focusedIndex: this.opened ? 0 : -1 }), d(this.props.onFocus, t, this, void 0));
    }, this.handleButtonBlur = (t) => {
      this.opened || (this.setState({ focused: !1 }), d(this.props.onBlur, t, this, void 0));
    }, this.handleMenuBlur = (t) => {
      this.skipFocus || (this.setState({ focused: !1, focusedIndex: -1 }), d(this.props.onBlur, t, this, void 0), setTimeout(() => {
        this.setOpen(!1, t);
      }, 0));
    }, this.setOpen = (t, e) => {
      this.opened !== t && (this.openedDuringOnChange = t, this.setState({ opened: t }), e ? this.dispatchPopupEvent(e, t) : this.openedDuringOnChange = void 0);
    }, this.onItemClick = (t, e) => {
      this.setState({ focusedIndex: -1 }), this.dispatchClickEvent(t, e), this.setOpen(!1, t);
    }, this.onItemDown = (t) => {
      m(document) === this.list && t.preventDefault();
    }, this.mouseDown = (t) => {
      t.preventDefault();
      const e = m(document);
      this.element && e !== this.element && e !== this.list && this.element.focus();
    }, this.onPopupClose = (t) => {
      var o;
      const e = m(document);
      this.element && this.element.removeAttribute("tabindex"), (e === this.list || (o = this.list) != null && o.contains(e)) && this.switchFocus(() => {
        this.element && this.element.focus({ preventScroll: !0 });
      }), this.props.popupSettings && this.props.popupSettings.onClose && this.props.popupSettings.onClose.call(void 0, t);
    }, this.listRef = (t) => {
      this.list = t, t && this.state.focused && this.switchFocus(() => {
        t.focus({ preventScroll: !0 }), this.element && (this.element.tabIndex = -1);
      });
    }, this.onClickMainButton = (t) => {
      if (!this.buttonsData.length)
        return;
      const e = !this.opened;
      this.setState({
        focused: !0,
        focusedIndex: e ? 0 : -1
      }), this.setOpen(e, t);
    }, this.dispatchPopupEvent = (t, e) => {
      d(e ? this.props.onOpen : this.props.onClose, t, this, void 0), this.openedDuringOnChange = void 0;
    }, A(j);
  }
  get guid() {
    return this.props.id + "-accessibility-id";
  }
  get opened() {
    return this.openedDuringOnChange !== void 0 ? this.openedDuringOnChange : this.props.opened === void 0 ? this.state.opened : this.props.opened;
  }
  /**
   * @hidden
   */
  render() {
    const i = this.isRtl(), t = this.context && this.context.uDropDownButton, e = i ? "rtl" : void 0, {
      id: o,
      style: n,
      tabIndex: h,
      disabled: g,
      size: C,
      rounded: y,
      fillMode: D,
      themeColor: b,
      ariaLabel: I,
      title: k,
      accessKey: w,
      icon: x,
      svgIcon: B,
      iconClass: S,
      buttonClass: O,
      className: F,
      imageUrl: E,
      startIcon: v,
      endIcon: K
    } = this.props;
    return this.buttonsData = this.props.items || a.Children.toArray(this.props.children).filter((p) => p && p.type === T).map((p) => p.props), /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
      P,
      {
        id: o,
        size: C,
        style: n,
        rounded: y,
        fillMode: D,
        themeColor: b,
        onClick: this.onClickMainButton,
        onMouseDown: this.mouseDown,
        onKeyDown: this.onKeyDown,
        onFocus: this.handleFocus,
        onBlur: this.handleButtonBlur,
        "aria-disabled": g ? "true" : void 0,
        tabIndex: h,
        accessKey: w,
        icon: x,
        svgIcon: B,
        iconClass: S,
        className: u(
          O,
          F,
          l.wrapper({
            c: t,
            focused: this.state.focused,
            disabled: g
          })
        ),
        imageUrl: E,
        dir: e,
        ref: (p) => this.mainButton = p && p.element,
        type: "button",
        "aria-expanded": this.opened ? "true" : "false",
        "aria-label": I,
        "aria-controls": this.opened ? this.guid : void 0,
        title: k,
        startIcon: v,
        endIcon: K
      },
      this.props.text
    ), this.renderPopup(i));
  }
  /**
   * @hidden
   */
  componentDidMount() {
    (this.props.dir === void 0 && this.isRtl() || this.opened) && this.forceUpdate();
  }
  /**
   * The DOM element of main button.
   */
  get element() {
    return this.mainButton;
  }
  dispatchClickEvent(i, t) {
    this.isItemDisabled(t) || d(this.props.onItemClick, i, this, {
      item: this.buttonsData[t],
      itemIndex: t
    });
  }
  renderPopup(i) {
    const { popupSettings: t = {}, id: e } = this.props, o = this.context && this.context.uDropDownButton, { focusedIndex: n } = this.state;
    return /* @__PURE__ */ a.createElement(
      U,
      {
        anchor: this.mainButton,
        show: this.opened,
        animate: t.animate,
        popupClass: u(l.popup({ c: o }), t.popupClass),
        anchorAlign: t.anchorAlign || $(i),
        popupAlign: t.popupAlign || L(i),
        style: i ? { direction: "rtl" } : void 0,
        onClose: this.onPopupClose
      },
      /* @__PURE__ */ a.createElement(
        "ul",
        {
          role: "list",
          id: this.guid,
          tabIndex: -1,
          "aria-activedescendant": n >= 0 ? `${this.guid}-${n}` : void 0,
          ref: this.listRef,
          onKeyDown: this.onKeyDown,
          onBlur: this.handleMenuBlur,
          className: u(
            l.ul({
              c: o,
              size: this.props.size
            })
          )
        },
        this.renderChildItems()
      )
    );
  }
  renderChildItems() {
    const { item: i, itemRender: t, textField: e } = this.props, o = this.context && this.context.uDropDownButton;
    return this.buttonsData.length > 0 ? this.buttonsData.map((n, h) => /* @__PURE__ */ a.createElement(
      z,
      {
        className: u(
          l.item({
            c: o
          }),
          n.className,
          { "k-first": h === 0 },
          { "k-last": h === this.buttonsData.length - 1 }
        ),
        dataItem: n,
        textField: e,
        focused: this.state.focusedIndex === h,
        onClick: this.onItemClick,
        onDown: this.onItemDown,
        render: t,
        item: i,
        index: h,
        key: h,
        id: `${this.guid}-${h}`
      }
    )) : null;
  }
  isItemDisabled(i) {
    return this.buttonsData[i] ? this.buttonsData[i].disabled : this.props.disabled;
  }
  isRtl() {
    return this.props.dir !== void 0 ? this.props.dir === "rtl" : !!this.mainButton && getComputedStyle(this.mainButton).direction === "rtl";
  }
};
c.propTypes = {
  accessKey: s.string,
  ariaLabel: s.string,
  title: s.string,
  onFocus: s.func,
  onBlur: s.func,
  onItemClick: s.func,
  onOpen: s.func,
  onClose: s.func,
  items: s.arrayOf(s.any),
  textField: s.string,
  tabIndex: s.number,
  disabled: s.bool,
  icon: s.string,
  svgIcon: M,
  iconClass: s.string,
  imageUrl: s.string,
  popupSettings: s.object,
  itemRender: s.func,
  item: s.func,
  className: s.string,
  buttonClass: s.string,
  dir: s.string
}, c.defaultProps = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let f = c;
f.contextType = R;
export {
  f as DropDownButton
};
