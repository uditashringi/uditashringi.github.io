/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as F from "react";
import e from "prop-types";
import { validatePackage as y, getTabIndex as b } from "@progress/kendo-react-common";
import { UploadFileStatus as r } from "./interfaces/UploadFileStatus.mjs";
import { UploadNavigation as E } from "./UploadNavigation.mjs";
import g from "axios";
import C from "./utils/utils.mjs";
import p from "./utils/stateUtils.mjs";
import f from "./utils/connectionUtils.mjs";
import w from "./utils/validationUtils.mjs";
import { packageMetadata as D } from "./package-metadata.mjs";
const m = class m extends F.Component {
  constructor(v) {
    super(v), this._httpSubscriptions = {}, this._uploadNavigation = null, this.focus = () => {
      this._uploadNavigation && this._uploadNavigation.focus();
    }, this.triggerUpload = () => {
      this.onUpload();
    }, this.uploadFiles = (i) => {
      const t = this.async;
      p.setFilesStatus(i, r.Uploading), p.groupForEach(i, (s, a) => {
        const n = f.cloneRequestHeaders(t.saveHeaders || {}), l = {
          target: this,
          files: s,
          headers: n,
          additionalData: {}
        };
        this.props.onBeforeUpload && this.props.onBeforeUpload.call(void 0, l);
        const c = f.populateRequestOptions(l.headers, this.async), u = f.populateUploadFormData(
          s,
          t.saveField,
          l.additionalData
        );
        if (this.isCustomSave)
          this.props.saveUrl(
            s,
            { formData: u, requestOptions: c },
            this.onUploadProgress
          ).then((d) => this.onUploadSuccess(d.uid)).catch((d) => this.onUploadError(d.uid));
        else {
          const d = g.CancelToken.source();
          this._httpSubscriptions[a] = d, g({
            method: t.saveMethod,
            url: t.saveUrl,
            data: u,
            cancelToken: d.token,
            ...c,
            onUploadProgress: (h) => this.onUploadProgress(a, h)
          }).then((h) => this.onUploadSuccess(a, h)).catch((h) => this.onUploadError(a, h));
        }
      });
    }, this.removeFiles = (i) => {
      const t = this.async;
      p.groupForEach(i, (s, a) => {
        const n = f.cloneRequestHeaders(t.removeHeaders || {}), l = {
          target: this,
          files: s,
          headers: n,
          additionalData: {}
        };
        this.props.onBeforeRemove && this.props.onBeforeRemove.call(void 0, l);
        const c = s.map((h) => h.name), u = f.populateRequestOptions(l.headers, this.async), d = f.populateRemoveFormData(
          c,
          t.removeField,
          l.additionalData
        );
        this.isCustomRemove ? this.props.removeUrl(s, { formData: d, requestOptions: u }).then((h) => this.onRemoveSuccess(h.uid)).catch((h) => this.onRemoveError(h.uid)) : g({
          method: t.removeMethod,
          url: t.removeUrl,
          data: d,
          ...u
        }).then((h) => this.onRemoveSuccess(a, h)).catch((h) => this.onRemoveError(a, h));
      });
    }, this.onUpload = () => {
      const i = this.fileStateCopy, t = p.groupFilesByUid(i), s = p.filesForUpload(t);
      this.uploadFiles(s);
      const a = () => {
        if (this.props.onStatusChange) {
          const n = {
            target: this,
            newState: i,
            affectedFiles: p.flatFileGroup(s)
          };
          this.props.onStatusChange.call(void 0, n);
        }
      };
      this.isControlled ? a() : this.setState({ files: i }, a);
    }, this.onAdd = (i) => {
      let t = C.getAllFileInfo(i), s;
      if (t = C.assignGuidToFiles(t, this.async.batch), w.validateFiles(t, this.props.restrictions), this.props.multiple ? s = this.fileStateCopy : s = [], p.addMany(t, s), this.async.autoUpload) {
        const n = p.groupFilesByUid(s);
        this.uploadFiles(p.filesForUpload(n));
      }
      const a = () => {
        if (this.props.onAdd) {
          const n = {
            target: this,
            newState: s,
            affectedFiles: t
          };
          this.props.onAdd.call(void 0, n);
        }
      };
      this.isControlled ? a() : this.setState({ files: s }, a);
    }, this.onUploadProgress = (i, t) => {
      const s = Math.round(100 * t.loaded / (t.total || 0)) || 0, a = this.fileStateCopy, n = a.filter((l) => l.uid === i);
      if (!n.length)
        return;
      n.forEach((l) => {
        l.progress = s;
      });
      const o = () => {
        if (this.props.onProgress) {
          const l = {
            target: this,
            newState: a,
            affectedFiles: n
          };
          this.props.onProgress.call(void 0, l);
        }
      };
      this.isControlled ? o() : this.setState({ files: a }, o);
    }, this.onUploadSuccess = (i, t) => {
      const s = this.fileStateCopy, a = s.filter((o) => o.uid === i);
      a.forEach((o) => {
        o.status = r.Uploaded;
      }), delete this._httpSubscriptions[i];
      const n = () => {
        if (this.props.onStatusChange) {
          const o = {
            target: this,
            newState: s,
            affectedFiles: a,
            response: t ? f.convertAxiosResponse(t) : void 0
          };
          this.props.onStatusChange.call(void 0, o);
        }
      };
      this.isControlled ? n() : this.setState({ files: s }, n);
    }, this.onUploadError = (i, t) => {
      const s = this.fileStateCopy, a = s.filter((o) => o.uid === i);
      if (a.forEach((o) => {
        o.status = r.UploadFailed;
      }), delete this._httpSubscriptions[i], !a.length)
        return;
      const n = () => {
        if (this.props.onStatusChange) {
          const o = {
            target: this,
            newState: s,
            affectedFiles: a,
            response: t ? f.convertAxiosResponse(t) : void 0
          };
          this.props.onStatusChange.call(void 0, o);
        }
      };
      this.isControlled ? n() : this.setState({ files: s }, n);
    }, this.onRemove = (i) => {
      const t = this.fileStateCopy, s = t.filter((o) => o.uid === i), a = t.filter((o) => o.uid !== i);
      if ([
        r.Uploaded,
        r.Initial,
        r.RemoveFailed
      ].indexOf(s[0].status) > -1) {
        const o = {
          [i]: s
        };
        p.setFilesStatus(o, r.Removing), this.removeFiles(o);
        const l = () => {
          if (this.props.onStatusChange) {
            const c = {
              target: this,
              newState: t,
              affectedFiles: s
            };
            this.props.onStatusChange.call(void 0, c);
          }
        };
        this.isControlled ? l() : this.setState({ files: t }, l);
      } else {
        const o = () => {
          if (this.props.onRemove) {
            const l = {
              target: this,
              newState: a,
              affectedFiles: s
            };
            this.props.onRemove.call(void 0, l);
          }
        };
        this.isControlled ? o() : this.setState({ files: a }, o);
      }
    }, this.onRemoveSuccess = (i, t) => {
      const s = this.fileStateCopy, a = s.filter((l) => l.uid === i), n = s.filter((l) => l.uid !== i), o = () => {
        if (this.props.onRemove) {
          const l = {
            target: this,
            newState: n,
            affectedFiles: a,
            response: t ? f.convertAxiosResponse(t) : void 0
          };
          this.props.onRemove.call(void 0, l);
        }
      };
      this.isControlled ? o() : this.setState({ files: n }, o);
    }, this.onRemoveError = (i, t) => {
      const s = this.fileStateCopy, a = s.filter((o) => o.uid === i);
      a.forEach((o) => {
        o.status = r.RemoveFailed;
      });
      const n = () => {
        if (this.props.onStatusChange) {
          const o = {
            target: this,
            newState: s,
            affectedFiles: a,
            response: t ? f.convertAxiosResponse(t) : void 0
          };
          this.props.onStatusChange.call(void 0, o);
        }
      };
      this.isControlled ? n() : this.setState({ files: s }, n);
    }, this.onRetry = (i) => {
      const t = this.fileStateCopy, s = p.groupFilesByUid(t.filter((n) => n.uid === i));
      p.setFilesStatus(s, r.Uploading), this.uploadFiles(s);
      const a = () => {
        if (this.props.onStatusChange) {
          const n = {
            target: this,
            newState: t,
            affectedFiles: p.flatFileGroup(s)
          };
          this.props.onStatusChange.call(void 0, n);
        }
      };
      this.isControlled ? a() : this.setState({ files: t }, a);
    }, this.onCancel = (i) => {
      const t = this.fileStateCopy, s = t.filter((o) => o.uid !== i), a = t.filter((o) => o.uid === i);
      if (this._httpSubscriptions[i] && (this._httpSubscriptions[i].cancel(), delete this._httpSubscriptions[i]), this.props.onCancel) {
        const o = {
          target: this,
          uid: i
        };
        this.props.onCancel.call(void 0, o);
      }
      const n = () => {
        if (this.props.onRemove) {
          const o = {
            target: this,
            newState: s,
            affectedFiles: a
          };
          this.props.onRemove.call(void 0, o);
        }
      };
      this.isControlled ? n() : this.setState({ files: s }, n);
    }, this.onClear = () => {
      if (!this.files.length)
        return;
      Object.keys(this._httpSubscriptions).forEach((t) => {
        this._httpSubscriptions[t].cancel();
      }), this._httpSubscriptions = {};
      const i = () => {
        if (this.props.onRemove) {
          const t = {
            target: this,
            newState: [],
            affectedFiles: this.fileStateCopy
          };
          this.props.onRemove.call(void 0, t);
        }
      };
      this.isControlled ? i() : this.setState({ files: [] }, i);
    }, y(D), this.state = {
      files: v.defaultFiles || []
    };
  }
  get async() {
    const {
      autoUpload: v,
      batch: i,
      removeField: t,
      removeHeaders: s,
      removeMethod: a,
      removeUrl: n,
      responseType: o,
      saveField: l,
      saveHeaders: c,
      saveMethod: u,
      saveUrl: d,
      withCredentials: h
    } = this.props;
    return {
      autoUpload: v,
      batch: i,
      removeField: t,
      removeHeaders: s,
      removeMethod: a,
      removeUrl: n,
      responseType: o,
      saveField: l,
      saveHeaders: c,
      saveMethod: u,
      saveUrl: d,
      withCredentials: h
    };
  }
  get files() {
    return (this.isControlled ? this.props.files : this.state.files) || [];
  }
  get isControlled() {
    return !this.props.defaultFiles;
  }
  get isCustomSave() {
    return this.props.saveUrl && typeof this.props.saveUrl == "function";
  }
  get isCustomRemove() {
    return this.props.removeUrl && typeof this.props.removeUrl == "function";
  }
  get fileStateCopy() {
    return this.isControlled ? p.copyState(this.props.files) : p.copyState(this.state.files);
  }
  /**
   * @hidden
   */
  get actionElement() {
    if (this._uploadNavigation)
      return this._uploadNavigation.actionElement;
  }
  /**
   * @hidden
   */
  render() {
    var S;
    const {
      showFileList: v,
      onAdd: i,
      onRemove: t,
      onCancel: s,
      autoUpload: a,
      showActionButtons: n,
      actionsLayout: o,
      tabIndex: l,
      disabled: c,
      ...u
    } = this.props, d = p.groupFilesByUid(this.files), h = p.filesForUpload(d);
    return /* @__PURE__ */ F.createElement(
      E,
      {
        groupedFiles: d,
        className: this.props.className,
        showFileList: v && !!Object.keys(d).length,
        showActionButtons: n && !a && (!!Object.keys(h).length || !!((S = this.props.defaultFiles) != null && S.length)),
        actionsLayout: o,
        autoUpload: a,
        disabled: c,
        onAdd: this.onAdd,
        onRemove: this.onRemove,
        onClear: this.onClear,
        onUpload: this.onUpload,
        onRetry: this.onRetry,
        onCancel: this.onCancel,
        tabIndex: b(l, c),
        ref: (R) => this._uploadNavigation = R,
        ...u
      }
    );
  }
};
m.defaultProps = {
  autoUpload: !0,
  batch: !1,
  removeField: "fileNames",
  removeHeaders: {},
  removeMethod: "POST",
  removeUrl: "",
  responseType: "json",
  saveField: "files",
  saveHeaders: {},
  saveMethod: "POST",
  saveUrl: "",
  withCredentials: !0,
  restrictions: {
    allowedExtensions: [],
    maxFileSize: 0,
    minFileSize: 0
  },
  multiple: !0,
  showFileList: !0,
  showActionButtons: !0,
  actionsLayout: "end",
  disabled: !1
}, m.propTypes = {
  autoUpload: e.bool,
  batch: e.bool,
  withCredentials: e.bool,
  saveField: e.string,
  saveHeaders: e.object,
  saveMethod: e.string,
  saveUrl: e.oneOfType([e.string, e.func]),
  responseType: e.oneOf(["arraybuffer", "blob", "json", "text"]),
  removeField: e.string,
  removeHeaders: e.object,
  removeMethod: e.string,
  removeUrl: e.oneOfType([e.string, e.func]),
  multiple: e.bool,
  disabled: e.bool,
  showFileList: e.bool,
  showActionButtons: e.bool,
  actionsLayout: e.oneOf(["start", "center", "end", "stretched"]),
  tabIndex: e.number,
  accept: e.string,
  listItemUI: e.oneOfType([
    e.func,
    e.string,
    e.shape({ render: e.func.isRequired })
  ]),
  restrictions: e.shape({
    allowedExtensions: e.arrayOf(e.string),
    maxFileSize: e.number,
    minFileSize: e.number
  }),
  files: e.arrayOf(
    e.shape({
      uid: e.string,
      name: e.string,
      extension: e.string,
      size: e.number,
      validationErrors: e.arrayOf(e.string),
      status: e.oneOf([
        r.Initial,
        r.RemoveFailed,
        r.Removing,
        r.Selected,
        r.UploadFailed,
        r.Uploaded,
        r.Uploading
      ]),
      progress: e.number,
      getRawFile: e.func
    })
  ),
  defaultFiles: e.arrayOf(
    e.shape({
      uid: e.string,
      name: e.string,
      extension: e.string,
      size: e.number,
      validationErrors: e.arrayOf(e.string),
      status: e.oneOf([
        r.Initial,
        r.RemoveFailed,
        r.Removing,
        r.Selected,
        r.UploadFailed,
        r.Uploaded,
        r.Uploading
      ]),
      progress: e.number,
      getRawFile: e.func
    })
  )
};
let U = m;
export {
  U as Upload
};
