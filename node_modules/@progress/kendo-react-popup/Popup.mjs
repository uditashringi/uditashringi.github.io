/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as i from "react";
import * as we from "react-dom";
import t from "prop-types";
import { slide as ve } from "./animation.mjs";
import { validatePackage as ye, useUnstyled as Pe, useZIndexContext as Oe, canUseDOM as Ee, ZIndexContext as be, classNames as D, uPopup as A } from "@progress/kendo-react-common";
import { Collision as w, AlignPoint as s, alignElement as Ce, positionElement as xe, domUtils as De } from "@progress/kendo-popup-common";
import { throttle as Ae, FRAME_DURATION as Te } from "./util.mjs";
import { packageMetadata as Re } from "./package-metadata.mjs";
const Ne = i.createContext((l) => l), ze = 100, Ie = 1;
function b(l, a) {
  if (l === a)
    return !0;
  if (!!l != !!a)
    return !1;
  const T = Object.getOwnPropertyNames(l), R = Object.getOwnPropertyNames(a);
  if (T.length !== R.length)
    return !1;
  for (let m = 0; m < T.length; m++) {
    const h = T[m];
    if (l[h] !== a[h])
      return !1;
  }
  return !0;
}
const Me = {
  left: -1e3,
  top: 0
}, te = i.forwardRef((l, a) => {
  const R = i.useContext(Ne).call(void 0, l);
  ye(Re);
  const {
    collision: m = g.collision,
    anchorAlign: h = g.anchorAlign,
    popupAlign: v = g.popupAlign,
    offset: N = g.offset,
    animate: ne = g.animate,
    show: y = g.show,
    margin: F = g.margin,
    positionMode: H = g.positionMode,
    appendTo: P,
    contentKey: z,
    anchor: p,
    scale: oe,
    role: re,
    onKeyDown: ie,
    onPosition: q,
    onOpen: V,
    onMouseDownOutside: X,
    onClose: W,
    className: I,
    popupClass: M,
    id: se,
    style: L,
    children: ce
  } = R, le = Pe(), S = R.unstyled || le, C = S && S.uPopup, [o, U] = i.useState({
    current: "hidden",
    previous: "hidden",
    props: {}
  }), B = (e) => {
    window == null || window.addEventListener("mousedown", J), k(e), G(e.firstChild, "enter", ue), U({ ...n, current: "shown", previous: n.current });
  }, k = (e) => {
    const { width: r, height: d } = e.style;
    e.style.width = e.offsetWidth + "px", e.style.height = e.offsetHeight + "px";
    const f = Ce({
      anchor: p,
      anchorAlign: h,
      element: e,
      elementAlign: v,
      offset: N,
      margin: F,
      positionMode: H,
      scale: oe
    }), u = xe({
      anchor: p,
      anchorAlign: h,
      element: e,
      elementAlign: v,
      collisions: m,
      currentLocation: f,
      margin: F
    });
    if (e.style.top = u.offset.top + "px", e.style.left = u.offset.left + "px", e.style.width = r, e.style.height = d, _.current = {
      fit: u.fit,
      fitted: u.fitted,
      flip: u.flip,
      flipped: u.flipped
    }, q) {
      const x = {
        target: E.current,
        flipped: u.flipped,
        fitted: u.fitted
      };
      q.call(void 0, x);
    }
  }, ue = () => {
    const e = c.current;
    e && (y && e.classList.add(
      ...D(A.animationContainerShown({ c: C })).split(" ").filter((r) => r)
    ), fe(e), V && V.call(void 0, { target: E.current }));
  }, G = (e, r, d) => {
    if (!v)
      return;
    let f;
    const { horizontal: u, vertical: x } = v;
    u === "left" && x === "center" ? f = "right" : u === "right" && x === "center" ? f = "left" : x === "top" ? f = "down" : f = "up";
    const ge = {
      down: "up",
      up: "down",
      left: "right",
      right: "left"
    };
    _.current && _.current.flipped && (f = ge[f]), ve(e, f, pe()[r], r, d, C);
  }, J = (e) => {
    var f;
    const r = ((f = e == null ? void 0 : e.target) == null ? void 0 : f.closest(".k-animation-container")) === null, d = (p == null ? void 0 : p.contains(e == null ? void 0 : e.target)) || !1;
    if (r) {
      if (X) {
        const u = {
          target: E.current,
          event: e,
          state: n,
          isAnchorClicked: d
        };
        X.call(void 0, u);
      }
      window == null || window.removeEventListener("mousedown", J);
    }
  }, ae = (e) => {
    if (!y) {
      const r = S && S.uPopup;
      e.classList.remove(
        ...D(A.animationContainerShown({ c: r })).split(" ").filter((d) => d)
      );
    }
    Z();
  }, Q = () => {
    n.current === "hiding" && (n.previous === "shown" || n.previous === "reposition") && U({ ...n, current: "hidden", previous: n.current }), W && W.call(void 0, { target: E.current });
  }, pe = () => {
    const e = ne;
    let r = 0, d = 0;
    return e && (e === !0 ? r = d = 300 : (r = e.openDuration || 0, d = e.closeDuration || 0)), { enter: r, exit: d };
  }, fe = (e) => {
    Z(), O.current = De.scrollableParents(p || e), O.current && O.current.map((r) => r.addEventListener("scroll", K)), window.addEventListener("resize", K);
  }, Z = () => {
    O.current && (O.current.map((e) => e.removeEventListener("scroll", K)), O.current = void 0), window.removeEventListener("resize", K);
  }, K = Ae(() => {
    n.current !== "hidden" && n.current !== "hiding" && U({ ...o, current: "reposition", previous: n.current });
  }, Te), de = () => Y ? Y + Ie : ze, Y = Oe() || 0, _ = i.useRef(), O = i.useRef(), c = i.useRef(null), E = i.useRef(null), $ = i.useRef({}), j = i.useRef(!1);
  i.useImperativeHandle(E, () => ({
    element: c.current,
    setPosition: k,
    props: l
  })), i.useImperativeHandle(a, () => E.current);
  const n = i.useMemo(() => {
    const e = {
      ...o,
      props: {
        show: y,
        anchor: p,
        anchorAlign: h,
        appendTo: P,
        collision: m,
        popupAlign: v,
        className: I,
        popupClass: M,
        style: L,
        offset: N,
        contentKey: z
      }
    };
    return y ? o.current === "hidden" || o.current === "hiding" ? { ...e, current: "showing", previous: o.current } : o.current === "showing" ? { ...e, current: "shown", previous: o.current } : o.current === "shown" && (!b(N, o.props.offset) || !b(h, o.props.anchorAlign) || !b(P, o.props.appendTo) || !b(m, o.props.collision) || !b(v, o.props.popupAlign) || !b(L, o.props.style) || p !== o.props.anchor || M !== o.props.popupClass || I !== o.props.className) ? { ...e, current: "reposition", previous: o.current } : e : o.current === "hiding" || o.current === "hidden" ? { ...e, current: "hidden", previous: o.current } : { ...e, current: "hiding", previous: o.current };
  }, [
    y,
    p,
    h,
    P,
    m,
    v,
    I,
    M,
    L,
    N,
    z,
    o
  ]);
  i.useEffect(() => {
    n.current === "hiding" && !j.current && c.current ? (j.current = !0, ae(c.current), G(c.current.firstChild, "exit", Q)) : (j.current = !1, n.current === "showing" && c.current ? B(c.current) : n.current === "hiding" && c.current ? Q() : n.current === "reposition" && n.previous === "shown" ? setTimeout(() => {
      U({ ...n, current: "shown", previous: n.current });
    }, 0) : n.current === "shown" && $.current.contentKey !== z && c.current && k(c.current)), n.current === "reposition" && (n.previous === "shown" || n.previous === "showing") && c.current && k(c.current), $.current = { contentKey: z };
  }, [n]), i.useEffect(() => (n.current === "showing" && c.current && B(c.current), () => {
    Z();
  }), []);
  const ee = P || (Ee ? p && p.ownerDocument ? p.ownerDocument.body : document.body : void 0), me = Object.assign(
    {},
    { position: H, top: 0, left: -1e4 },
    L || {}
  ), he = n.current === "hiding";
  if ((y || he) && ee) {
    const e = de(), r = /* @__PURE__ */ i.createElement(be.Provider, { value: e }, /* @__PURE__ */ i.createElement(
      "div",
      {
        onKeyDown: ie,
        className: D(A.animationContainer({ c: C }), I),
        id: se,
        ref: c,
        style: {
          zIndex: e,
          ...me
        }
      },
      /* @__PURE__ */ i.createElement(
        "div",
        {
          className: D(A.animationChild({ c: C })),
          style: { transitionDelay: "0ms" }
        },
        /* @__PURE__ */ i.createElement("div", { role: re, className: D(A.popup({ c: C }), M) }, ce)
      )
    ));
    return P !== null ? we.createPortal(r, ee) : r;
  }
  return null;
}), g = {
  collision: {
    horizontal: w.fit,
    vertical: w.flip
  },
  anchorAlign: {
    horizontal: s.left,
    vertical: s.bottom
  },
  popupAlign: {
    horizontal: s.left,
    vertical: s.top
  },
  offset: Me,
  animate: !0,
  show: !1,
  margin: {
    horizontal: 0,
    vertical: 0
  },
  positionMode: "absolute"
};
te.displayName = "Popup";
te.propTypes = {
  anchor: function(l) {
    const a = l.anchor;
    return a && typeof a.nodeType != "number" ? new Error("Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  appendTo: function(l) {
    const a = l.appendTo;
    return a && typeof a.nodeType != "number" ? new Error("Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  className: t.oneOfType([t.string, t.arrayOf(t.string.isRequired)]),
  id: t.string,
  popupClass: t.oneOfType([t.string, t.arrayOf(t.string), t.object]),
  collision: t.shape({
    horizontal: t.oneOf([w.fit, w.flip, w.none]),
    vertical: t.oneOf([w.fit, w.flip, w.none])
  }),
  anchorAlign: t.shape({
    horizontal: t.oneOf([s.left, s.center, s.right]),
    vertical: t.oneOf([s.top, s.center, s.bottom])
  }),
  popupAlign: t.shape({
    horizontal: t.oneOf([s.left, s.center, s.right]),
    vertical: t.oneOf([s.top, s.center, s.bottom])
  }),
  offset: t.shape({
    left: t.number,
    top: t.number
  }),
  children: t.oneOfType([t.element, t.node]),
  show: t.bool,
  animate: t.oneOfType([
    t.bool,
    t.shape({
      openDuration: t.number,
      closeDuration: t.number
    })
  ]),
  margin: t.shape({
    horizontal: t.number,
    vertical: t.number
  }),
  positionMode: t.oneOf(["fixed", "absolute"]),
  scale: t.number,
  style: t.object,
  onClose: t.func,
  onPosition: t.func,
  onOpen: t.func,
  onKeyDown: t.func,
  onMouseDownOutside: t.func
};
export {
  te as Popup,
  Ne as PopupPropsContext,
  g as popupDefaultProps
};
