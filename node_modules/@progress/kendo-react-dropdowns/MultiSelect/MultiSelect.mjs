/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as f from "react";
import m from "prop-types";
import { Keys as u, classNames as y, IconWrap as R, validatePackage as X, canUseDOM as L, createPropsContext as Z, withIdHOC as tt, withPropsContext as et, kendoThemeMaps as st } from "@progress/kendo-react-common";
import { plusIcon as it } from "@progress/kendo-svg-icons";
import { FloatingLabel as ot } from "@progress/kendo-react-labels";
import at from "../common/ListContainer.mjs";
import nt from "../common/List.mjs";
import lt from "../common/GroupStickyHeader.mjs";
import dt from "./TagList.mjs";
import rt from "../common/SearchBar.mjs";
import F from "../common/DropDownBase.mjs";
import { ActiveDescendant as k } from "../common/settings.mjs";
import { getFilteredData as I, areSame as E, removeDataItems as w, isPresent as M, getItemValue as O, preventDefaultNonInputs as ht, matchTags as B, itemIndexStartsWith as pt } from "../common/utils.mjs";
import { packageMetadata as ct } from "../package-metadata.mjs";
import ut from "../common/ClearButton.mjs";
import { AdaptiveMode as ft } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as gt } from "@progress/kendo-react-layout";
import { MOBILE_MEDIUM_DEVISE as mt } from "../common/constants.mjs";
import { provideLocalizationService as vt } from "@progress/kendo-react-intl";
import { adaptiveModeFooterCancel as z, messages as V, adaptiveModeFooterApply as H } from "../messages/index.mjs";
import It from "../common/ListFilter.mjs";
import A from "../common/withCustomComponent.mjs";
const { sizeMap: D, roundedMap: yt } = st, bt = "Please enter a valid value!", $ = (T) => T.preventDefault(), q = (T) => T === 2, b = class b extends f.Component {
  constructor(n) {
    super(n), this.state = {
      activedescendant: k.PopupList,
      currentValue: []
    }, this._element = null, this._valueItemsDuringOnChange = null, this.base = new F(this), this._tags = [], this._input = null, this._adaptiveInput = null, this._skipFocusEvent = !1, this._lastSelectedOrDeslectedItemIndex = null, this.itemHeight = 0, this.scrollToFocused = !1, this.localization = null, this.focus = () => {
      this._input && this._input.focus();
    }, this.handleItemSelect = (e, t) => {
      const { dataItemKey: o, virtual: s } = this.props, a = I(this.props), p = s ? s.skip : 0, c = a[e - p], r = this.value.findIndex((g) => E(g, c, o));
      this._lastSelectedOrDeslectedItemIndex = a.findIndex((g) => E(g, c, o));
      let i = [];
      r !== -1 ? (i = this.value, i.splice(r, 1)) : i = [...this.value, c], (this.props.filter !== void 0 ? this.props.filter : this.state.text) && !this.mobileMode && (this.state.text && (t.data.text = ""), this.base.filterChanged("", t)), this._adaptiveInput && this._adaptiveInput.blur(), this.state.focusedIndex !== void 0 && (t.data.focusedIndex = void 0), this.triggerOnChange(i, t), this.base.triggerPageChangeCornerItems(c, t);
    }, this.onTagDelete = (e, t) => {
      const o = this.base.initState();
      o.syntheticEvent = t, this.opened && this.base.togglePopup(o), !this.state.focused && !this.mobileMode && (o.data.focused = !0, this.focus());
      const s = this.value;
      w(s, e, this.props.dataItemKey), this.triggerOnChange(s, o), this.applyState(o);
    }, this.itemFocus = (e, t) => {
      const { allowCustom: o, virtual: s } = this.props, a = I(this.props), p = s ? s.skip : 0, c = this.props.filter !== void 0 ? this.props.filter : this.state.text, { focusedIndex: r } = this.getFocusedState(), i = o && c, d = a[e - p];
      d && r !== e ? this.state.focusedIndex !== e && (t.data.focusedIndex = e, t.data.activedescendant = k.PopupList) : i && e === -1 && this.state.focusedIndex !== void 0 && (t.data.focusedIndex = void 0), this.base.triggerPageChangeCornerItems(d, t);
    }, this.componentRef = (e) => {
      this._element = e, this.base.wrapper = e;
    }, this.searchbarRef = (e) => {
      const t = this._input = e && e.input;
      t && this.state.focused && window.setTimeout(() => t.focus(), 0);
    }, this.onChangeHandler = (e) => {
      const t = this.base.initState(), o = e.target.value;
      t.syntheticEvent = e, this.props.filter === void 0 && (t.data.text = o), t.data.focusedIndex = void 0, this.opened || (this.base.togglePopup(t), this.setState({ currentValue: this.value })), this.base.filterChanged(o, t), this.applyState(t), this.setState({ group: void 0 });
    }, this.clearButtonClick = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.value.length > 0 && this.triggerOnChange([], t), this.state.focusedIndex !== void 0 && (t.data.focusedIndex = void 0), this.opened && this.base.togglePopup(t);
      const o = this.props.filter !== void 0 ? this.props.filter : this.state.text;
      M(o) && o !== "" && this.base.filterChanged("", t), this.state.text && (t.data.text = ""), this._lastSelectedOrDeslectedItemIndex = null, this.applyState(t);
    }, this.onInputKeyDown = (e) => {
      const { textField: t, groupField: o } = this.props, s = I(this.props), a = e.keyCode, p = this.props.filter !== void 0 ? this.props.filter : this.state.text, c = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { focusedItem: r, focusedIndex: i } = this.getFocusedState(), d = this.base.initState();
      if (d.syntheticEvent = e, !p && this.value.length > 0 && (a === u.left || a === u.right || a === u.home || a === u.end || a === u.delete || a === u.backspace) && !e.shiftKey)
        return this.onTagsNavigate(e, d);
      const g = () => {
        e.preventDefault(), this.base.togglePopup(d), this.applyState(d);
      };
      if (this.opened)
        if (a === u.pageUp)
          e.preventDefault(), this.base.scrollPopupByPageSize(-1);
        else if (a === u.pageDown)
          e.preventDefault(), this.base.scrollPopupByPageSize(1);
        else if ((e.ctrlKey || e.metaKey) && e.code === "KeyA") {
          const h = (this.state.value && this.state.value.length) === s.length ? [] : s;
          this.updateStateOnKeyboardNavigation(h, d);
        } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.keyCode === u.end) {
          const l = s.slice(this.getFocusedState().focusedIndex);
          this.itemFocus(s.length - 1, d), this.updateStateOnKeyboardNavigation(l, d);
        } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.keyCode === u.home) {
          const l = s.slice(0, this.getFocusedState().focusedIndex + 1);
          this.itemFocus(0, d), this.updateStateOnKeyboardNavigation(l, d);
        } else if (e.shiftKey && e.keyCode === u.up) {
          let l;
          const h = this.getLastSelectedOrDeselectedIndex(1, i);
          h === null ? l = i !== 0 ? s.slice(i - 1, i) : [s[i]] : h === i ? l = [s[h - 1]] : i >= 0 && (l = h > i ? s.slice(i - 1, h) : s.slice(h - 1, i)), l && l.length > 0 && (i >= 1 && this.itemFocus(i - 1, d), this.updateStateOnKeyboardNavigation(l, d));
        } else if (e.shiftKey && e.keyCode === u.down) {
          let l;
          const h = this.getLastSelectedOrDeselectedIndex(0, i);
          h === null ? l = i !== s.length - 1 ? s.slice(i, i + 1) : [s[i]] : h === i ? l = s.slice(i, i + 2) : i >= 0 && (l = h > i ? s.slice(i + 1, h + 1) : s.slice(h, i + 2)), l && l.length >= 1 && (this.itemFocus(i + 1, d), this.updateStateOnKeyboardNavigation(l, d));
        } else if (e.altKey && a === u.up)
          g();
        else if (a === u.up || a === u.down) {
          if (o !== "" && t)
            if (!this.props.skipDisabledItems && c)
              this.onNavigate(d, a);
            else {
              let l = 0;
              if (a === u.down || a === u.right) {
                const h = s.slice(i + 1).find((v) => !v.disabled && v[t]);
                l = h && s.findIndex((v) => v[t] === h[t]);
              } else if (a === u.up || a === u.left) {
                let h;
                if (i === -1)
                  h = s, l = s.findIndex((v) => !v.disabled && v[t]);
                else {
                  h = s.slice(0, i);
                  let v = h.pop();
                  for (; v && v.disabled; )
                    v = h.pop();
                  l = v && s.findIndex((S) => S[t] === v[t]);
                }
              }
              if (l) {
                const h = l - i;
                this.onNavigate(d, a, h);
              } else
                l !== void 0 && this.onNavigate(d, a);
            }
          else if (!this.props.skipDisabledItems && c)
            this.onNavigate(d, a);
          else {
            let l = null;
            if (a === u.down || a === u.right)
              l = s.slice(i + 1).find((h) => !h.disabled);
            else if (a === u.up || a === u.left) {
              const h = s.slice(0, i);
              for (l = h.pop(); l && l.disabled; )
                l = h.pop();
            }
            if (l) {
              const h = l.id - i - 1;
              this.onNavigate(d, a, h);
            } else
              this.onNavigate(d, a);
          }
          this.applyState(d), e.preventDefault();
        } else
          a === u.enter ? (e.preventDefault(), this.props.allowCustom && p && r === null ? this.customItemSelect(e) : r && r.disabled ? g() : this.selectFocusedItem(e)) : a === u.esc && g();
      else
        e.altKey && a === u.down ? g() : a === u.esc && this.clearButtonClick(e);
    }, this.listContainerContent = () => {
      const { header: e, footer: t, allowCustom: o, size: s, groupStickyHeaderItemRender: a, groupField: p, list: c } = this.props, r = I(this.props), i = this.props.filter !== void 0 ? this.props.filter : this.state.text, { focusedType: d } = this.getFocusedState(), g = o && i && /* @__PURE__ */ f.createElement(
        "div",
        {
          className: y("k-list", {
            [`k-list-${D[s] || s}`]: s
          }),
          key: "customitem",
          onClick: this.customItemSelect,
          onMouseDown: $
        },
        /* @__PURE__ */ f.createElement(
          "div",
          {
            className: y("k-list-item k-custom-item", { "k-focus": q(d) }),
            style: { fontStyle: "italic" }
          },
          i,
          /* @__PURE__ */ f.createElement(R, { name: "plus", icon: it, style: { position: "absolute", right: "0.5em" } })
        )
      );
      let { group: l } = this.state;
      return l === void 0 && p !== void 0 && (l = O(r[0], p)), /* @__PURE__ */ f.createElement(f.Fragment, null, e && /* @__PURE__ */ f.createElement("div", { className: "k-list-header" }, e), g, /* @__PURE__ */ f.createElement(
        "div",
        {
          className: y("k-list", {
            [`k-list-${this.mobileMode ? "lg" : D[s] || s}`]: s,
            "k-virtual-list": this.base.vs.enabled
          })
        },
        !c && l && r.length !== 0 && /* @__PURE__ */ f.createElement(lt, { group: l, groupMode: "modern", render: a }),
        this.renderList()
      ), t && /* @__PURE__ */ f.createElement("div", { className: "k-list-footer" }, t));
    }, this.renderListContainer = () => {
      const e = this.base, { dir: t } = this.props, o = I(this.props), s = this.base.getPopupSettings(), a = s.width !== void 0 ? s.width : e.popupWidth, p = {
        dir: t !== void 0 ? t : e.dirCalculated,
        width: a,
        popupSettings: {
          ...s,
          popupClass: y(s.popupClass, "k-list-container", "k-multiselect-popup"),
          anchor: s.anchor || this.element,
          show: this.opened,
          onOpen: this.onPopupOpened,
          onClose: this.onPopupClosed
        },
        itemsCount: [o.length, this.value.length]
      };
      return /* @__PURE__ */ f.createElement(at, { ...p }, this.listContainerContent());
    }, this.renderAdaptiveListContainer = () => {
      const { adaptiveTitle: e, filterable: t, filter: o } = this.props, { windowWidth: s = 0 } = this.state, a = o !== void 0 ? o : this.state.text;
      this.localization = vt(this);
      const p = t ? /* @__PURE__ */ f.createElement(
        It,
        {
          value: a,
          ref: (r) => this._adaptiveInput = r && r.element,
          onChange: this.onChangeHandler,
          onKeyDown: this.onInputKeyDown,
          size: this.props.size,
          rounded: this.props.rounded,
          fillMode: this.props.fillMode
        }
      ) : null, c = {
        adaptiveTitle: e,
        expand: this.opened,
        onClose: (r) => this.onCancel(r),
        windowWidth: s,
        mobileFilter: p,
        footer: {
          cancelText: this.localization.toLanguageString(
            z,
            V[z]
          ),
          onCancel: this.onCancel,
          applyText: this.localization.toLanguageString(
            H,
            V[H]
          ),
          onApply: this.closePopup
        }
      };
      return /* @__PURE__ */ f.createElement(ft, { ...c }, /* @__PURE__ */ f.createElement(gt, { overflowHidden: !0 }, /* @__PURE__ */ f.createElement("div", { className: "k-list-container" }, this.listContainerContent())));
    }, this.closePopup = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.state.focusedIndex !== void 0 && (t.data.focusedIndex = void 0), this.opened && this.base.togglePopup(t), t.events.push({ type: "onClose" });
      const o = this.props.filter !== void 0 ? this.props.filter : this.state.text;
      M(o) && o !== "" && this.base.filterChanged("", t), this.state.text && (t.data.text = ""), this.applyState(t);
    }, this.onCancel = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.state.focusedIndex !== void 0 && (t.data.focusedIndex = void 0), this.opened && this.base.togglePopup(t), t.events.push({ type: "onCancel" });
      const o = this.props.filter !== void 0 ? this.props.filter : this.state.text;
      M(o) && o !== "" && this.base.filterChanged("", t), this.state.text && (t.data.text = ""), this.applyState(t);
    }, this.renderList = () => {
      const {
        textField: e,
        listNoDataRender: t,
        itemRender: o,
        groupHeaderItemRender: s,
        dataItemKey: a,
        virtual: p = { skip: 0, total: void 0 }
      } = this.props, c = I(this.props), r = this.base.vs, { focusedIndex: i } = this.getFocusedState(), d = this.base.getPopupSettings(), g = `translateY(${r.translate}px)`;
      return /* @__PURE__ */ f.createElement(
        nt,
        {
          id: this.base.listBoxId,
          show: this.opened,
          data: c.slice(),
          focusedIndex: i - p.skip,
          value: this.value,
          textField: e,
          valueField: a,
          optionsGuid: this.base.guid,
          groupField: this.props.groupField,
          groupMode: "modern",
          listRef: (l) => {
            r.list = this.base.list = l;
          },
          wrapperStyle: this.mobileMode ? {} : { maxHeight: d.height },
          wrapperCssClass: "k-list-content",
          listStyle: r.enabled ? { transform: g } : void 0,
          key: "listKey",
          skip: p.skip,
          onClick: this.handleItemClick,
          itemRender: o,
          groupHeaderItemRender: s,
          noDataRender: t,
          onMouseDown: $,
          onBlur: this.handleBlur,
          onScroll: this.onScroll,
          wrapperRef: r.scrollerRef,
          scroller: this.base.renderScrollElement(),
          ariaSetSize: p.total
        }
      );
    }, this.onScroll = (e) => {
      const { vs: t, list: o } = this.base;
      t.scrollHandler(e);
      const { groupField: s } = this.props;
      let a = I(this.props);
      if (!(!s || !a.length) && s) {
        const p = this.itemHeight = this.itemHeight || (t.enabled ? t.itemHeight : o ? o.children[0].offsetHeight : 0), r = e.target.scrollTop - t.skip * p;
        a = this.base.getGroupedDataModernMode(a, s);
        let i = a[0][s];
        for (let d = 1; d < a.length && !(p * d > r); d++)
          a[d] && a[d][s] && (i = a[d][s]);
        i !== this.state.group && this.setState({
          group: i
        });
      }
    }, this.customItemSelect = (e) => {
      const t = this.props.filter !== void 0 ? this.props.filter : this.state.text, { textField: o } = this.props;
      if (!t)
        return;
      const s = this.base.initState();
      s.syntheticEvent = e;
      const a = o ? { [o]: t } : t;
      this.state.text !== void 0 && (s.data.text = ""), s.data.focusedIndex = void 0, this.base.filterChanged("", s);
      const p = [...this.value, a];
      this.triggerOnChange(p, s), this.base.togglePopup(s), this.applyState(s);
    }, this.handleWrapperClick = (e) => {
      const t = this._input;
      !this.opened && t && this.focusElement(t);
      const o = this.base.initState();
      o.syntheticEvent = e, !this.state.focused && !this.mobileMode && (o.events.push({ type: "onFocus" }), o.data.focused = !0), this.mobileMode && (this.setState({ currentValue: this.tagsToRender }), this.mobileMode && window.setTimeout(() => this._adaptiveInput && this._adaptiveInput.focus(), 300)), this.base.togglePopup(o), this.applyState(o);
    }, this.handleItemClick = (e, t) => {
      const o = this.base.initState();
      o.syntheticEvent = t, this.handleItemSelect(e, o), this.props.autoClose && !this.mobileMode && this.base.togglePopup(o), t.stopPropagation(), this.applyState(o);
    }, this.handleBlur = (e) => {
      if (!this.state.focused || this._skipFocusEvent)
        return;
      const t = this.base.initState(), { allowCustom: o, filterable: s } = this.props;
      t.syntheticEvent = e, t.data.focused = !1, t.events.push({ type: "onBlur" }), this.opened && !this.mobileMode && (this.state.opened && (t.data.opened = !1), t.events.push({ type: "onClose" })), !o && !s && this.state.text && (t.data.text = ""), this.applyState(t);
    }, this.handleFocus = (e) => {
      this._skipFocusEvent || this.base.handleFocus(e);
    }, this.onPopupOpened = () => {
      this._input && this.state.focused && !this.mobileMode && this.focusElement(this._input);
    }, this.onPopupClosed = () => {
      this.state.focused && window.setTimeout(() => {
        this.state.focused && this.focusElement(this._input);
      }, 0);
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || bt
      );
    }, X(ct);
  }
  get _inputId() {
    return this.props.id;
  }
  get document() {
    if (L)
      return this.element && this.element.ownerDocument || document;
  }
  /** @hidden */
  get element() {
    return this._element;
  }
  /** @hidden */
  get opened() {
    return !!(this.props.opened !== void 0 ? this.props.opened : this.state.opened);
  }
  /** @hidden */
  get tagsToRender() {
    const { tags: n, textField: e } = this.props, t = [];
    return n === void 0 ? this.value.forEach((o) => {
      t.push({ text: O(o, e), data: [o] });
    }) : t.push(...n), t;
  }
  /**
   * The mobile mode of the ComboBox.
   */
  get mobileMode() {
    return !!(this.state.windowWidth && this.state.windowWidth <= mt && this.props.adaptive);
  }
  /**
   * Represents the value of the MultiSelect.
   */
  get value() {
    const n = [];
    return this._valueItemsDuringOnChange ? n.push(...this._valueItemsDuringOnChange) : this.props.value ? n.push(...this.props.value) : this.state.value ? n.push(...this.state.value) : this.props.defaultValue && n.push(...this.props.defaultValue), n;
  }
  /**
   * Gets the `name` property of the MultiSelect.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the MultiSelect is set.
   */
  get validity() {
    const n = this.props.validationMessage !== void 0, e = !this.required || this.value !== null && this.value.length > 0 && this.value !== void 0, t = this.props.valid !== void 0 ? this.props.valid : e;
    return {
      customError: n,
      valid: t,
      valueMissing: this.value === null
    };
  }
  /** @hidden */
  get required() {
    return this.props.required !== void 0 ? this.props.required : b.defaultProps.required;
  }
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : b.defaultProps.validityStyles;
  }
  /** @hidden */
  componentDidUpdate(n, e) {
    var g;
    const { virtual: t, groupField: o = "" } = this.props, s = I(this.props), a = t ? t.skip : 0, p = n.virtual ? n.virtual.total : 0, c = n.opened !== void 0 ? n.opened : e.opened, r = !c && this.opened, i = c && !this.opened, d = this.base.getPopupSettings();
    if (this.base.didUpdate(), !d.animate && i && this.onPopupClosed(), t && t.total !== p)
      this.base.vs.calcScrollElementHeight(), this.base.vs.reset();
    else {
      let { focusedItem: l, focusedIndex: h } = this.getFocusedState();
      o !== "" && (h = (g = this.base.getGroupedDataModernMode(s, o)) == null ? void 0 : g.indexOf(l)), r && t ? this.base.scrollToVirtualItem(t, h - a) : r && !t ? (s && s.length !== 0 && this.base.resetGroupStickyHeader(s[0][o], this), this.base.scrollToItem(h)) : this.opened && c && l && this.scrollToFocused && this.base.scrollToItem(h - a);
    }
    this.scrollToFocused = !1, this.setValidity();
  }
  /** @hidden */
  componentDidMount() {
    var n;
    this.observerResize = L && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.base.didMount(), this.setValidity(), (n = this.document) != null && n.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /** @hidden */
  componentWillUnmount() {
    var n;
    (n = this.document) != null && n.body && this.observerResize && this.observerResize.disconnect();
  }
  /** @hidden */
  onNavigate(n, e, t) {
    const { allowCustom: o } = this.props, s = I(this.props), a = this.props.filter !== void 0 ? this.props.filter : this.state.text, { focusedType: p, focusedIndex: c } = this.getFocusedState(), r = o && a, i = q(p), d = this.base, g = d.vs;
    if (this.opened && e === u.up && i)
      this.state.focusedIndex !== void 0 && (n.data.focusedIndex = void 0);
    else {
      const l = d.navigation.navigate({
        keyCode: e,
        current: c,
        max: (g.enabled ? g.total : s.length) - 1,
        min: r ? -1 : 0,
        skipItems: t || void 0
      });
      l !== void 0 && (this.itemFocus(l, n), this.scrollToFocused = !0);
    }
    this.applyState(n);
  }
  /** @hidden */
  render() {
    const {
      style: n,
      className: e,
      label: t,
      dir: o,
      disabled: s,
      textField: a,
      dataItemKey: p,
      virtual: c,
      size: r,
      rounded: i,
      fillMode: d,
      loading: g,
      filter: l
    } = this.props, { text: h, focused: v, focusedTag: S, currentValue: W } = this.state, C = this.base.vs, _ = this.props.id || this._inputId;
    C.enabled = c !== void 0, c !== void 0 && (C.skip = c.skip, C.total = c.total, C.pageSize = c.pageSize);
    const x = this.mobileMode && this.opened ? W : this.tagsToRender;
    this.setItems(this.tagsToRender, this._tags);
    const K = !this.validityStyles || this.validity.valid, G = !!(l !== void 0 ? l : h) || x && x.length > 0, [U, Y] = A(this.props.prefix || f.Fragment), [j, J] = A(this.props.suffix || f.Fragment), N = /* @__PURE__ */ f.createElement(f.Fragment, null, /* @__PURE__ */ f.createElement(
      "div",
      {
        ref: this.componentRef,
        className: y("k-multiselect k-input", e, {
          [`k-input-${D[r] || r}`]: r,
          [`k-rounded-${yt[i] || i}`]: i,
          [`k-input-${d}`]: d,
          "k-focus": v && !s,
          "k-invalid": !K,
          "k-disabled": s,
          "k-loading": g,
          "k-required": this.required
        }),
        style: t ? { ...n, width: void 0 } : n,
        dir: o,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onClick: this.handleWrapperClick,
        onMouseDown: ht
      },
      this.props.prefix && /* @__PURE__ */ f.createElement(U, { ...Y }),
      /* @__PURE__ */ f.createElement("div", { className: y("k-input-values") }, /* @__PURE__ */ f.createElement(
        "div",
        {
          className: y("k-chip-list", { [`k-chip-list-${D[r] || r}`]: r }),
          role: "listbox",
          id: "tagslist-" + this.base.guid
        },
        x && x.length > 0 && /* @__PURE__ */ f.createElement(
          dt,
          {
            tagRender: this.props.tagRender,
            onTagDelete: this.onTagDelete,
            data: x,
            guid: this.base.guid,
            focused: S ? x.find((Q) => B(Q, S, p)) : void 0,
            size: r
          }
        )
      ), this.renderSearchBar(_)),
      g && /* @__PURE__ */ f.createElement(R, { className: "k-input-loading-icon", name: "loading" }),
      this.props.suffix && /* @__PURE__ */ f.createElement(j, { ...J }),
      G && /* @__PURE__ */ f.createElement(ut, { onClick: this.clearButtonClick }),
      !this.mobileMode && this.renderListContainer()
    ), this.mobileMode && this.renderAdaptiveListContainer());
    return t ? /* @__PURE__ */ f.createElement(
      ot,
      {
        label: t,
        editorId: _,
        editorValue: h || O(this.value[0], a),
        editorValid: K,
        editorDisabled: s,
        style: { width: n ? n.width : void 0 },
        children: N
      }
    ) : N;
  }
  renderSearchBar(n) {
    const { activedescendant: e, focusedTag: t, currentValue: o } = this.state, { disabled: s, placeholder: a, ariaDescribedBy: p, ariaLabelledBy: c, ariaLabel: r } = this.props, i = !this.mobileMode && (this.props.filter !== void 0 ? this.props.filter : this.state.text) || "", { focusedIndex: d } = this.getFocusedState(), g = this.value.length === 0 && !i ? a : void 0, l = o && o.length > 0 ? void 0 : a, h = e === k.TagsList && t !== void 0 ? `tag-${this.base.guid}-${t.text.replace(/\s+/g, "-")}` : `option-${this.base.guid}-${d}`, v = {
      accessKey: this.props.accessKey,
      tabIndex: this.props.tabIndex
    };
    return /* @__PURE__ */ f.createElement(
      rt,
      {
        id: n,
        size: Math.max((g || "").length, i.length, 1),
        placeholder: this.mobileMode && this.opened ? l : g,
        value: i,
        onChange: this.onChangeHandler,
        onKeyDown: this.onInputKeyDown,
        ref: this.searchbarRef,
        disabled: s,
        expanded: this.opened,
        owns: this.base.listBoxId,
        role: "combobox",
        activedescendant: h,
        ariaDescribedBy: `tagslist-${this.base.guid}${p ? " " + p : ""}`,
        ariaLabelledBy: c,
        ariaRequired: this.required,
        ariaLabel: r,
        ...v
      }
    );
  }
  onTagsNavigate(n, e) {
    const t = n.keyCode, { focusedTag: o } = this.state, s = this._tags, a = this.props.dataItemKey;
    let p = o ? s.findIndex((i) => B(i, o, a)) : -1, c;
    const r = p !== -1;
    if (t === u.left)
      r ? p = Math.max(0, p - 1) : p = s.length - 1, c = s[p];
    else if (t === u.right)
      p === s.length - 1 ? c = void 0 : r && (p = Math.min(s.length - 1, p + 1), c = s[p]);
    else if (t === u.home && !n.shiftKey)
      c = s[0];
    else if (t === u.end && !n.shiftKey)
      c = s[s.length - 1];
    else if (t === u.delete) {
      if (r) {
        const i = this.value;
        w(i, s[p].data, a), this.triggerOnChange(i, e);
      }
    } else if (t === u.backspace) {
      const i = this.value;
      if (r)
        w(i, s[p].data, a), this.triggerOnChange(i, e);
      else if (!r && s.length) {
        const d = s.pop();
        w(i, d.data, a), this.triggerOnChange(i, e);
      }
    }
    c !== o && (e.data.focusedTag = c, e.data.activedescendant = k.TagsList), this.applyState(e);
  }
  triggerOnChange(n, e) {
    this.props.value === void 0 && (e.data.value = [...n]), this._valueItemsDuringOnChange = [], this.setItems(n, this._valueItemsDuringOnChange), e.events.push({ type: "onChange" });
  }
  selectFocusedItem(n, e) {
    const { virtual: t } = this.props, o = I(this.props), { focusedIndex: s } = e || this.getFocusedState(), a = t ? t.skip : 0;
    o[s - a] !== void 0 && this.handleItemClick(s, n);
  }
  setItems(n, e) {
    e.length = 0, e.push(...n);
  }
  getFocusedState() {
    const { focusedIndex: n } = this.state, e = this.props.filter !== void 0 ? this.props.filter : this.state.text, {
      allowCustom: t,
      dataItemKey: o,
      virtual: s,
      textField: a,
      focusedItemIndex: p = pt,
      skipDisabledItems: c
    } = this.props, r = I(this.props), i = s && s.skip || 0;
    let d;
    if (n !== void 0)
      return {
        focusedIndex: n,
        focusedItem: r[n - i],
        focusedType: 1
        /* ListItem */
      };
    const g = this.value;
    if (t && e)
      return {
        focusedItem: null,
        focusedIndex: -1,
        focusedType: 2
        /* CustomItem */
      };
    if (e)
      return d = p(r, e, a), {
        focusedItem: r[d],
        focusedIndex: d + i,
        focusedType: 1
        /* ListItem */
      };
    if (g.length) {
      const l = g[g.length - 1];
      return d = r.findIndex((h) => E(h, l, o)), r[d] !== void 0 ? {
        focusedIndex: d + i,
        focusedItem: r[d],
        focusedType: 1
        /* ListItem */
      } : { focusedType: 0, focusedIndex: -1 };
    } else if (c && a && !e && i === 0) {
      const l = r.findIndex((h) => !h.disabled && h[a]);
      return {
        focusedIndex: l,
        focusedItem: r[l - i],
        focusedType: 1
        /* ListItem */
      };
    }
    return i === 0 ? {
      focusedItem: r[0],
      focusedIndex: 0,
      focusedType: 1
      /* ListItem */
    } : { focusedType: 0, focusedIndex: -1 };
  }
  focusElement(n) {
    this._skipFocusEvent = !0, n.focus(), window.setTimeout(() => this._skipFocusEvent = !1, 0);
  }
  applyState(n) {
    this.base.applyState(n), this._valueItemsDuringOnChange = null;
  }
  calculateMedia(n) {
    for (const e of n)
      this.setState({ windowWidth: e.target.clientWidth });
  }
  /**
   * Updates the state of the MultiSelect when the complex keyboard navigation that
   * includes key combinations with the Ctrl/Command, Shift, Home and End keys
   *
   * @param {Array<string | Object>} dataToSet Defines the array of new values that will be applied to the MultiSelect
   * @param {MultiSelectInternalState} state The current state of the MultiSelect
   */
  updateStateOnKeyboardNavigation(n, e) {
    this.setState({ value: n }), this.triggerOnChange(n, e), this.applyState(e);
  }
  /**
   * Returns the last element that was selected or deselected. Needed for the keyboard navigation specifications
   *
   * @param {number} correction A correction is needed depending on if UP or DOWN key is pressed
   */
  getLastSelectedOrDeselectedIndex(n, e) {
    return this._lastSelectedOrDeslectedItemIndex === null && (this._lastSelectedOrDeslectedItemIndex = e), this._lastSelectedOrDeslectedItemIndex !== null ? this._lastSelectedOrDeslectedItemIndex + n : null;
  }
};
b.displayName = "MultiSelect", b.propTypes = {
  ...F.propTypes,
  autoClose: m.bool,
  value: m.arrayOf(m.any),
  defaultValue: m.arrayOf(m.any),
  dataItemKey: m.string,
  placeholder: m.string,
  tags: m.arrayOf(
    m.shape({
      text: m.string,
      data: m.arrayOf(m.any)
    })
  ),
  tagRender: m.func,
  id: m.string,
  ariaLabelledBy: m.string,
  ariaDescribedBy: m.string,
  groupField: m.string,
  list: m.any,
  adaptive: m.bool,
  adaptiveTitle: m.string,
  onCancel: m.func,
  skipDisabledItems: m.bool
}, b.defaultProps = {
  ...F.defaultProps,
  autoClose: !0,
  required: !1,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  groupMode: "modern",
  skipDisabledItems: !0,
  prefix: void 0,
  suffix: void 0
};
let P = b;
const xt = Z(), St = tt(
  et(
    xt,
    P
  )
);
St.displayName = "KendoReactMultiSelect";
export {
  St as MultiSelect,
  xt as MultiSelectPropsContext,
  P as MultiSelectWithoutContext
};
