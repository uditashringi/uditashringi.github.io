/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
const l = (e) => e != null, d = (e, t) => {
  for (let r = 0; r < e.length; r++)
    if (e.charAt(r) !== t)
      return !1;
  return !0;
}, I = (e, t, r) => {
  let n = e;
  return r && (n = [r].concat(n)), n.slice(t).concat(n.slice(0, t));
}, x = (e, t, r) => {
  if (!l(e))
    return !1;
  let n = String(e);
  return r && (n = n.toLowerCase()), n.indexOf(t) === 0;
}, C = (e, t, r, n, s) => {
  const o = e.offsetHeight, g = t.children.item(r), i = g.offsetTop + (s ? n - e.scrollTop : 0), c = g.offsetHeight;
  if (s) {
    let u = 0;
    i + c > o ? u = i + c - o : i < 0 && (u = i), u !== 0 ? e.scrollTop += u : e.scrollTop === 0 && n !== 0 && (e.scrollTop = n);
  } else
    i + c > o + e.scrollTop ? e.scrollTop = i + c - o : i < e.scrollTop && (e.scrollTop -= e.scrollTop - i);
}, h = (e, t, r) => {
  let n = -1;
  if (t) {
    t = t.toLowerCase();
    for (let s = 0; s < e.length; s++) {
      const o = (f(e[s], r) || "") + "";
      if (o && o.toLowerCase().startsWith(t)) {
        n = s;
        break;
      }
    }
  }
  return n;
}, T = (e, t, r, n = !1) => {
  const s = (o) => n ? o : o.toLowerCase();
  return e.findIndex((o) => r ? s(f(o, r)) === s(t) : s(t) === s(o.toString()));
}, f = (e, t) => {
  if (t && l(e)) {
    const r = t.split(".");
    let n = e;
    return r.forEach((s) => {
      n = n ? n[s] : void 0;
    }), n;
  }
  return e;
}, D = (e, t, r) => {
  if (!e)
    return;
  const n = e.findIndex((s) => f(s, t) === r);
  return e[n];
}, a = (e = [], t = [], r) => {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!p(e[n], t[n], r))
      return !1;
  return !0;
}, w = (e, t, r) => {
  t.forEach((n) => {
    const s = e.findIndex((o) => p(o, n, r));
    s !== -1 && e.splice(s, 1);
  });
}, p = (e, t, r) => e === t || l(e) === l(t) && f(e, r) === f(t, r), L = (e, t, r) => {
  if (t) {
    const n = T(e, t, r, !0);
    return n !== -1 ? e[n] : e[h(e, t, r)];
  }
  return e[0];
}, H = (e, t = [], r) => {
  let n = "";
  if (e) {
    const s = t[h(t, e, r)];
    if (s) {
      const o = f(s, r);
      e.toLowerCase() !== o.toLowerCase() && (n = o.substring(e.length));
    }
  }
  return n;
}, S = (e) => {
  e.target.nodeName !== "INPUT" && e.preventDefault();
}, y = (e, t, r) => !!e != !!t || e.text !== t.text ? !1 : e === t || a(e.data, t.data, r), N = (e) => {
  const t = e.filter(
    (r, n) => e.some((s, o) => s === r && o !== n)
  );
  return Array.from(new Set(t));
}, O = (e) => {
  const { data: t = [], groupField: r } = e;
  return r ? t.filter((n) => r && n[r] !== void 0) : t;
};
export {
  p as areSame,
  D as findByFieldValue,
  O as getFilteredData,
  L as getFocusedItem,
  T as getItemIndexByText,
  f as getItemValue,
  N as getPlainDataDuplicates,
  l as isPresent,
  h as itemIndexStartsWith,
  a as matchDataCollections,
  y as matchTags,
  x as matchText,
  S as preventDefaultNonInputs,
  w as removeDataItems,
  d as sameCharsOnly,
  C as scrollToItem,
  I as shuffleData,
  H as suggestValue
};
