/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as I from "react";
import c from "prop-types";
import T from "../common/SearchBar.mjs";
import N from "../common/ListContainer.mjs";
import L from "../common/List.mjs";
import C from "../common/DropDownBase.mjs";
import H from "../common/GroupStickyHeader.mjs";
import { getFilteredData as y, getItemValue as x, areSame as k, getFocusedItem as O, itemIndexStartsWith as R } from "../common/utils.mjs";
import { Keys as m, validatePackage as q, classNames as w, IconWrap as K, createPropsContext as z, withIdHOC as G, withPropsContext as $, kendoThemeMaps as A } from "@progress/kendo-react-common";
import { FloatingLabel as U } from "@progress/kendo-react-labels";
import { packageMetadata as j } from "../package-metadata.mjs";
import J from "../common/ClearButton.mjs";
import P from "../common/withCustomComponent.mjs";
const Q = "Please enter a valid value!", { sizeMap: B, roundedMap: W } = A, b = class b extends I.Component {
  constructor(a) {
    super(a), this.state = {}, this.base = new C(this), this._element = null, this._suggested = "", this._input = null, this._isScrolling = !1, this.itemHeight = 0, this.focus = () => {
      this._input && this._input.focus();
    }, this.handleItemSelect = (e, o) => {
      const s = y(this.props), t = x(s[e], this.props.textField);
      this.triggerOnChange(t, o);
    }, this.itemFocus = (e, o) => {
      const { textField: s } = this.props, i = y(this.props)[e];
      k(this.state.focusedItem, i, s) || (o.data.focusedItem = i);
    }, this.togglePopup = (e) => {
      this.base.togglePopup(e);
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || Q
      );
    }, this.onScroll = (e) => {
      this._isScrolling = !0;
      const { list: o } = this.base, { groupField: s } = this.props;
      let t = y(this.props);
      if (!s || !t.length)
        return;
      const i = this.itemHeight || (o ? o.children[0].offsetHeight : 0), p = e.target.scrollTop;
      s && (t = this.base.getGroupedDataModernMode(t, s));
      let n = t[0][s];
      for (let d = 1; d < t.length && !(i * d > p); d++)
        t[d] && t[d][s] && (n = t[d][s]);
      n !== this.state.group && this.setState({
        group: n
      });
    }, this.handleItemClick = (e, o) => {
      this.base.handleItemClick(e, o), this._valueDuringOnChange = void 0;
    }, this.onChangeHandler = (e) => {
      const s = this.base.initState(), t = e.currentTarget, i = t.value, r = t.selectionEnd === i.length;
      s.syntheticEvent = e;
      const p = this._suggested, n = this.value, d = n && n.substring(0, n.length - p.length), f = d && d === i, h = d && d.length > i.length, { suggest: g } = this.props, l = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      if (g !== void 0 && g !== !1) {
        f || h || !r ? this._suggested = "" : this.suggestValue(i);
        const u = i + this._suggested, v = { userInput: i, value: this._suggested };
        this.triggerOnChange(u, s, { suggestion: v });
      } else
        this._suggested = "", this.triggerOnChange(i, s);
      (!l && i || l && !i) && this.togglePopup(s), s.data.focusedItem = void 0, this.applyState(s), this.setState({ group: void 0 });
    }, this.clearButtonClick = (e) => {
      const s = this.base.initState(), t = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      s.syntheticEvent = e;
      const i = "";
      this._suggested = "", this.triggerOnChange(i, s), this.state.focusedItem !== void 0 && (s.data.focusedItem = void 0), t && this.togglePopup(s), this.applyState(s);
    }, this.onInputKeyDown = (e) => {
      const { skipDisabledItems: o, groupField: s, textField: t } = this.props, i = y(this.props);
      this._isScrolling && (this._isScrolling = !1);
      const r = this.focusedIndex(), p = i[r], n = e.keyCode, d = e.altKey, f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = this.base.initState();
      h.syntheticEvent = e;
      const g = () => {
        f && e.preventDefault();
      };
      if (d && n === m.down)
        this.setState({
          opened: !0
        });
      else if (d && n === m.up)
        this.setState({
          opened: !1
        });
      else if (f && n === m.pageUp)
        g(), this.base.scrollPopupByPageSize(-1);
      else if (f && n === m.pageDown)
        g(), this.base.scrollPopupByPageSize(1);
      else if (f && (n === m.enter || n === m.esc))
        g(), o === !1 && p && p.disabled ? (f && this.togglePopup(h), this.applyState(h)) : this.applyInputValue(e.currentTarget.value, h, e.keyCode);
      else if (!f && n === m.esc) {
        const l = "";
        this._suggested = "", this.triggerOnChange(l, h), this.state.focusedItem !== void 0 && (h.data.focusedItem = void 0), this.applyState(h);
      } else if (n === m.up || n === m.down) {
        if (s !== "" && t)
          if (!this.props.skipDisabledItems && f)
            this.onNavigate(h, n);
          else {
            let l = 0;
            if (n === m.down || n === m.right) {
              const u = i.slice(r + 1).find((v) => !v.disabled && v[t]);
              l = u && i.findIndex((v) => v[t] === u[t]);
            } else if (n === m.up || n === m.left) {
              let u;
              if (r === -1)
                u = i, l = i.findIndex((v) => !v.disabled && v[t]);
              else {
                u = i.slice(0, r);
                let v = u.pop();
                for (; v && v.disabled; )
                  v = u.pop();
                l = v && i.findIndex((S) => S[t] === v[t]);
              }
            }
            if (l !== void 0) {
              const u = l - r;
              this.onNavigate(h, n, u);
            } else
              l === void 0 && i.findIndex((u) => u[t]) === i.length - 1 && this.onNavigate(h, n);
          }
        else if (!this.props.skipDisabledItems && f)
          this.onNavigate(h, n);
        else {
          let l = null;
          if (n === m.down || n === m.right)
            l = i.slice(r + 1).find((u) => !u.disabled);
          else if (n === m.up || n === m.left) {
            const u = i.slice(0, r);
            for (l = u.pop(); l && l.disabled; )
              l = u.pop();
          }
          if (l) {
            const u = l.id - r - 1;
            this.onNavigate(h, n, u);
          } else
            this.onNavigate(h, n);
        }
        this.applyState(h), g();
      }
    }, this.handleBlur = (e) => {
      if (this.state.focused) {
        const o = this.base.initState();
        o.data.focused = !1, o.events.push({ type: "onBlur" }), o.syntheticEvent = e, this.applyInputValue(e.currentTarget.value, o);
      }
    }, q(j);
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * The value of the AutoComplete.
   */
  get value() {
    return this._valueDuringOnChange !== void 0 ? this._valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value !== void 0 ? this.state.value : this.props.defaultValue !== void 0 ? this.props.defaultValue : "";
  }
  /**
   * Gets the `name` property of the AutoComplete.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the AutoComplete is set.
   */
  get validity() {
    const a = this.props.validationMessage !== void 0, e = !this.required || this.value !== "", o = this.props.valid !== void 0 ? this.props.valid : e;
    return {
      customError: a,
      valid: o,
      valueMissing: this.value === null
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : b.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : b.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidUpdate(a, e) {
    var g;
    const { groupField: o = "" } = this.props, s = y(this.props), { data: t = [] } = a, i = this.focusedIndex(), r = s[i], p = t !== s, n = r !== void 0 && e.focusedItem !== r, d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, f = a.opened !== void 0 ? a.opened : e.opened, h = !f && d;
    if (o === "")
      (d && (n || p) || h) && this.base.scrollToItem(i);
    else if (!this._isScrolling) {
      const l = (g = this.base.getGroupedDataModernMode(s, o)) == null ? void 0 : g.indexOf(r);
      h && (s && s.length !== 0 && this.base.resetGroupStickyHeader(s[0][o], this), this.base.scrollToItem(l)), d && f && n && this.base.scrollToItem(l);
    }
    this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.base.didMount(), this.setValidity();
  }
  /**
   * @hidden
   */
  render() {
    const { dir: a, disabled: e, label: o, className: s, style: t, loading: i, suggest: r, size: p, rounded: n, fillMode: d } = this.props, f = !this.validityStyles || this.validity.valid, h = this.base, g = this.value, l = this.props.clearButton !== !1 && !i && !!g, u = this.props.id || this._inputId, v = this.state.focused;
    typeof r == "string" && (this._suggested = r);
    const [S, V] = P(this.props.prefix || I.Fragment), [E, M] = P(this.props.suffix || I.Fragment), _ = /* @__PURE__ */ I.createElement(
      "span",
      {
        className: w("k-autocomplete k-input", s, {
          [`k-input-${B[p] || p}`]: p,
          [`k-rounded-${W[n] || n}`]: n,
          [`k-input-${d}`]: d,
          "k-invalid": !f,
          "k-focus": v && !e,
          "k-loading": i,
          "k-required": this.required,
          "k-disabled": e
        }),
        ref: (F) => {
          this._element = F, h.wrapper = F;
        },
        style: o ? { ...t, width: void 0 } : t,
        dir: a
      },
      this.props.prefix && /* @__PURE__ */ I.createElement(S, { ...V }),
      this.renderSearchBar(g || "", u),
      i && /* @__PURE__ */ I.createElement(K, { className: "k-input-loading-icon", name: "loading" }),
      l && !i && /* @__PURE__ */ I.createElement(J, { onClick: this.clearButtonClick, key: "clearbutton" }),
      this.props.suffix && /* @__PURE__ */ I.createElement(E, { ...M }),
      this.renderListContainer()
    );
    return o ? /* @__PURE__ */ I.createElement(
      U,
      {
        label: o,
        editorId: u,
        editorValue: g,
        editorValid: f,
        editorDisabled: e,
        style: { width: t ? t.width : void 0 },
        children: _
      }
    ) : _;
  }
  /**
   * @hidden
   */
  onNavigate(a, e, o) {
    const s = this.value, { textField: t, focusedItemIndex: i } = this.props, r = y(this.props), p = this.state.focusedItem !== void 0 ? r.findIndex((d) => k(d, this.state.focusedItem, t)) : i ? i(r, s, t) : r.indexOf(O(r, s, t)), n = this.base.navigation.navigate({
      keyCode: e,
      current: p,
      max: r.length - 1,
      min: 0,
      skipItems: o || void 0
    });
    n !== void 0 && this.itemFocus(n, a), this.applyState(a);
  }
  /**
   * @hidden
   */
  applyInputValue(a, e, o) {
    const s = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { textField: t } = this.props, i = y(this.props), r = this.focusedIndex(), p = i[r];
    if (this._suggested = "", s && o === m.enter && p && !p.disabled) {
      const n = x(i[this.focusedIndex(a)], t);
      this.triggerOnChange(n, e);
    }
    s && this.togglePopup(e), this.applyState(e);
  }
  renderSearchBar(a, e) {
    const o = this.base, { placeholder: s, tabIndex: t, disabled: i, readonly: r } = this.props, { focused: p } = this.state, n = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ I.createElement(
      T,
      {
        id: e,
        placeholder: s,
        tabIndex: t,
        accessKey: this.props.accessKey,
        value: a,
        suggestedText: this._suggested,
        focused: p,
        name: this.props.name,
        ref: (d) => this._input = d && d.input,
        onKeyDown: this.onInputKeyDown,
        onChange: this.onChangeHandler,
        onFocus: o.handleFocus,
        onBlur: this.handleBlur,
        disabled: i,
        readOnly: r,
        expanded: n,
        owns: o.listBoxId,
        activedescendant: "option-" + o.guid + "-" + this.focusedIndex(),
        role: "combobox",
        ariaLabelledBy: this.props.ariaLabelledBy,
        ariaDescribedBy: this.props.ariaDescribedBy,
        ariaRequired: this.required,
        render: this.props.valueRender
      }
    );
  }
  renderListContainer() {
    const a = this.base, { dir: e, header: o, footer: s, size: t, groupField: i, list: r, groupStickyHeaderItemRender: p } = this.props, n = y(this.props), d = a.getPopupSettings(), f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = d.width !== void 0 ? d.width : a.popupWidth;
    let { group: g } = this.state;
    return g === void 0 && i !== void 0 && (g = x(n[0], i)), /* @__PURE__ */ I.createElement(
      N,
      {
        width: h,
        popupSettings: {
          ...d,
          anchor: d.anchor || this.element,
          show: f,
          popupClass: w(d.popupClass, "k-list-container", "k-autocomplete-popup")
        },
        dir: e !== void 0 ? e : this.base.dirCalculated,
        itemsCount: [n.length]
      },
      o && /* @__PURE__ */ I.createElement("div", { className: "k-list-header" }, o),
      /* @__PURE__ */ I.createElement(
        "div",
        {
          className: w("k-list", {
            [`k-list-${B[t] || t}`]: t
          })
        },
        !r && g && n.length !== 0 && /* @__PURE__ */ I.createElement(H, { group: g, groupMode: "modern", render: p }),
        this.renderList()
      ),
      s && /* @__PURE__ */ I.createElement("div", { className: "k-list-footer" }, s)
    );
  }
  renderList() {
    const a = this.base, e = a.getPopupSettings(), { textField: o, listNoDataRender: s, itemRender: t, groupHeaderItemRender: i } = this.props, r = y(this.props), p = this.value, n = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ I.createElement(
      L,
      {
        id: a.listBoxId,
        show: n,
        data: r.slice(),
        focusedIndex: this.focusedIndex(),
        value: p,
        textField: o,
        valueField: o,
        highlightSelected: !1,
        optionsGuid: a.guid,
        groupField: this.props.groupField,
        groupMode: "modern",
        listRef: (d) => a.list = d,
        wrapperStyle: { maxHeight: e.height },
        wrapperCssClass: "k-list-content",
        onClick: this.handleItemClick,
        itemRender: t,
        groupHeaderItemRender: i,
        noDataRender: s,
        onMouseDown: (d) => d.preventDefault(),
        onScroll: this.onScroll
      }
    );
  }
  triggerOnChange(a, e, o) {
    this.value === a && !o || (e.data.value = a, this._valueDuringOnChange = a, e.events.push({ type: "onChange", ...o || {} }));
  }
  applyState(a) {
    this.base.applyState(a), this._valueDuringOnChange = void 0;
  }
  suggestValue(a) {
    if (this._suggested = "", a) {
      const { textField: e } = this.props, o = y(this.props), s = o[R(o, a, e)];
      if (s) {
        const t = x(s, e);
        a.toLowerCase() !== t.toLowerCase() && (this._suggested = t.substring(a.length));
      }
    }
  }
  focusedIndex(a) {
    const { textField: e, focusedItemIndex: o, skipDisabledItems: s } = this.props, t = y(this.props), i = a !== void 0 ? a : this.value;
    if (this.state.focusedItem !== void 0)
      return t.findIndex((p) => k(p, this.state.focusedItem, e));
    if (o)
      return o(t, i, e);
    const r = t.indexOf(O(t, i, e));
    return s && e && r === -1 ? t.findIndex((p) => !p.disabled && p[e]) : Math.max(0, r);
  }
};
b.displayName = "AutoComplete", b.propTypes = {
  ...C.basicPropTypes,
  size: c.oneOf([null, "small", "medium", "large"]),
  rounded: c.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: c.oneOf([null, "solid", "flat", "outline"]),
  groupField: c.string,
  suggest: c.oneOfType([c.bool, c.string]),
  placeholder: c.string,
  value: c.string,
  defaultValue: c.string,
  validationMessage: c.string,
  required: c.bool,
  readonly: c.bool,
  clearButton: c.bool,
  valueRender: c.func,
  id: c.string,
  ariaLabelledBy: c.string,
  ariaDescribedBy: c.string,
  list: c.any,
  skipDisabledItems: c.bool
}, b.defaultProps = {
  ...C.defaultProps,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  skipDisabledItems: !0,
  prefix: void 0,
  suffix: void 0
};
let D = b;
const X = z(), Y = G(
  $(
    X,
    D
  )
);
Y.displayName = "KendoReactAutoComplete";
export {
  Y as AutoComplete,
  X as AutoCompletePropsContext,
  D as AutoCompleteWithoutContext
};
