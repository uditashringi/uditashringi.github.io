/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import f from "prop-types";
import { TabStripNavigationItem as W } from "./TabStripNavigationItem.mjs";
import { classNames as I } from "@progress/kendo-react-common";
import { Button as z } from "@progress/kendo-react-buttons";
import { caretAltRightIcon as k, caretAltLeftIcon as A, caretAltUpIcon as D, caretAltDownIcon as H } from "@progress/kendo-svg-icons";
import { provideLocalizationService as y } from "@progress/kendo-react-intl";
import { prevArrowTitle as N, messages as x, nextArrowTitle as C } from "./messages/index.mjs";
const B = (w) => Array.apply(null, Array(w)), O = (w) => w.preventDefault(), u = "smooth", d = "prev", b = "next", T = class T extends a.Component {
  constructor(s) {
    super(s), this.itemsNavRef = a.createRef(), this.isRtl = () => this.props.dir === "rtl", this.onWheel = (t) => {
      t.stopPropagation();
      const l = t.deltaY < 0 ? d : b;
      this.setNewScrollPosition(l, t);
    }, this.arrowClickPrev = (t) => {
      this.handleArrowClick(d, t);
    }, this.arrowClickNext = (t) => {
      this.handleArrowClick(b, t);
    }, this.handleArrowClick = (t, l) => {
      this.setNewScrollPosition(t, l);
    }, this.setNewScrollPosition = (t, l) => {
      const e = this.itemsNavRef.current;
      if (!e)
        return;
      const c = this.horizontalScroll(), n = c ? e.scrollWidth - e.offsetWidth : e.scrollHeight - e.offsetHeight, r = (l.type === "click" ? this.props.buttonScrollSpeed : this.props.mouseScrollSpeed) || 0;
      let o = c ? e.scrollLeft : e.scrollTop, i = c ? e.scrollWidth - e.scrollLeft : e.scrollHeight - e.scrollTop, m = e.scrollWidth - e.scrollLeft * -1;
      this.isRtl() && this.horizontalScroll() ? (t === d && o < 0 && (o += r, m += r), t === b && o < n && (o -= r, m -= r), o = Math.min(0, Math.min(n, o))) : (t === d && o > 0 && (o -= r, i += r), t === b && o < n && (o += r, i -= r), o = Math.max(0, Math.min(n, o)));
      const h = o === 0, v = l.type === "click" ? u : void 0;
      if (c) {
        const S = this.isRtl() ? Math.round(m) <= e.clientWidth || Math.floor(m) <= e.clientWidth : Math.round(i) <= e.clientWidth || Math.floor(i) <= e.clientWidth;
        this.setState({
          disabledPrev: h,
          disabledNext: S
        }), e.scrollTo({ left: o, behavior: v });
      } else
        this.setState({
          disabledPrev: h,
          disabledNext: Math.round(i) <= e.clientHeight || Math.floor(i) <= e.clientHeight
        }), e.scrollTo({ top: o, behavior: v });
    }, this.renderArrow = (t, l) => {
      const e = this.horizontalScroll(), c = y(this), n = {
        prev: {
          arrowTab: "k-tabstrip-prev",
          fontIcon: e ? this.isRtl() ? "caret-alt-right" : "caret-alt-left" : "caret-alt-up",
          svgIcon: e ? this.isRtl() ? k : A : D,
          title: c.toLanguageString(N, x[N])
        },
        next: {
          arrowTab: "k-tabstrip-next",
          fontIcon: e ? this.isRtl() ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down",
          svgIcon: e ? this.isRtl() ? A : k : H,
          title: c.toLanguageString(C, x[C])
        }
      }, r = (t === d ? this.props.prevButton : this.props.nextButton) || z, o = t === d ? this.arrowClickPrev : this.arrowClickNext;
      return /* @__PURE__ */ a.createElement(
        r,
        {
          disabled: l,
          className: `${n[t].arrowTab}`,
          onClick: o,
          icon: n[t].fontIcon,
          svgIcon: n[t].svgIcon,
          onMouseDown: O,
          tabIndex: -1,
          fillMode: "flat",
          title: n[t].title
        }
      );
    }, this.state = {
      disabledPrev: this.props.selected === 0,
      disabledNext: this.props.selected === a.Children.count(this.props.children) - 1
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.props.scrollable && this.scrollToSelected();
  }
  /**
   * @hidden
   */
  componentDidUpdate(s) {
    const { scrollable: t, selected: l } = this.props;
    t && s.selected !== l && (this.scrollToSelected(), this.setState({
      disabledPrev: l === 0,
      disabledNext: l === a.Children.count(this.props.children) - 1
    }));
  }
  /**
   * @hidden
   */
  render() {
    const {
      selected: s,
      tabPosition: t,
      tabAlignment: l,
      children: e,
      onSelect: c,
      onKeyDown: n,
      navItemId: r,
      contentPanelId: o,
      renderAllContent: i,
      scrollable: m,
      scrollButtonsPosition: h
    } = this.props, v = a.Children.count(e), S = a.Children.toArray(e);
    let g;
    e && (g = B(v).map((U, p, M) => {
      const E = {
        active: s === p,
        disabled: S[p].props.disabled,
        index: p,
        title: S[p].props.title,
        first: p === 0,
        last: p === M.length - 1,
        contentPanelId: o,
        renderAllContent: i,
        id: r,
        onSelect: c
      };
      return /* @__PURE__ */ a.createElement(W, { key: p, ...E });
    }));
    const L = I("k-tabstrip-items-wrapper", {
      "k-hstack": t === "top" || t === "bottom",
      "k-vstack": t === "left" || t === "right"
    }), P = I("k-tabstrip-items", "k-reset", `k-tabstrip-items-${l}`);
    return /* @__PURE__ */ a.createElement("div", { className: L }, m ? /* @__PURE__ */ a.createElement(a.Fragment, null, (h === "around" || h === "before") && this.renderArrow(d, this.state.disabledPrev), h === "before" && this.renderArrow(b, this.state.disabledNext), /* @__PURE__ */ a.createElement(
      "ul",
      {
        ref: this.itemsNavRef,
        className: P,
        role: "tablist",
        tabIndex: this.props.tabIndex,
        onKeyDown: n,
        onWheel: this.onWheel,
        "aria-orientation": t === "left" || t === "right" ? "vertical" : void 0
      },
      g
    ), h === "after" && this.renderArrow(d, this.state.disabledPrev), (h === "around" || h === "after") && this.renderArrow(b, this.state.disabledNext)) : /* @__PURE__ */ a.createElement("ul", { className: P, role: "tablist", tabIndex: this.props.tabIndex, onKeyDown: n }, g));
  }
  scrollToSelected() {
    const s = this.itemsNavRef.current, t = s && s.children[this.props.selected || 0];
    if (t instanceof HTMLElement && s instanceof HTMLElement) {
      const l = this.horizontalScroll(), e = l ? s.offsetWidth : s.offsetHeight, c = l ? t.offsetWidth : t.offsetHeight, n = l ? "left" : "top";
      let r = l ? s.scrollLeft : s.scrollTop, o = 0;
      if (this.isRtl()) {
        const i = t.offsetLeft;
        r = r * -1, i < 0 ? (o = i - c + s.offsetLeft, s.scrollTo({ [n]: o, behavior: u })) : i + c > e - r && (o = r + i - c, s.scrollTo({ [n]: o, behavior: u }));
      } else {
        const i = l ? t.offsetLeft - s.offsetLeft : t.offsetTop - s.offsetTop;
        r + e < i + c ? (o = i + c - e, s.scrollTo({ [n]: o, behavior: u })) : r > i && (o = i, s.scrollTo({ [n]: o, behavior: u }));
      }
    }
  }
  horizontalScroll() {
    return /top|bottom/.test(this.props.tabPosition || "top");
  }
};
T.propTypes = {
  children: f.oneOfType([f.element, f.arrayOf(f.element)]),
  onSelect: f.func,
  onKeyDown: f.func,
  selected: f.number,
  tabIndex: f.number
};
let R = T;
export {
  R as TabStripNavigation
};
