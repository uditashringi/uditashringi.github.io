/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import t from "prop-types";
import { classNames as l, uAnimation as c, noop as m } from "@progress/kendo-react-common";
import { CSSTransition as J } from "react-transition-group";
const R = a.forwardRef(
  (E, O) => {
    const e = a.useRef(null), {
      mountOnEnter: N = n.mountOnEnter,
      unmountOnExit: h = n.unmountOnExit,
      onEnter: s = n.onEnter,
      onEntering: d = n.onEntering,
      onEntered: x = n.onEntered,
      onExit: g = n.onExit,
      onExiting: f = n.onExiting,
      onExited: y = n.onExited,
      onAfterExited: p = n.onAfterExited,
      animationEnteringStyle: D = n.animationEnteringStyle,
      animationEnteredStyle: C = n.animationEnteredStyle,
      animationExitingStyle: T = n.animationExitingStyle,
      animationExitedStyle: j = n.animationExitedStyle,
      children: q,
      style: P,
      appear: H,
      enter: I,
      exit: $,
      transitionName: u,
      transitionEnterDuration: S,
      transitionExitDuration: v,
      className: w,
      unstyled: A,
      ...K
    } = E, k = {
      transitionDelay: "0ms",
      ...P
    }, o = A && A.uAnimation, z = l(w, c.childContainer({ c: o })), r = a.useRef({
      element: e.current,
      props: E
    }), i = a.useRef(null);
    a.useImperativeHandle(i, () => ({
      element: e.current,
      props: E
    })), a.useImperativeHandle(
      O,
      () => i.current,
      []
    );
    const B = {
      entering: { transitionDuration: `${S}ms`, ...D },
      entered: { ...C },
      exiting: { transitionDuration: `${v}ms`, ...T },
      exited: { ...j }
    }, F = {
      in: E.in,
      appear: H,
      enter: I,
      exit: $,
      mountOnEnter: N,
      unmountOnExit: h,
      timeout: {
        enter: S,
        exit: v
      },
      onEnter: () => {
        s && s.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      onEntering: () => {
        d && d.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      onEntered: () => {
        x && x.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      onExit: () => {
        g && g.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      onExiting: () => {
        f && f.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      onExited: () => {
        p && p.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        }), y && y.call(void 0, {
          animatedElement: e.current,
          target: i.current || r.current
        });
      },
      classNames: {
        appear: l(c.appear({ c: o, transitionName: u })),
        appearActive: l(c.appearActive({ c: o, transitionName: u })),
        enter: l(c.enter({ c: o, transitionName: u })),
        enterActive: l(c.enterActive({ c: o, transitionName: u })),
        exit: l(c.exit({ c: o, transitionName: u })),
        exitActive: l(c.exitActive({ c: o, transitionName: u }))
      }
    };
    return /* @__PURE__ */ a.createElement(J, { ...F, ...K, nodeRef: e }, (G) => /* @__PURE__ */ a.createElement(
      "div",
      {
        style: {
          ...k,
          ...B[G]
        },
        className: z,
        ref: (b) => {
          e.current = b, r.current.element = b;
        }
      },
      q
    ));
  }
), n = {
  mountOnEnter: !0,
  unmountOnExit: !1,
  onEnter: m,
  onEntering: m,
  onEntered: m,
  onExit: m,
  onExiting: m,
  onExited: m,
  onAfterExited: m,
  animationEnteringStyle: {},
  animationEnteredStyle: {},
  animationExitingStyle: {},
  animationExitedStyle: {}
};
R.displayName = "KendoReactAnimationChild";
R.propTypes = {
  in: t.bool,
  children: t.oneOfType([t.arrayOf(t.node), t.node]),
  transitionName: t.string.isRequired,
  className: t.string,
  appear: t.bool,
  enter: t.bool,
  exit: t.bool,
  transitionEnterDuration: t.number.isRequired,
  transitionExitDuration: t.number.isRequired,
  mountOnEnter: t.bool,
  unmountOnExit: t.bool,
  animationEnteringStyle: t.object,
  animationEnteredStyle: t.object,
  animationExitingStyle: t.object,
  animationExitedStyle: t.object
};
export {
  R as AnimationChild
};
