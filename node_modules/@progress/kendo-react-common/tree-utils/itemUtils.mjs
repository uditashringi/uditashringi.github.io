/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { getRootParentId as h, isIdZeroLevel as I, getIdWithoutRootParentId as b, getAllShortIds as p, createId as g, EMPTY_ID as C } from "./itemIdUtils.mjs";
import { SortedPublicItemIds as x } from "./SortedPublicItemIds.mjs";
import { getNestedValue as i } from "./misc.mjs";
function P(t, o) {
  const e = i(o, t);
  return !!(e && e.length);
}
function O(t, o) {
  return o.expanded(t) && P(t, o.getChildrenField());
}
function R(t, o, e, n) {
  const u = A([t], o, e, n);
  return u.length ? u[0] : void 0;
}
function A(t, o, e, n) {
  const u = [], r = new x();
  return r.init(t), N(r, o, e, C, u, n), u;
}
function d(t, o, e, n, u) {
  const r = Number(h(o));
  if (r >= t.length)
    return t;
  let s = t, c = t[r];
  return c[n] || (s = t.slice(), c = s[r] = Object.assign({}, c, { [n]: !0 })), I(o) ? e(c) : c[u] && (c[u] = d(
    c[u],
    b(o),
    e,
    n,
    u
  )), s;
}
function W(t, o, e) {
  const n = p(t);
  let u = o;
  for (let r = 0; r < n.length; r++) {
    const s = u[Number(n[r])];
    if (e.disabled(s))
      return !1;
    u = s[e.getChildrenField()];
  }
  return !0;
}
function j(t, o, e, n) {
  return n ? r(t) : u(t, o);
  function u(s, c) {
    let l = [];
    const f = s[e] || [];
    for (let a = 0; a < f.length; a++) {
      const m = g(a, c);
      l.push(m), l = l.concat(u(f[a], m));
    }
    return l;
  }
  function r(s) {
    let c = [];
    const l = s[e] || [];
    for (let f = 0; f < l.length; f++)
      c.push(i(n, l[f])), c = c.concat(r(l[f]));
    return c;
  }
}
function w(t, o, e, n, u) {
  return (t[n] || []).every(
    (s, c) => u.indexOf(e ? i(e, s) : g(c, o)) > -1
  );
}
function y(t, o, e) {
  const n = [], u = p(t);
  let r = e;
  for (let s = 0; s < u.length - 1 && r; s++) {
    const c = r[Number(u[s])];
    n.push(c), r = c[o];
  }
  return n;
}
function v(t, o, e) {
  const n = e.slice();
  if (I(t))
    n.splice(Number(t), 1);
  else {
    const u = Number(h(t)), r = n[u] = { ...n[u] };
    r[o] = v(
      b(t),
      o,
      r[o]
    );
  }
  return n;
}
function E(t, o, e, n, u) {
  const r = u.slice();
  if (I(n))
    if (o === "child") {
      const s = r[Number(n)] = { ...r[Number(n)] };
      s[e] ? (s[e] = s[e].slice(), s[e].push(t)) : s[e] = [t];
    } else
      r.splice(Number(n) + (o === "after" ? 1 : 0), 0, t);
  else {
    const s = Number(h(n)), c = r[s] = { ...r[s] };
    c[e] = E(
      t,
      o,
      e,
      b(n),
      c[e]
    );
  }
  return r;
}
function N(t, o, e, n, u, r) {
  for (let s = 0; s < e.length; s++) {
    const c = e[s], l = g(s, n);
    t.hasId(i(o, c)) && u.push(l), P(c, r) && N(
      t,
      o,
      i(r, c),
      l,
      u,
      r
    );
  }
}
export {
  E as addItem,
  w as areAllDirectChildrenChecked,
  j as getAllDirectIndirectChildrenIds,
  y as getAllParents,
  P as hasChildren,
  W as isEnabledAndAllParentsEnabled,
  O as isItemExpandedAndWithChildren,
  v as removeItem,
  R as resolveItemId,
  A as resolveItemsIds,
  d as updateItem
};
