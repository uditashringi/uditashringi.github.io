/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _FreeTextEditor_instances, _a, _FreeTextEditor_color, _FreeTextEditor_content, _FreeTextEditor_editorDivId, _FreeTextEditor_editModeAC, _FreeTextEditor_fontSize, _FreeTextEditor_initialData, _FreeTextEditor_updateFontSize, _FreeTextEditor_updateColor, _FreeTextEditor_extractText, _FreeTextEditor_setEditorDimensions, _FreeTextEditor_getNodeContent, _FreeTextEditor_setContent, _FreeTextEditor_serializeContent, _FreeTextEditor_deserializeContent, _FreeTextEditor_hasElementChanged;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// eslint-disable-next-line max-len
/** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
import { AnnotationEditorParamsType, AnnotationEditorType, Util, } from "pdfjs-dist/legacy/build/pdf.mjs";
// import {
//     AnnotationEditorUIManager,
//     bindEvents,
//     KeyboardManager,
// } from "./tools.js";
import { AnnotationEditor } from "./annotation-editor";
import { bindEvents } from "../helpers/tools";
import { FreeTextAnnotationElement } from "../annotation-layer";
// import { FreeTextAnnotationElement } from "../annotation-layer";
const EOL_PATTERN = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
    constructor(params) {
        super(Object.assign(Object.assign({}, params), { name: "k-free-text-editor freeTextEditor" }));
        _FreeTextEditor_instances.add(this);
        // todo: props
        this.editorDiv = null;
        this.overlayDiv = null;
        // todo: props
        _FreeTextEditor_color.set(this, void 0);
        _FreeTextEditor_content.set(this, "");
        _FreeTextEditor_editorDivId.set(this, `${this.id}-editor`);
        _FreeTextEditor_editModeAC.set(this, null);
        _FreeTextEditor_fontSize.set(this, void 0);
        _FreeTextEditor_initialData.set(this, null);
        __classPrivateFieldSet(this, _FreeTextEditor_color, params.color ||
            _a._defaultColor ||
            AnnotationEditor._defaultLineColor, "f");
        __classPrivateFieldSet(this, _FreeTextEditor_fontSize, params.fontSize || _a._defaultFontSize, "f");
    }
    /** @inheritdoc */
    static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager, {
            strings: ["pdfjs-free-text-default-content"],
        });
        const style = getComputedStyle(document.documentElement);
        // if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
        //     const lineHeight = parseFloat(
        //         style.getPropertyValue("--freetext-line-height")
        //     );
        //     assert(
        //         lineHeight === LINE_FACTOR,
        //         "Update the CSS variable to agree with the constant."
        //     );
        // }
        // todo: read the variable
        this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding")) || 2;
    }
    /** @inheritdoc */
    static updateDefaultParams(type, value) {
        switch (type) {
            case AnnotationEditorParamsType.FREETEXT_SIZE:
                _a._defaultFontSize = value;
                break;
            case AnnotationEditorParamsType.FREETEXT_COLOR:
                _a._defaultColor = value;
                break;
            default: break;
        }
    }
    /** @inheritdoc */
    updateParams(type, value) {
        switch (type) {
            case AnnotationEditorParamsType.FREETEXT_SIZE:
                __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_updateFontSize).call(this, value);
                break;
            case AnnotationEditorParamsType.FREETEXT_COLOR:
                __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_updateColor).call(this, value);
                break;
            default: break;
        }
    }
    /** @inheritdoc */
    static get defaultPropertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.FREETEXT_SIZE,
                _a._defaultFontSize,
            ],
            [
                AnnotationEditorParamsType.FREETEXT_COLOR,
                _a._defaultColor || AnnotationEditor._defaultLineColor,
            ],
        ];
    }
    /** @inheritdoc */
    get propertiesToUpdate() {
        return [
            [AnnotationEditorParamsType.FREETEXT_SIZE, __classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f")],
            [AnnotationEditorParamsType.FREETEXT_COLOR, __classPrivateFieldGet(this, _FreeTextEditor_color, "f")],
        ];
    }
    /**
     * Helper to translate the editor with the keyboard when it's empty.
     * @param {number} x in page units.
     * @param {number} y in page units.
     */
    _translateEmpty(x, y) {
        this._uiManager.translateSelectedEditors(x, y, /* noCommit = */ true);
    }
    getInitialTranslation() {
        // The start of the base line is where the user clicked.
        const scale = this.parentScale;
        return [
            -_a._internalPadding * scale,
            -(_a._internalPadding + __classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f")) * scale,
        ];
    }
    /** @inheritdoc */
    rebuild() {
        if (!this.parent) {
            return;
        }
        super.rebuild();
        if (this.div === null) {
            return;
        }
        if (!this.isAttachedToDOM) {
            // At some point this editor was removed and we're rebuilting it,
            // hence we must add it to its parent.
            this.parent.add(this);
        }
    }
    enableEditMode() {
        if (this.isInEditMode()) {
            return;
        }
        this.parent.setEditingState(false);
        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);
        super.enableEditMode();
        this.overlayDiv.classList.remove("enabled");
        this.editorDiv.contentEditable = true;
        this._isDraggable = false;
        this.div.removeAttribute("aria-activedescendant");
        // if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
        //     assert(
        //         !this.#editModeAC,
        //         "No `this.#editModeAC` AbortController should exist."
        //     );
        // }
        __classPrivateFieldSet(this, _FreeTextEditor_editModeAC, new AbortController(), "f");
        const signal = this._uiManager.combinedSignal(__classPrivateFieldGet(this, _FreeTextEditor_editModeAC, "f"));
        this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal });
        this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
            signal,
        });
        this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
            signal,
        });
        this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
            signal,
        });
        this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
            signal,
        });
    }
    disableEditMode() {
        var _b;
        if (!this.isInEditMode()) {
            return;
        }
        this.parent.setEditingState(true);
        super.disableEditMode();
        // this.overlayDiv.classList.add("enabled");
        this.editorDiv.contentEditable = false;
        this.div.setAttribute("aria-activedescendant", __classPrivateFieldGet(this, _FreeTextEditor_editorDivId, "f"));
        this._isDraggable = true;
        (_b = __classPrivateFieldGet(this, _FreeTextEditor_editModeAC, "f")) === null || _b === void 0 ? void 0 : _b.abort();
        __classPrivateFieldSet(this, _FreeTextEditor_editModeAC, null, "f");
        // On Chrome, the focus is given to <body> when contentEditable is set to
        // false, hence we focus the div.
        this.div.focus({
            preventScroll: true /* See issue #15744 */,
        });
        // In case the blur callback hasn't been called.
        this.isEditing = false;
        // this.parent.div.classList.add("freetextEditing");
    }
    focusin(event) {
        var _b;
        if (!this._focusEventsAllowed) {
            return;
        }
        if (((_b = this._uiManager) === null || _b === void 0 ? void 0 : _b.getMode()) !== AnnotationEditorType.FREETEXT) {
            // prevent focusing the freetext editor while in highlight mode
            // in pdf.js this situation does free highlight annotation isntead
            // which is not currently implemented
            return;
        }
        super.focusin(event);
        if (event.target !== this.editorDiv) {
            this.editorDiv.focus();
        }
    }
    /** @inheritdoc */
    onceAdded() {
        var _b;
        if (this.width) {
            // The editor was created in using ctrl+c.
            return;
        }
        this.enableEditMode();
        this.editorDiv.focus();
        if ((_b = this._initialOptions) === null || _b === void 0 ? void 0 : _b.isCentered) {
            this.center();
        }
        this._initialOptions = null;
    }
    /** @inheritdoc */
    isEmpty() {
        var _b, _c;
        return !this.editorDiv || ((_c = (_b = this.editorDiv) === null || _b === void 0 ? void 0 : _b.innerText) === null || _c === void 0 ? void 0 : _c.trim()) === "";
    }
    /** @inheritdoc */
    remove() {
        this.isEditing = false;
        if (this.parent) {
            this.parent.setEditingState(true);
            // this.parent.div.classList.add("freetextEditing");
        }
        super.remove();
    }
    /**
     * Commit the content we have in this editor.
     * @returns {undefined}
     */
    commit() {
        if (!this.isInEditMode()) {
            return;
        }
        super.commit();
        this.disableEditMode();
        const savedText = __classPrivateFieldGet(this, _FreeTextEditor_content, "f");
        const newText = (__classPrivateFieldSet(this, _FreeTextEditor_content, __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_extractText).call(this).trimEnd(), "f"));
        if (savedText === newText) {
            return;
        }
        const setText = text => {
            __classPrivateFieldSet(this, _FreeTextEditor_content, text, "f");
            if (!text) {
                this.remove();
                return;
            }
            __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setContent).call(this);
            this._uiManager.rebuild(this);
            __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setEditorDimensions).call(this);
        };
        this.addCommands({
            cmd: () => {
                setText(newText);
            },
            undo: () => {
                setText(savedText);
            },
            mustExec: false,
        });
        __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setEditorDimensions).call(this);
    }
    /** @inheritdoc */
    shouldGetKeyboardEvents() {
        return this.isInEditMode();
    }
    /** @inheritdoc */
    enterInEditMode() {
        this.enableEditMode();
        this.editorDiv.focus();
    }
    /**
     * ondblclick callback.
     * @param {MouseEvent} event
     */
    dblclick(event) {
        if (!event) {
            return;
        }
        this.enterInEditMode();
    }
    /**
     * onkeydown callback.
     * @param {KeyboardEvent} event
     */
    keydown(event) {
        if (event.target === this.div && event.key === "Enter") {
            this.enterInEditMode();
            // Avoid to add an unwanted new line.
            event.preventDefault();
        }
    }
    editorDivKeydown() {
        // FreeTextEditor._keyboardManager.exec(this, event);
    }
    editorDivFocus() {
        this.isEditing = true;
    }
    editorDivBlur() {
        this.isEditing = false;
    }
    editorDivInput() {
        // this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    /** @inheritdoc */
    disableEditing() {
        this.editorDiv.setAttribute("role", "comment");
        this.editorDiv.removeAttribute("aria-multiline");
    }
    /** @inheritdoc */
    enableEditing() {
        this.editorDiv.setAttribute("role", "textbox");
        this.editorDiv.setAttribute("aria-multiline", true);
    }
    /** @inheritdoc */
    render() {
        var _b;
        if (this.div) {
            return this.div;
        }
        let baseX, baseY;
        if (this.width) {
            baseX = this.x;
            baseY = this.y;
        }
        super.render();
        this.editorDiv = document.createElement("div");
        this.editorDiv.className = "k-internal internal";
        // todo: move to CSS
        // this.editorDiv.style.position = "absolute";
        // this.div.style.position = "absolute";
        this.editorDiv.setAttribute("id", __classPrivateFieldGet(this, _FreeTextEditor_editorDivId, "f"));
        this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text");
        this.enableEditing();
        // AnnotationEditor._l10nPromise
        //     .get("pdfjs-free-text-default-content")
        //     .then(msg => this.editorDiv?.setAttribute("default-content", msg));
        // todo: fix localization
        (_b = this.editorDiv) === null || _b === void 0 ? void 0 : _b.setAttribute("default-content", this._uiManager.pdfViewer.options.messages.freeTextEditorPlaceholder);
        this.editorDiv.contentEditable = true;
        const { style } = this.editorDiv;
        style.fontSize = `calc(${__classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f")}px * var(--scale-factor))`;
        style.color = __classPrivateFieldGet(this, _FreeTextEditor_color, "f");
        this.div.append(this.editorDiv);
        this.overlayDiv = document.createElement("div");
        // this.overlayDiv.classList.add("overlay", "enabled");
        this.div.append(this.overlayDiv);
        bindEvents(this, this.div, ["dblclick", "keydown"]);
        if (this.width) {
            // This editor was created in using copy (ctrl+c).
            const [parentWidth, parentHeight] = this.parentDimensions;
            if (this.annotationElementId) {
                // This stuff is hard to test: if something is changed here, please
                // test with the following PDF file:
                //  - freetexts.pdf
                //  - rotated_freetexts.pdf
                // Only small variations between the original annotation and its editor
                // are allowed.
                // position is the position of the first glyph in the annotation
                // and it's relative to its container.
                const { position } = __classPrivateFieldGet(this, _FreeTextEditor_initialData, "f");
                let [tx, ty] = this.getInitialTranslation();
                [tx, ty] = this.pageTranslationToScreen(tx, ty);
                const [pageWidth, pageHeight] = this.pageDimensions;
                const [pageX, pageY] = this.pageTranslation;
                let posX, posY;
                switch (this.rotation) {
                    case 0:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                        break;
                    case 90:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [ty, -tx];
                        break;
                    case 180:
                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [-tx, -ty];
                        break;
                    case 270:
                        posX =
                            baseX +
                                (position[0] - pageX - this.height * pageHeight) / pageWidth;
                        posY =
                            baseY +
                                (position[1] - pageY - this.width * pageWidth) / pageHeight;
                        [tx, ty] = [-ty, tx];
                        break;
                    default: break;
                }
                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
            }
            else {
                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
            }
            __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setContent).call(this);
            this._isDraggable = true;
            this.editorDiv.contentEditable = false;
        }
        else {
            this._isDraggable = false;
            this.editorDiv.contentEditable = true;
        }
        // if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
        //     this.div.setAttribute("annotation-id", this.annotationElementId);
        // }
        return this.div;
    }
    editorDivPaste(event) {
        // @ts-expect-error TS(2551):
        const clipboardData = event.clipboardData || window.clipboardData;
        const { types } = clipboardData;
        if (types.length === 1 && types[0] === "text/plain") {
            return;
        }
        event.preventDefault();
        const paste = __classPrivateFieldGet(_a, _a, "m", _FreeTextEditor_deserializeContent).call(_a, clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
        if (!paste) {
            return;
        }
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            return;
        }
        this.editorDiv.normalize();
        selection.deleteFromDocument();
        const range = selection.getRangeAt(0);
        if (!paste.includes("\n")) {
            range.insertNode(document.createTextNode(paste));
            this.editorDiv.normalize();
            selection.collapseToStart();
            return;
        }
        // Collect the text before and after the caret.
        const { startContainer, startOffset } = range;
        const bufferBefore = [];
        const bufferAfter = [];
        if (startContainer.nodeType === Node.TEXT_NODE) {
            const parent = startContainer.parentElement;
            bufferAfter.push(
            // @ts-expect-error TS(2556):
            startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
            if (parent !== this.editorDiv) {
                let buffer = bufferBefore;
                for (const child of this.editorDiv.childNodes) {
                    if (child === parent) {
                        buffer = bufferAfter;
                        continue;
                    }
                    buffer.push(__classPrivateFieldGet(_a, _a, "m", _FreeTextEditor_getNodeContent).call(_a, child));
                }
            }
            bufferBefore.push(startContainer.nodeValue
                .slice(0, startOffset)
                // @ts-expect-error TS(2556):
                .replaceAll(EOL_PATTERN, ""));
        }
        else if (startContainer === this.editorDiv) {
            let buffer = bufferBefore;
            let i = 0;
            for (const child of this.editorDiv.childNodes) {
                if (i++ === startOffset) {
                    buffer = bufferAfter;
                }
                buffer.push(__classPrivateFieldGet(_a, _a, "m", _FreeTextEditor_getNodeContent).call(_a, child));
            }
        }
        __classPrivateFieldSet(this, _FreeTextEditor_content, `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`, "f");
        __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setContent).call(this);
        // Set the caret at the right position.
        const newRange = new Range();
        let beforeLength = bufferBefore.reduce((acc, line) => acc + line.length, 0);
        for (const { firstChild } of this.editorDiv.childNodes) {
            // Each child is either a div with a text node or a br element.
            if (firstChild.nodeType === Node.TEXT_NODE) {
                const length = firstChild.nodeValue.length;
                if (beforeLength <= length) {
                    newRange.setStart(firstChild, beforeLength);
                    newRange.setEnd(firstChild, beforeLength);
                    break;
                }
                beforeLength -= length;
            }
        }
        selection.removeAllRanges();
        selection.addRange(newRange);
    }
    /** @inheritdoc */
    get contentDiv() {
        return this.editorDiv;
    }
    /** @inheritdoc */
    static deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof FreeTextAnnotationElement) {
            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, }, textContent, textPosition, parent: { page: { pageNumber }, }, } = data;
            // textContent is supposed to be an array of strings containing each line
            // of text. However, it can be null or empty.
            if (!textContent || textContent.length === 0) {
                // Empty annotation.
                return null;
            }
            initialData = data = {
                annotationType: AnnotationEditorType.FREETEXT,
                color: Array.from(fontColor),
                fontSize,
                value: textContent.join("\n"),
                position: textPosition,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                id,
                deleted: false,
            };
        }
        const editor = super.deserialize(data, parent, uiManager);
        __classPrivateFieldSet(editor, _FreeTextEditor_fontSize, data.fontSize, "f");
        // @ts-expect-error TS(2556):
        __classPrivateFieldSet(editor, _FreeTextEditor_color, Util.makeHexColor(...data.color), "f");
        __classPrivateFieldSet(editor, _FreeTextEditor_content, __classPrivateFieldGet(_a, _a, "m", _FreeTextEditor_deserializeContent).call(_a, data.value), "f");
        editor.annotationElementId = data.id || null;
        __classPrivateFieldSet(editor, _FreeTextEditor_initialData, initialData, "f");
        return editor;
    }
    /** @inheritdoc */
    serialize(isForCopying = false) {
        if (this.isEmpty()) {
            return null;
        }
        if (this.deleted) {
            return {
                pageIndex: this.pageIndex,
                id: this.annotationElementId,
                deleted: true,
            };
        }
        const padding = _a._internalPadding * this.parentScale;
        const rect = this.getRect(padding, padding);
        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM
            ? getComputedStyle(this.editorDiv).color
            : __classPrivateFieldGet(this, _FreeTextEditor_color, "f"));
        const serialized = {
            annotationType: AnnotationEditorType.FREETEXT,
            color,
            fontSize: __classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f"),
            value: __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_serializeContent).call(this),
            pageIndex: this.pageIndex,
            rect,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId,
        };
        if (isForCopying) {
            // Don't add the id when copying because the pasted editor mustn't be
            // linked to an existing annotation.
            return serialized;
        }
        if (this.annotationElementId && !__classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_hasElementChanged).call(this, serialized)) {
            return null;
        }
        // @ts-expect-error TS(2556):
        serialized.id = this.annotationElementId;
        return serialized;
    }
    /** @inheritdoc */
    renderAnnotationElement(annotation) {
        const content = super.renderAnnotationElement(annotation);
        if (this.deleted) {
            return content;
        }
        const { style } = content;
        style.fontSize = `calc(${__classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f")}px * var(--scale-factor))`;
        style.color = __classPrivateFieldGet(this, _FreeTextEditor_color, "f");
        content.replaceChildren();
        for (const line of __classPrivateFieldGet(this, _FreeTextEditor_content, "f").split("\n")) {
            const div = document.createElement("div");
            div.append(line ? document.createTextNode(line) : document.createElement("br"));
            content.append(div);
        }
        const padding = _a._internalPadding * this.parentScale;
        annotation.updateEdited({
            rect: this.getRect(padding, padding),
            popupContent: __classPrivateFieldGet(this, _FreeTextEditor_content, "f"),
        });
        return content;
    }
    resetAnnotationElement(annotation) {
        super.resetAnnotationElement(annotation);
        annotation.resetEdited();
    }
    // todo: this is necessary
    // saveDocument() has checks that test "editor instanceof AnnotationEditor", but they fail
    // because AnnotationEditor from "pdfjs-dist/legacy/build/pdf.mjs" is not exported
    // thus replace instances of editors with their serialized version
    toJSON() {
        const data = this.serialize();
        return data;
    }
}
_a = FreeTextEditor, _FreeTextEditor_color = new WeakMap(), _FreeTextEditor_content = new WeakMap(), _FreeTextEditor_editorDivId = new WeakMap(), _FreeTextEditor_editModeAC = new WeakMap(), _FreeTextEditor_fontSize = new WeakMap(), _FreeTextEditor_initialData = new WeakMap(), _FreeTextEditor_instances = new WeakSet(), _FreeTextEditor_updateFontSize = function _FreeTextEditor_updateFontSize(fontSize) {
    const setFontsize = size => {
        this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
        this.translate(0, -(size - __classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f")) * this.parentScale);
        __classPrivateFieldSet(this, _FreeTextEditor_fontSize, size, "f");
        __classPrivateFieldGet(this, _FreeTextEditor_instances, "m", _FreeTextEditor_setEditorDimensions).call(this);
    };
    const savedFontsize = __classPrivateFieldGet(this, _FreeTextEditor_fontSize, "f");
    this.addCommands({
        cmd: setFontsize.bind(this, fontSize),
        undo: setFontsize.bind(this, savedFontsize),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.FREETEXT_SIZE,
        overwriteIfSameType: true,
        keepUndo: true,
    });
}, _FreeTextEditor_updateColor = function _FreeTextEditor_updateColor(color) {
    const setColor = col => {
        __classPrivateFieldSet(this, _FreeTextEditor_color, this.editorDiv.style.color = col, "f");
    };
    const savedColor = __classPrivateFieldGet(this, _FreeTextEditor_color, "f");
    this.addCommands({
        cmd: setColor.bind(this, color),
        undo: setColor.bind(this, savedColor),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.FREETEXT_COLOR,
        overwriteIfSameType: true,
        keepUndo: true,
    });
}, _FreeTextEditor_extractText = function _FreeTextEditor_extractText() {
    // We don't use innerText because there are some bugs with line breaks.
    const buffer = [];
    this.editorDiv.normalize();
    for (const child of this.editorDiv.childNodes) {
        buffer.push(__classPrivateFieldGet(_a, _a, "m", _FreeTextEditor_getNodeContent).call(_a, child));
    }
    return buffer.join("\n");
}, _FreeTextEditor_setEditorDimensions = function _FreeTextEditor_setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    let rect;
    if (this.isAttachedToDOM) {
        rect = this.div.getBoundingClientRect();
    }
    else {
        // This editor isn't on screen but we need to get its dimensions, so
        // we just insert it in the DOM, get its bounding box and then remove it.
        const { currentLayer, div } = this;
        const savedDisplay = div.style.display;
        const savedVisibility = div.classList.contains("hidden") || div.classList.contains("k-hidden");
        div.classList.remove("hidden");
        div.classList.remove("k-hidden");
        div.style.display = "hidden";
        currentLayer.div.append(this.div);
        rect = div.getBoundingClientRect();
        div.remove();
        div.style.display = savedDisplay;
        // div.classList.toggle("hidden", savedVisibility);
        div.classList.toggle("k-hidden", savedVisibility);
    }
    // The dimensions are relative to the rotation of the page, hence we need to
    // take that into account (see issue #16636).
    if (this.rotation % 180 === this.parentRotation % 180) {
        this.width = rect.width / parentWidth;
        this.height = rect.height / parentHeight;
    }
    else {
        this.width = rect.height / parentWidth;
        this.height = rect.width / parentHeight;
    }
    this.fixAndSetPosition();
}, _FreeTextEditor_getNodeContent = function _FreeTextEditor_getNodeContent(node) {
    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
}, _FreeTextEditor_setContent = function _FreeTextEditor_setContent() {
    this.editorDiv.replaceChildren();
    if (!__classPrivateFieldGet(this, _FreeTextEditor_content, "f")) {
        return;
    }
    for (const line of __classPrivateFieldGet(this, _FreeTextEditor_content, "f").split("\n")) {
        const div = document.createElement("div");
        div.append(line ? document.createTextNode(line) : document.createElement("br"));
        this.editorDiv.append(div);
    }
}, _FreeTextEditor_serializeContent = function _FreeTextEditor_serializeContent() {
    // @ts-expect-error TS(2556):
    return __classPrivateFieldGet(this, _FreeTextEditor_content, "f").replaceAll("\xa0", " ");
}, _FreeTextEditor_deserializeContent = function _FreeTextEditor_deserializeContent(content) {
    return content.replaceAll(" ", "\xa0");
}, _FreeTextEditor_hasElementChanged = function _FreeTextEditor_hasElementChanged(serialized) {
    const { value, fontSize, color, pageIndex } = __classPrivateFieldGet(this, _FreeTextEditor_initialData, "f");
    return (this._hasBeenMoved ||
        serialized.value !== value ||
        serialized.fontSize !== fontSize ||
        serialized.color.some((c, i) => c !== color[i]) ||
        serialized.pageIndex !== pageIndex);
};
FreeTextEditor._freeTextDefaultContent = "";
FreeTextEditor._internalPadding = 0;
// static _defaultColor = null;
FreeTextEditor._defaultColor = "#000000";
FreeTextEditor._defaultFontSize = 10;
// static get _keyboardManager() {
//     const proto = FreeTextEditor.prototype;
//     const arrowChecker = self => self.isEmpty();
//     const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
//     const big = AnnotationEditorUIManager.TRANSLATE_BIG;
//     return shadow(
//         this,
//         "_keyboardManager",
//         new KeyboardManager([
//             [
//                 // Commit the text in case the user use ctrl+s to save the document.
//                 // The event must bubble in order to be caught by the viewer.
//                 // See bug 1831574.
//                 ["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"],
//                 proto.commitOrRemove,
//                 { bubbles: true },
//             ],
//             [
//                 ["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"],
//                 proto.commitOrRemove,
//             ],
//             [
//                 ["ArrowLeft", "mac+ArrowLeft"],
//                 proto._translateEmpty,
//                 { args: [-small, 0], checker: arrowChecker },
//             ],
//             [
//                 ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
//                 proto._translateEmpty,
//                 { args: [-big, 0], checker: arrowChecker },
//             ],
//             [
//                 ["ArrowRight", "mac+ArrowRight"],
//                 proto._translateEmpty,
//                 { args: [small, 0], checker: arrowChecker },
//             ],
//             [
//                 ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
//                 proto._translateEmpty,
//                 { args: [big, 0], checker: arrowChecker },
//             ],
//             [
//                 ["ArrowUp", "mac+ArrowUp"],
//                 proto._translateEmpty,
//                 { args: [0, -small], checker: arrowChecker },
//             ],
//             [
//                 ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
//                 proto._translateEmpty,
//                 { args: [0, -big], checker: arrowChecker },
//             ],
//             [
//                 ["ArrowDown", "mac+ArrowDown"],
//                 proto._translateEmpty,
//                 { args: [0, small], checker: arrowChecker },
//             ],
//             [
//                 ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
//                 proto._translateEmpty,
//                 { args: [0, big], checker: arrowChecker },
//             ],
//         ])
//     );
// }
FreeTextEditor._type = "freetext";
FreeTextEditor._editorType = AnnotationEditorType.FREETEXT;
export { FreeTextEditor };
