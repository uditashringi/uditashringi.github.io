/* Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _AnnotationEditorUIManager_instances, _AnnotationEditorUIManager_abortController, _AnnotationEditorUIManager_activeEditor, _AnnotationEditorUIManager_allEditors, _AnnotationEditorUIManager_allLayers, _AnnotationEditorUIManager_annotationStorage, _AnnotationEditorUIManager_changedExistingAnnotations, _AnnotationEditorUIManager_commandManager, _AnnotationEditorUIManager_currentPageIndex, _AnnotationEditorUIManager_deletedAnnotationsElementIds, _AnnotationEditorUIManager_draggingEditors, _AnnotationEditorUIManager_editorTypes, _AnnotationEditorUIManager_editorsToRescale, _AnnotationEditorUIManager_enableHighlightFloatingButton, _AnnotationEditorUIManager_focusMainContainerTimeoutId, _AnnotationEditorUIManager_focusManagerAC, _AnnotationEditorUIManager_highlightColors, _AnnotationEditorUIManager_highlightWhenShiftUp, _AnnotationEditorUIManager_highlightToolbar, _AnnotationEditorUIManager_idManager, _AnnotationEditorUIManager_isEnabled, _AnnotationEditorUIManager_isWaiting, _AnnotationEditorUIManager_lastActiveElement, _AnnotationEditorUIManager_mode, _AnnotationEditorUIManager_selectedEditors, _AnnotationEditorUIManager_selectedTextNode, _AnnotationEditorUIManager_showAllStates, _AnnotationEditorUIManager_previousStates, _AnnotationEditorUIManager_translation, _AnnotationEditorUIManager_translationTimeoutId, _AnnotationEditorUIManager_container, _AnnotationEditorUIManager_viewer, _AnnotationEditorUIManager_getAnchorElementForSelection, _AnnotationEditorUIManager_getLayerForTextLayer, _AnnotationEditorUIManager_displayHighlightToolbar, _AnnotationEditorUIManager_selectionChange, _AnnotationEditorUIManager_onSelectEnd, _AnnotationEditorUIManager_addSelectionListener, _AnnotationEditorUIManager_addFocusManager, _AnnotationEditorUIManager_removeFocusManager, _AnnotationEditorUIManager_addKeyboardManager, _AnnotationEditorUIManager_removeKeyboardManager, _AnnotationEditorUIManager_addCopyPasteListeners, _AnnotationEditorUIManager_removeCopyPasteListeners, _AnnotationEditorUIManager_addDragAndDropListeners, _AnnotationEditorUIManager_dispatchUpdateStates, _AnnotationEditorUIManager_dispatchUpdateUI, _AnnotationEditorUIManager_enableAll, _AnnotationEditorUIManager_disableAll, _AnnotationEditorUIManager_addEditorToLayer, _AnnotationEditorUIManager_lastSelectedEditor_get, _AnnotationEditorUIManager_isEmpty, _AnnotationEditorUIManager_selectEditors;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// import { PixelsPerInch, shadow } from "pdfjs-dist/legacy/build/pdf.mjs";
import { AnnotationEditorParamsType, AnnotationEditorType, PixelsPerInch, shadow } from "pdfjs-dist/legacy/build/pdf.mjs";
// import { CommandManager } from "./helpers/command-manager";
import { IdManager } from "./helpers/id-manager";
// import { AnnotationEditorType } from "../shared/utils";
import { CommandManager } from "./helpers/command-manager";
// import { ImageManager } from "./helpers/image-manager";
export class AnnotationEditorUIManager {
    // static get _keyboardManager() {
    //     const proto = AnnotationEditorUIManager.prototype;
    //     /**
    //      * If the focused element is an input, we don't want to handle the arrow.
    //      * For example, sliders can be controlled with the arrow keys.
    //      */
    //     const arrowChecker = self =>
    //         self.#container.contains(document.activeElement) &&
    //         document.activeElement.tagName !== "BUTTON" &&
    //         self.hasSomethingToControl();
    //     const textInputChecker = (_self, { target: el }) => {
    //         if (el instanceof HTMLInputElement) {
    //             const { type } = el;
    //             return type !== "text" && type !== "number";
    //         }
    //         return true;
    //     };
    //     const small = this.TRANSLATE_SMALL;
    //     const big = this.TRANSLATE_BIG;
    //     return shadow(
    //         this,
    //         "_keyboardManager",
    //         new KeyboardManager([
    //             [
    //                 ["ctrl+a", "mac+meta+a"],
    //                 proto.selectAll,
    //                 { checker: textInputChecker },
    //             ],
    //             [["ctrl+z", "mac+meta+z"], proto.undo, { checker: textInputChecker }],
    //             [
    //                 // On mac, depending of the OS version, the event.key is either "z" or
    //                 // "Z" when the user presses "meta+shift+z".
    //                 [
    //                     "ctrl+y",
    //                     "ctrl+shift+z",
    //                     "mac+meta+shift+z",
    //                     "ctrl+shift+Z",
    //                     "mac+meta+shift+Z",
    //                 ],
    //                 proto.redo,
    //                 { checker: textInputChecker },
    //             ],
    //             [
    //                 [
    //                     "Backspace",
    //                     "alt+Backspace",
    //                     "ctrl+Backspace",
    //                     "shift+Backspace",
    //                     "mac+Backspace",
    //                     "mac+alt+Backspace",
    //                     "mac+ctrl+Backspace",
    //                     "Delete",
    //                     "ctrl+Delete",
    //                     "shift+Delete",
    //                     "mac+Delete",
    //                 ],
    //                 proto.delete,
    //                 { checker: textInputChecker },
    //             ],
    //             [
    //                 ["Enter", "mac+Enter"],
    //                 proto.addNewEditorFromKeyboard,
    //                 {
    //                     // Those shortcuts can be used in the toolbar for some other actions
    //                     // like zooming, hence we need to check if the container has the
    //                     // focus.
    //                     checker: (self, { target: el }) =>
    //                         !(el instanceof HTMLButtonElement) &&
    //                         self.#container.contains(el) &&
    //                         !self.isEnterHandled,
    //                 },
    //             ],
    //             [
    //                 [" ", "mac+ "],
    //                 proto.addNewEditorFromKeyboard,
    //                 {
    //                     // Those shortcuts can be used in the toolbar for some other actions
    //                     // like zooming, hence we need to check if the container has the
    //                     // focus.
    //                     checker: (self, { target: el }) =>
    //                         !(el instanceof HTMLButtonElement) &&
    //                         self.#container.contains(document.activeElement),
    //                 },
    //             ],
    //             [["Escape", "mac+Escape"], proto.unselectAll],
    //             [
    //                 ["ArrowLeft", "mac+ArrowLeft"],
    //                 proto.translateSelectedEditors,
    //                 { args: [-small, 0], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
    //                 proto.translateSelectedEditors,
    //                 { args: [-big, 0], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ArrowRight", "mac+ArrowRight"],
    //                 proto.translateSelectedEditors,
    //                 { args: [small, 0], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
    //                 proto.translateSelectedEditors,
    //                 { args: [big, 0], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ArrowUp", "mac+ArrowUp"],
    //                 proto.translateSelectedEditors,
    //                 { args: [0, -small], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
    //                 proto.translateSelectedEditors,
    //                 { args: [0, -big], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ArrowDown", "mac+ArrowDown"],
    //                 proto.translateSelectedEditors,
    //                 { args: [0, small], checker: arrowChecker },
    //             ],
    //             [
    //                 ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
    //                 proto.translateSelectedEditors,
    //                 { args: [0, big], checker: arrowChecker },
    //             ],
    //         ])
    //     );
    // }
    constructor({ container = null, viewer, pdfViewer, 
    // altTextManager,
    eventBus, pdfDocument, 
    // pageColors,
    highlightColors = "",
    // enableHighlightFloatingButton,
    // enableUpdatedAddImage,
    // enableNewAltTextWhenAddingImage,
    // mlManager
     }) {
        _AnnotationEditorUIManager_instances.add(this);
        // todo: props
        // todo: extract to pdf viewer
        this.pdfViewer = null;
        this.annotationEditorMode = AnnotationEditorType.NONE;
        this.viewParameters = {};
        this.isShiftKeyDown = false;
        this._eventBus = null;
        // todo: props
        _AnnotationEditorUIManager_abortController.set(this, new AbortController());
        _AnnotationEditorUIManager_activeEditor.set(this, null);
        _AnnotationEditorUIManager_allEditors.set(this, new Map());
        _AnnotationEditorUIManager_allLayers.set(this, new Map());
        // #altTextManager = null;
        _AnnotationEditorUIManager_annotationStorage.set(this, null);
        _AnnotationEditorUIManager_changedExistingAnnotations.set(this, null);
        _AnnotationEditorUIManager_commandManager.set(this, new CommandManager());
        // #copyPasteAC = null;
        _AnnotationEditorUIManager_currentPageIndex.set(this, 0);
        _AnnotationEditorUIManager_deletedAnnotationsElementIds.set(this, new Set());
        _AnnotationEditorUIManager_draggingEditors.set(this, null);
        _AnnotationEditorUIManager_editorTypes.set(this, null);
        _AnnotationEditorUIManager_editorsToRescale.set(this, new Set());
        // todo: change default value
        // #enableHighlightFloatingButton = false;
        _AnnotationEditorUIManager_enableHighlightFloatingButton.set(this, true);
        // #enableUpdatedAddImage = false;
        // #enableNewAltTextWhenAddingImage = false;
        // #filterFactory = null;
        _AnnotationEditorUIManager_focusMainContainerTimeoutId.set(this, null);
        _AnnotationEditorUIManager_focusManagerAC.set(this, null);
        // todo: this is defined in "highlightEditorColors" in pdf.js as
        // value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
        _AnnotationEditorUIManager_highlightColors.set(this, "");
        _AnnotationEditorUIManager_highlightWhenShiftUp.set(this, false);
        _AnnotationEditorUIManager_highlightToolbar.set(this, null);
        _AnnotationEditorUIManager_idManager.set(this, new IdManager());
        _AnnotationEditorUIManager_isEnabled.set(this, false);
        _AnnotationEditorUIManager_isWaiting.set(this, false);
        // #keyboardManagerAC = null;
        _AnnotationEditorUIManager_lastActiveElement.set(this, null);
        // #mainHighlightColorPicker = null;
        // #mlManager = null;
        _AnnotationEditorUIManager_mode.set(this, AnnotationEditorType.NONE);
        _AnnotationEditorUIManager_selectedEditors.set(this, new Set());
        _AnnotationEditorUIManager_selectedTextNode.set(this, null);
        // #pageColors = null;
        _AnnotationEditorUIManager_showAllStates.set(this, null);
        _AnnotationEditorUIManager_previousStates.set(this, {
            isEditing: false,
            isEmpty: true,
            hasSomethingToUndo: false,
            hasSomethingToRedo: false,
            hasSelectedEditor: false,
            hasSelectedText: false,
        });
        _AnnotationEditorUIManager_translation.set(this, [0, 0]);
        _AnnotationEditorUIManager_translationTimeoutId.set(this, null);
        _AnnotationEditorUIManager_container.set(this, null);
        _AnnotationEditorUIManager_viewer.set(this, null);
        // // const signal = (this._signal = this.#abortController.signal);
        const signal = this._signal = __classPrivateFieldGet(this, _AnnotationEditorUIManager_abortController, "f").signal;
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_container, container, "f");
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_viewer, viewer, "f");
        this.pdfViewer = pdfViewer;
        // this.#altTextManager = altTextManager;
        this._eventBus = eventBus;
        this._eventBus._on("editingaction", this.onEditingAction.bind(this), {
            signal,
        });
        this._eventBus._on("pagechanging", this.onPageChanging.bind(this), {
            signal,
        });
        this._eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
            signal,
        });
        this._eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
            signal,
        });
        this._eventBus._on("setpreference", this.onSetPreference.bind(this), {
            signal,
        });
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addSelectionListener).call(this);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addDragAndDropListeners).call(this);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addKeyboardManager).call(this);
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_annotationStorage, pdfDocument.annotationStorage, "f");
        // this.#filterFactory = pdfDocument.filterFactory;
        // this.#pageColors = pageColors;
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_highlightColors, highlightColors || "", "f");
        // this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
        // this.#enableUpdatedAddImage = enableUpdatedAddImage;
        // this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
        // this.#mlManager = mlManager || null;
        this.viewParameters = {
            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: 0,
        };
        // this.isShiftKeyDown = false;
        // if ( typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
        //     window.uiManager = this;
        //     Object.defineProperty(this, "reset", {
        //         value: () => {
        //             this.selectAll();
        //             this.delete();
        //             this.#idManager.reset();
        //         },
        //     });
        // }
    }
    destroy() {
        var _a;
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_abortController, "f")) === null || _a === void 0 ? void 0 : _a.abort();
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_abortController, null, "f");
        this._signal = null;
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            layer.destroy();
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").clear();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").clear();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorsToRescale, "f").clear();
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_activeEditor, null, "f");
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").clear();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").destroy();
        // this.#altTextManager?.destroy();
        // this.#highlightToolbar?.hide();
        // this.#highlightToolbar = null;
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, "f")) {
            clearTimeout(__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, "f"));
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, null, "f");
        }
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_translationTimeoutId, "f")) {
            clearTimeout(__classPrivateFieldGet(this, _AnnotationEditorUIManager_translationTimeoutId, "f"));
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_translationTimeoutId, null, "f");
        }
    }
    // todo: new
    getTextLayerForAnchor(anchorElement) {
        if (!anchorElement) {
            return null;
        }
        return anchorElement.closest(".textLayer") || anchorElement.closest(".k-text-layer");
    }
    combinedSignal(abortSignal) {
        // eslint-disable-next-line
        if (AbortSignal && AbortSignal["any"]) {
            return AbortSignal.any([this._signal, abortSignal.signal]);
        }
        else {
            // add this for the unit tests
            // AbortSignal.any is an API since March 2024
            // however, this API is not currently available in
            // the node/jest-related bits version that we are using
            return this._signal || abortSignal.signal;
        }
    }
    // get mlManager() {
    //     return this.#mlManager;
    // }
    // get useNewAltTextFlow() {
    //     return this.#enableUpdatedAddImage;
    // }
    // get useNewAltTextWhenAddingImage() {
    //     return this.#enableNewAltTextWhenAddingImage;
    // }
    // get hcmFilter() {
    //     return shadow(
    //         this,
    //         "hcmFilter",
    //         this.#pageColors
    //             ? this.#filterFactory.addHCMFilter(
    //                 this.#pageColors.foreground,
    //                 this.#pageColors.background
    //             )
    //             : "none"
    //     );
    // }
    get direction() {
        return shadow(this, "direction", getComputedStyle(__classPrivateFieldGet(this, _AnnotationEditorUIManager_container, "f")).direction);
    }
    get highlightColors() {
        return shadow(this, "highlightColors", __classPrivateFieldGet(this, _AnnotationEditorUIManager_highlightColors, "f")
            ? new Map(
            // Array.from(
            //     this.#highlightColors
            //         .split(",")
            //         .map(pair => pair.split("=").map(x => x.trim()))
            // )
            )
            : null);
    }
    get highlightColorNames() {
        return shadow(this, "highlightColorNames", this.highlightColors
            ? new Map(Array.from(this.highlightColors, e => e.reverse()))
            : null);
    }
    // setMainHighlightColorPicker(colorPicker) {
    //     this.#mainHighlightColorPicker = colorPicker;
    // }
    // editAltText(editor, firstTime = false) {
    //     this.#altTextManager?.editAltText(this, editor, firstTime);
    // }
    switchToMode(mode, callback) {
        // Switching to a mode can be asynchronous.
        this._eventBus.on("annotationeditormodechanged", callback, {
            once: true,
            signal: this._signal,
            mode
        });
        this._eventBus.dispatch("showannotationeditorui", {
            source: this,
            mode,
        });
    }
    setPreference(name, value) {
        this._eventBus.dispatch("setpreference", {
            source: this,
            name,
            value,
        });
    }
    // onSetPreference({ name, value }) {
    onSetPreference({ name }) {
        switch (name) {
            case "enableNewAltTextWhenAddingImage":
                // this.#enableNewAltTextWhenAddingImage = value;
                break;
            default: break;
        }
    }
    onPageChanging({ pageNumber }) {
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_currentPageIndex, pageNumber - 1, "f");
    }
    focusMainContainer() {
        var _a;
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_container, "f")) === null || _a === void 0 ? void 0 : _a.focus();
    }
    findParent(x, y) {
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            const { x: layerX, y: layerY, width, height, } = layer.div.getBoundingClientRect();
            if (x >= layerX &&
                x <= layerX + width &&
                y >= layerY &&
                y <= layerY + height) {
                return layer;
            }
        }
        return null;
    }
    disableUserSelect(value = false) {
        var _a;
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_viewer, "f")) === null || _a === void 0 ? void 0 : _a.classList.toggle("noUserSelect", value);
    }
    addShouldRescale(editor) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorsToRescale, "f").add(editor);
    }
    removeShouldRescale(editor) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorsToRescale, "f").delete(editor);
    }
    onScaleChanging({ scale }) {
        this.commitOrRemove();
        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorsToRescale, "f")) {
            editor.onScaleChanging();
        }
    }
    onRotationChanging({ pagesRotation }) {
        this.commitOrRemove();
        this.viewParameters.rotation = pagesRotation;
    }
    highlightSelection(methodOfCreation = "") {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) {
            return;
        }
        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
        const text = selection.toString();
        const anchorElement = __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_getAnchorElementForSelection).call(this, selection);
        // const textLayer = anchorElement.closest(".textLayer");
        const textLayer = this.getTextLayerForAnchor(anchorElement);
        const boxes = this.getSelectionBoxes(textLayer);
        if (!boxes) {
            return;
        }
        selection.empty();
        const layer = __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_getLayerForTextLayer).call(this, textLayer);
        const isNoneMode = __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.NONE;
        const callback = () => {
            layer === null || layer === void 0 ? void 0 : layer.createAndAddNewEditor({ x: 0, y: 0 }, false, {
                methodOfCreation,
                boxes,
                anchorNode,
                anchorOffset,
                focusNode,
                focusOffset,
                text,
            });
            if (isNoneMode) {
                // this.showAllEditors("highlight", true, /* updateButton = */ true);
                this.showAllEditors("highlight", true);
            }
        };
        if (isNoneMode) {
            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
            return;
        }
        callback();
    }
    showEditorToolBar(anchor) {
        if (!anchor) {
            return;
        }
        // todo: disable showing a toolbar for other annotations
        const annotationEditorMode = this.getMode();
        if (annotationEditorMode === AnnotationEditorType.HIGHLIGHT) {
            const editor = anchor.closest(".highlightEditor");
            if (!editor) {
                return;
            }
        }
        if (annotationEditorMode === AnnotationEditorType.FREETEXT) {
            const editor = anchor.closest(".freeTextEditor");
            if (!editor) {
                return;
            }
        }
        if (annotationEditorMode !== AnnotationEditorType.HIGHLIGHT &&
            annotationEditorMode !== AnnotationEditorType.FREETEXT) {
            return;
        }
        this._eventBus.dispatch("kendoAnnotationEditorToolBarShow", {
            source: this,
            anchor: anchor
        });
    }
    hideEditorToolBar() {
        this._eventBus.dispatch("kendoAnnotationEditorToolBarHide", {
            source: this,
        });
    }
    /**
     * Add an editor in the annotation storage.
     * @param {AnnotationEditor} editor
     */
    addToAnnotationStorage(editor) {
        if (!editor.isEmpty() &&
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_annotationStorage, "f") &&
            !__classPrivateFieldGet(this, _AnnotationEditorUIManager_annotationStorage, "f").has(editor.id)) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_annotationStorage, "f").setValue(editor.id, editor);
        }
    }
    blur() {
        this.isShiftKeyDown = false;
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_highlightWhenShiftUp, "f")) {
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_highlightWhenShiftUp, false, "f");
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_onSelectEnd).call(this, "main_toolbar");
        }
        if (!this.hasSelection) {
            return;
        }
        // When several editors are selected and the window loses focus, we want to
        // keep the last active element in order to be able to focus it again when
        // the window gets the focus back but we don't want to trigger any focus
        // callbacks else only one editor will be selected.
        const { activeElement } = document;
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            if (editor.div.contains(activeElement)) {
                __classPrivateFieldSet(this, _AnnotationEditorUIManager_lastActiveElement, [editor, activeElement], "f");
                editor._focusEventsAllowed = false;
                break;
            }
        }
    }
    focus() {
        if (!__classPrivateFieldGet(this, _AnnotationEditorUIManager_lastActiveElement, "f")) {
            return;
        }
        const [lastEditor, lastActiveElement] = __classPrivateFieldGet(this, _AnnotationEditorUIManager_lastActiveElement, "f");
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_lastActiveElement, null, "f");
        lastActiveElement.addEventListener("focusin", () => {
            lastEditor._focusEventsAllowed = true;
        }, { once: true, signal: this._signal });
        lastActiveElement.focus();
    }
    addEditListeners() {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addKeyboardManager).call(this);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addCopyPasteListeners).call(this);
    }
    removeEditListeners() {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_removeKeyboardManager).call(this);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_removeCopyPasteListeners).call(this);
    }
    dragOver(event) {
        for (const { type } of event.dataTransfer.items) {
            for (const editorType of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
                if (editorType.isHandlingMimeForPasting(type)) {
                    event.dataTransfer.dropEffect = "copy";
                    event.preventDefault();
                    return;
                }
            }
        }
    }
    /**
     * Drop callback.
     * @param {DragEvent} event
     */
    drop(event) {
        for (const item of event.dataTransfer.items) {
            for (const editorType of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
                if (editorType.isHandlingMimeForPasting(item.type)) {
                    editorType.paste(item, this.currentLayer);
                    event.preventDefault();
                    return;
                }
            }
        }
    }
    /**
     * Copy callback.
     * @param {ClipboardEvent} event
     */
    copy(event) {
        var _a;
        event.preventDefault();
        // An editor is being edited so just commit it.
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f")) === null || _a === void 0 ? void 0 : _a.commitOrRemove();
        if (!this.hasSelection) {
            return;
        }
        const editors = [];
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            const serialized = editor.serialize(/* isForCopying = */ true);
            if (serialized) {
                editors.push(serialized);
            }
        }
        if (editors.length === 0) {
            return;
        }
        event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
    }
    /**
     * Cut callback.
     * @param {ClipboardEvent} event
     */
    cut(event) {
        this.copy(event);
        this.delete();
    }
    /**
     * Paste callback.
     * @param {ClipboardEvent} event
     */
    paste(event) {
        event.preventDefault();
        const { clipboardData } = event;
        for (const item of clipboardData.items) {
            for (const editorType of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
                if (editorType.isHandlingMimeForPasting(item.type)) {
                    editorType.paste(item, this.currentLayer);
                    return;
                }
            }
        }
        let data = clipboardData.getData("application/pdfjs");
        if (!data) {
            return;
        }
        try {
            data = JSON.parse(data);
        }
        catch (ex) {
            // warn(`paste: "${ex.message}".`);
            return;
        }
        if (!Array.isArray(data)) {
            return;
        }
        this.unselectAll();
        const layer = this.currentLayer;
        try {
            const newEditors = [];
            for (const editor of data) {
                const deserializedEditor = layer.deserialize(editor);
                if (!deserializedEditor) {
                    return;
                }
                newEditors.push(deserializedEditor);
            }
            const cmd = () => {
                for (const editor of newEditors) {
                    __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addEditorToLayer).call(this, editor);
                }
                __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_selectEditors).call(this, newEditors);
            };
            const undo = () => {
                for (const editor of newEditors) {
                    editor.remove();
                }
            };
            this.addCommands({ cmd, undo, mustExec: true });
        }
        catch (ex) {
            // warn(`paste: "${ex.message}".`);
        }
    }
    // /**
    //  * Keydown callback.
    //  * @param {KeyboardEvent} event
    //  */
    // keydown(event) {
    //     if (!this.isShiftKeyDown && event.key === "Shift") {
    //         this.isShiftKeyDown = true;
    //     }
    //     if (
    //         this.#mode !== AnnotationEditorType.NONE &&
    //         !this.isEditorHandlingKeyboard
    //     ) {
    //         AnnotationEditorUIManager._keyboardManager.exec(this, event);
    //     }
    // }
    // /**
    //  * Keyup callback.
    //  * @param {KeyboardEvent} event
    //  */
    // keyup(event) {
    //     if (this.isShiftKeyDown && event.key === "Shift") {
    //         this.isShiftKeyDown = false;
    //         if (this.#highlightWhenShiftUp) {
    //             this.#highlightWhenShiftUp = false;
    //             this.#onSelectEnd("main_toolbar");
    //         }
    //     }
    // }
    /**
     * Execute an action for a given name.
     * For example, the user can click on the "Undo" entry in the context menu
     * and it'll trigger the undo action.
     */
    onEditingAction({ name }) {
        switch (name) {
            case "undo":
            case "redo":
            case "delete":
            case "selectAll":
                this[name]();
                break;
            case "highlightSelection":
                this.highlightSelection("context_menu");
                break;
            default: break;
        }
    }
    /**
     * Set the editing state.
     * It can be useful to temporarily disable it when the user is editing a
     * FreeText annotation.
     * @param {boolean} isEditing
     */
    setEditingState(isEditing) {
        // setEditingState() {
        if (isEditing) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addFocusManager).call(this);
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addCopyPasteListeners).call(this);
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
                isEditing: __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") !== AnnotationEditorType.NONE,
                isEmpty: __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_isEmpty).call(this),
                hasSomethingToUndo: __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").hasSomethingToUndo(),
                hasSomethingToRedo: __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").hasSomethingToRedo(),
                hasSelectedEditor: false,
            });
        }
        else {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_removeFocusManager).call(this);
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_removeCopyPasteListeners).call(this);
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
                isEditing: false,
            });
            this.disableUserSelect(false);
        }
    }
    registerEditorTypes(types) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
            return;
        }
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_editorTypes, types, "f");
        for (const editorType of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, editorType.defaultPropertiesToUpdate);
        }
    }
    /**
     * Get an id.
     * @returns {string}
     */
    getId() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_idManager, "f").id;
    }
    get currentLayer() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").get(__classPrivateFieldGet(this, _AnnotationEditorUIManager_currentPageIndex, "f"));
    }
    getLayer(pageIndex) {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").get(pageIndex);
    }
    get currentPageIndex() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_currentPageIndex, "f");
    }
    /**
     * Add a new layer for a page which will contains the editors.
     * @param {AnnotationEditorLayer} layer
     */
    addLayer(layer) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").set(layer.pageIndex, layer);
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_isEnabled, "f")) {
            layer.enable();
        }
        else {
            layer.disable();
        }
    }
    /**
     * Remove a layer.
     * @param {AnnotationEditorLayer} layer
     */
    removeLayer(layer) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").delete(layer.pageIndex);
    }
    /**
     * Change the editor mode (None, FreeText, Ink, ...)
     * @param {number} mode
     * @param {string|null} editId
     * @param {boolean} [isFromKeyboard] - true if the mode change is due to a
     *   keyboard action.
     */
    updateMode(mode, editId = null, isFromKeyboard = false) {
        // todo: set isFromKeyboard intentionally to allow editor creation
        // updateMode(mode, editId = null, isFromKeyboard = true) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === mode) {
            return;
        }
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_mode, mode, "f");
        if (mode === AnnotationEditorType.NONE) {
            this.setEditingState(false);
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_disableAll).call(this);
            return;
        }
        this.setEditingState(true);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_enableAll).call(this);
        this.unselectAll();
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            layer.updateMode(mode);
        }
        if (!editId && isFromKeyboard) {
            this.addNewEditorFromKeyboard();
            return;
        }
        if (!editId) {
            return;
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            if (editor.annotationElementId === editId) {
                this.setSelected(editor);
                editor.enterInEditMode();
                break;
            }
        }
    }
    addNewEditorFromKeyboard() {
        if (this.currentLayer.canCreateNewEmptyEditor()) {
            this.currentLayer.addNewEditor();
        }
    }
    /**
     * Update the toolbar if it's required to reflect the tool currently used.
     * @param {number} mode
     * @returns {undefined}
     */
    updateToolbar(mode) {
        if (mode === __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f")) {
            return;
        }
        this._eventBus.dispatch("switchannotationeditormode", {
            source: this,
            mode,
        });
    }
    /**
     * Update a parameter in the current editor or globally.
     * @param {number} type
     * @param {*} value
     */
    updateParams(type, value) {
        if (!__classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
            return;
        }
        switch (type) {
            case AnnotationEditorParamsType.CREATE:
                this.currentLayer.addNewEditor();
                return;
            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
                // this.#mainHighlightColorPicker?.updateColor(value);
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
                // this._eventBus.dispatch("reporttelemetry", {
                //     source: this,
                //     details: {
                //         type: "editing",
                //         data: {
                //             type: "highlight",
                //             action: "toggle_visibility",
                //         },
                //     },
                // });
                (__classPrivateFieldSet(this, _AnnotationEditorUIManager_showAllStates, __classPrivateFieldGet(this, _AnnotationEditorUIManager_showAllStates, "f") || new Map(), "f")).set(type, value);
                this.showAllEditors("highlight", value);
                break;
            default: break;
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            editor.updateParams(type, value);
        }
        for (const editorType of __classPrivateFieldGet(this, _AnnotationEditorUIManager_editorTypes, "f")) {
            editorType.updateDefaultParams(type, value);
        }
    }
    // showAllEditors(type, visible, updateButton = false) {
    showAllEditors(type, visible) {
        var _a, _b;
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            if (editor.editorType === type) {
                editor.show(visible);
            }
        }
        const state = (_b = (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_showAllStates, "f")) === null || _a === void 0 ? void 0 : _a.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL)) !== null && _b !== void 0 ? _b : true;
        if (state !== visible) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, [
                [AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible],
            ]);
        }
    }
    enableWaiting(mustWait = false) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_isWaiting, "f") === mustWait) {
            return;
        }
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_isWaiting, mustWait, "f");
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            if (mustWait) {
                layer.disableClick();
            }
            else {
                layer.enableClick();
            }
            layer.div.classList.toggle("waiting", mustWait);
        }
    }
    /**
     * Get all the editors belonging to a given page.
     * @param {number} pageIndex
     * @returns {Array<AnnotationEditor>}
     */
    getEditors(pageIndex) {
        const editors = [];
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            if (editor.pageIndex === pageIndex) {
                editors.push(editor);
            }
        }
        return editors;
    }
    /**
     * Get an editor with the given id.
     * @param {string} id
     * @returns {AnnotationEditor}
     */
    getEditor(id) {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").get(id);
    }
    /**
     * Add a new editor.
     * @param {AnnotationEditor} editor
     */
    addEditor(editor) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").set(editor.id, editor);
    }
    /**
     * Remove an editor.
     * @param {AnnotationEditor} editor
     */
    removeEditor(editor) {
        var _a;
        if (editor.div.contains(document.activeElement)) {
            if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, "f")) {
                clearTimeout(__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, "f"));
            }
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, setTimeout(() => {
                // When the div is removed from DOM the focus can move on the
                // document.body, so we need to move it back to the main container.
                this.focusMainContainer();
                __classPrivateFieldSet(this, _AnnotationEditorUIManager_focusMainContainerTimeoutId, null, "f");
            }, 0), "f");
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").delete(editor.id);
        this.unselect(editor);
        if (!editor.annotationElementId ||
            !__classPrivateFieldGet(this, _AnnotationEditorUIManager_deletedAnnotationsElementIds, "f").has(editor.annotationElementId)) {
            (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_annotationStorage, "f")) === null || _a === void 0 ? void 0 : _a.remove(editor.id);
        }
    }
    /**
     * The annotation element with the given id has been deleted.
     * @param {AnnotationEditor} editor
     */
    addDeletedAnnotationElement(editor) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_deletedAnnotationsElementIds, "f").add(editor.annotationElementId);
        this.addChangedExistingAnnotation(editor);
        editor.deleted = true;
    }
    /**
     * Check if the annotation element with the given id has been deleted.
     * @param {string} annotationElementId
     * @returns {boolean}
     */
    isDeletedAnnotationElement(annotationElementId) {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_deletedAnnotationsElementIds, "f").has(annotationElementId);
    }
    /**
     * The annotation element with the given id have been restored.
     * @param {AnnotationEditor} editor
     */
    removeDeletedAnnotationElement(editor) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_deletedAnnotationsElementIds, "f").delete(editor.annotationElementId);
        this.removeChangedExistingAnnotation(editor);
        editor.deleted = false;
    }
    /**
     * Set the given editor as the active one.
     * @param {AnnotationEditor} editor
     */
    setActiveEditor(editor) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f") === editor) {
            return;
        }
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_activeEditor, editor, "f");
        if (editor) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, editor.propertiesToUpdate);
        }
    }
    /**
     * Update the UI of the active editor.
     * @param {AnnotationEditor} editor
     */
    updateUI(editor) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "a", _AnnotationEditorUIManager_lastSelectedEditor_get) === editor) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, editor.propertiesToUpdate);
        }
    }
    /**
     * Add or remove an editor the current selection.
     * @param {AnnotationEditor} editor
     */
    toggleSelected(editor) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").has(editor)) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").delete(editor);
            editor.unselect();
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
                hasSelectedEditor: this.hasSelection,
            });
            return;
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").add(editor);
        editor.select();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, editor.propertiesToUpdate);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSelectedEditor: true,
        });
    }
    /**
     * Set the last selected editor.
     * @param {AnnotationEditor} editor
     */
    setSelected(editor) {
        for (const selectedEditor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            if (selectedEditor !== editor) {
                selectedEditor.unselect();
            }
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").clear();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").add(editor);
        editor.select();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, editor.propertiesToUpdate);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSelectedEditor: true,
        });
    }
    /**
     * Check if the editor is selected.
     * @param {AnnotationEditor} editor
     */
    isSelected(editor) {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").has(editor);
    }
    get firstSelectedEditor() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").values().next().value;
    }
    /**
     * Unselect an editor.
     * @param {AnnotationEditor} editor
     */
    unselect(editor) {
        editor.unselect();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").delete(editor);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSelectedEditor: this.hasSelection,
        });
    }
    get hasSelection() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").size !== 0;
    }
    get isEnterHandled() {
        return (__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").size === 1 &&
            this.firstSelectedEditor.isEnterHandled);
    }
    /**
     * Undo the last command.
     */
    undo() {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").undo();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSomethingToUndo: __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").hasSomethingToUndo(),
            hasSomethingToRedo: true,
            isEmpty: __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_isEmpty).call(this),
        });
    }
    /**
     * Redo the last undoed command.
     */
    redo() {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").redo();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSomethingToUndo: true,
            hasSomethingToRedo: __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").hasSomethingToRedo(),
            isEmpty: __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_isEmpty).call(this),
        });
    }
    /**
     * Add a command to execute (cmd) and another one to undo it.
     * @param {Object} params
     */
    addCommands(params) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_commandManager, "f").add(params);
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSomethingToUndo: true,
            hasSomethingToRedo: false,
            isEmpty: __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_isEmpty).call(this),
        });
    }
    /**
     * Delete the current editor or all.
     */
    delete() {
        this.commitOrRemove();
        if (!this.hasSelection) {
            return;
        }
        const editors = [...__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")];
        const cmd = () => {
            for (const editor of editors) {
                editor.remove();
            }
        };
        const undo = () => {
            for (const editor of editors) {
                __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_addEditorToLayer).call(this, editor);
            }
        };
        this.addCommands({ cmd, undo, mustExec: true });
    }
    commitOrRemove() {
        var _a;
        // An editor is being edited so just commit it.
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f")) === null || _a === void 0 ? void 0 : _a.commitOrRemove();
    }
    hasSomethingToControl() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f") || this.hasSelection;
    }
    /**
     * Select all the editors.
     */
    selectAll() {
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            editor.commit();
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_selectEditors).call(this, __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values());
    }
    /**
     * Unselect all the selected editors.
     */
    unselectAll() {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f")) {
            // An editor is being edited so just commit it.
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f").commitOrRemove();
            if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") !== AnnotationEditorType.NONE) {
                // If the mode is NONE, we want to really unselect the editor, hence we
                // mustn't return here.
                return;
            }
        }
        if (!this.hasSelection) {
            return;
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            editor.unselect();
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").clear();
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
            hasSelectedEditor: false,
        });
    }
    translateSelectedEditors(x, y, noCommit = false) {
        if (!noCommit) {
            this.commitOrRemove();
        }
        if (!this.hasSelection) {
            return;
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_translation, "f")[0] += x;
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_translation, "f")[1] += y;
        const [totalX, totalY] = __classPrivateFieldGet(this, _AnnotationEditorUIManager_translation, "f");
        const editors = [...__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")];
        // We don't want to have an undo/redo for each translation so we wait a bit
        // before adding the command to the command manager.
        const TIME_TO_WAIT = 1000;
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_translationTimeoutId, "f")) {
            clearTimeout(__classPrivateFieldGet(this, _AnnotationEditorUIManager_translationTimeoutId, "f"));
        }
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_translationTimeoutId, setTimeout(() => {
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_translationTimeoutId, null, "f");
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_translation, "f")[0] = __classPrivateFieldGet(this, _AnnotationEditorUIManager_translation, "f")[1] = 0;
            this.addCommands({
                cmd: () => {
                    for (const editor of editors) {
                        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").has(editor.id)) {
                            editor.translateInPage(totalX, totalY);
                        }
                    }
                },
                undo: () => {
                    for (const editor of editors) {
                        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").has(editor.id)) {
                            editor.translateInPage(-totalX, -totalY);
                        }
                    }
                },
                mustExec: false,
            });
        }, TIME_TO_WAIT), "f");
        for (const editor of editors) {
            editor.translateInPage(x, y);
        }
    }
    /**
     * Set up the drag session for moving the selected editors.
     */
    setUpDragSession() {
        // // Note: don't use any references to the editor's parent which can be null
        // // if the editor belongs to a destroyed page.
        if (!this.hasSelection) {
            return;
        }
        // Avoid to have spurious text selection in the text layer when dragging.
        this.disableUserSelect(true);
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_draggingEditors, new Map(), "f");
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_draggingEditors, "f").set(editor, {
                savedX: editor.x,
                savedY: editor.y,
                savedPageIndex: editor.pageIndex,
                newX: 0,
                newY: 0,
                newPageIndex: -1,
            });
        }
    }
    /**
     * Ends the drag session.
     * @returns {boolean} true if at least one editor has been moved.
     */
    endDragSession() {
        if (!__classPrivateFieldGet(this, _AnnotationEditorUIManager_draggingEditors, "f")) {
            return false;
        }
        this.disableUserSelect(false);
        const map = __classPrivateFieldGet(this, _AnnotationEditorUIManager_draggingEditors, "f");
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_draggingEditors, null, "f");
        let mustBeAddedInUndoStack = false;
        for (const [{ x, y, pageIndex }, value] of map) {
            value.newX = x;
            value.newY = y;
            value.newPageIndex = pageIndex;
            mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x !== value.savedX ||
                y !== value.savedY ||
                pageIndex !== value.savedPageIndex);
        }
        if (!mustBeAddedInUndoStack) {
            return false;
        }
        const move = (editor, x, y, pageIndex) => {
            if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").has(editor.id)) {
                // The editor can be undone/redone on a page which is not visible (and
                // which potentially has no annotation editor layer), hence we need to
                // use the pageIndex instead of the parent.
                const parent = __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").get(pageIndex);
                if (parent) {
                    editor._setParentAndPosition(parent, x, y);
                }
                else {
                    editor.pageIndex = pageIndex;
                    editor.x = x;
                    editor.y = y;
                }
            }
        };
        this.addCommands({
            cmd: () => {
                for (const [editor, { newX, newY, newPageIndex }] of map) {
                    move(editor, newX, newY, newPageIndex);
                }
            },
            undo: () => {
                for (const [editor, { savedX, savedY, savedPageIndex }] of map) {
                    move(editor, savedX, savedY, savedPageIndex);
                }
            },
            mustExec: true,
        });
        return true;
    }
    /**
     * Drag the set of selected editors.
     * @param {number} tx
     * @param {number} ty
     */
    dragSelectedEditors(tx, ty) {
        if (!__classPrivateFieldGet(this, _AnnotationEditorUIManager_draggingEditors, "f")) {
            return;
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_draggingEditors, "f").keys()) {
            editor.drag(tx, ty);
        }
    }
    /**
     * Rebuild the editor (usually on undo/redo actions) on a potentially
     * non-rendered page.
     * @param {AnnotationEditor} editor
     */
    rebuild(editor) {
        if (editor.parent === null) {
            const parent = this.getLayer(editor.pageIndex);
            if (parent) {
                parent.changeParent(editor);
                parent.addOrRebuild(editor);
            }
            else {
                this.addEditor(editor);
                this.addToAnnotationStorage(editor);
                editor.rebuild();
            }
        }
        else {
            editor.parent.addOrRebuild(editor);
        }
    }
    // get isEditorHandlingKeyboard() {
    //     return (
    //         this.getActive()?.shouldGetKeyboardEvents() ||
    //         (this.#selectedEditors.size === 1 &&
    //             this.firstSelectedEditor.shouldGetKeyboardEvents())
    //     );
    // }
    /**
     * Is the current editor the one passed as argument?
     * @param {AnnotationEditor} editor
     * @returns
     */
    isActive(editor) {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f") === editor;
    }
    /**
     * Get the current active editor.
     * @returns {AnnotationEditor|null}
     */
    getActive() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f");
    }
    getActiveEditor() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_activeEditor, "f");
    }
    /**
     * Get the current editor mode.
     * @returns {number}
     */
    getMode() {
        return __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f");
    }
    // get imageManager() {
    //     return shadow(this, "imageManager", new ImageManager());
    // }
    getSelectionBoxes(textLayer) {
        if (!textLayer) {
            return null;
        }
        const selection = document.getSelection();
        for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
                return null;
            }
        }
        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight, } = textLayer.getBoundingClientRect();
        // We must rotate the boxes because we want to have them in the non-rotated
        // page coordinates.
        let rotator;
        switch (textLayer.getAttribute("data-main-rotation")) {
            case "90":
                rotator = (x, y, w, h) => ({
                    x: (y - layerY) / parentHeight,
                    y: 1 - (x + w - layerX) / parentWidth,
                    width: h / parentHeight,
                    height: w / parentWidth,
                });
                break;
            case "180":
                rotator = (x, y, w, h) => ({
                    x: 1 - (x + w - layerX) / parentWidth,
                    y: 1 - (y + h - layerY) / parentHeight,
                    width: w / parentWidth,
                    height: h / parentHeight,
                });
                break;
            case "270":
                rotator = (x, y, w, h) => ({
                    x: 1 - (y + h - layerY) / parentHeight,
                    y: (x - layerX) / parentWidth,
                    width: h / parentHeight,
                    height: w / parentWidth,
                });
                break;
            default:
                rotator = (x, y, w, h) => ({
                    x: (x - layerX) / parentWidth,
                    y: (y - layerY) / parentHeight,
                    width: w / parentWidth,
                    height: h / parentHeight,
                });
                break;
        }
        const boxes = [];
        for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
            const range = selection.getRangeAt(i);
            if (range.collapsed) {
                continue;
            }
            for (const { x, y, width, height } of range.getClientRects()) {
                if (width === 0 || height === 0) {
                    continue;
                }
                boxes.push(rotator(x, y, width, height));
            }
        }
        return boxes.length === 0 ? null : boxes;
    }
    addChangedExistingAnnotation({ annotationElementId, id }) {
        (__classPrivateFieldSet(this, _AnnotationEditorUIManager_changedExistingAnnotations, __classPrivateFieldGet(this, _AnnotationEditorUIManager_changedExistingAnnotations, "f") || new Map(), "f")).set(annotationElementId, id);
    }
    removeChangedExistingAnnotation({ annotationElementId }) {
        var _a;
        (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_changedExistingAnnotations, "f")) === null || _a === void 0 ? void 0 : _a.delete(annotationElementId);
    }
    renderAnnotationElement(annotation) {
        var _a;
        const editorId = (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_changedExistingAnnotations, "f")) === null || _a === void 0 ? void 0 : _a.get(annotation.data.id);
        if (!editorId) {
            return;
        }
        const editor = __classPrivateFieldGet(this, _AnnotationEditorUIManager_annotationStorage, "f").getRawValue(editorId);
        if (!editor) {
            return;
        }
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.NONE && !editor.hasBeenModified) {
            return;
        }
        editor.renderAnnotationElement(annotation);
    }
}
_AnnotationEditorUIManager_abortController = new WeakMap(), _AnnotationEditorUIManager_activeEditor = new WeakMap(), _AnnotationEditorUIManager_allEditors = new WeakMap(), _AnnotationEditorUIManager_allLayers = new WeakMap(), _AnnotationEditorUIManager_annotationStorage = new WeakMap(), _AnnotationEditorUIManager_changedExistingAnnotations = new WeakMap(), _AnnotationEditorUIManager_commandManager = new WeakMap(), _AnnotationEditorUIManager_currentPageIndex = new WeakMap(), _AnnotationEditorUIManager_deletedAnnotationsElementIds = new WeakMap(), _AnnotationEditorUIManager_draggingEditors = new WeakMap(), _AnnotationEditorUIManager_editorTypes = new WeakMap(), _AnnotationEditorUIManager_editorsToRescale = new WeakMap(), _AnnotationEditorUIManager_enableHighlightFloatingButton = new WeakMap(), _AnnotationEditorUIManager_focusMainContainerTimeoutId = new WeakMap(), _AnnotationEditorUIManager_focusManagerAC = new WeakMap(), _AnnotationEditorUIManager_highlightColors = new WeakMap(), _AnnotationEditorUIManager_highlightWhenShiftUp = new WeakMap(), _AnnotationEditorUIManager_highlightToolbar = new WeakMap(), _AnnotationEditorUIManager_idManager = new WeakMap(), _AnnotationEditorUIManager_isEnabled = new WeakMap(), _AnnotationEditorUIManager_isWaiting = new WeakMap(), _AnnotationEditorUIManager_lastActiveElement = new WeakMap(), _AnnotationEditorUIManager_mode = new WeakMap(), _AnnotationEditorUIManager_selectedEditors = new WeakMap(), _AnnotationEditorUIManager_selectedTextNode = new WeakMap(), _AnnotationEditorUIManager_showAllStates = new WeakMap(), _AnnotationEditorUIManager_previousStates = new WeakMap(), _AnnotationEditorUIManager_translation = new WeakMap(), _AnnotationEditorUIManager_translationTimeoutId = new WeakMap(), _AnnotationEditorUIManager_container = new WeakMap(), _AnnotationEditorUIManager_viewer = new WeakMap(), _AnnotationEditorUIManager_instances = new WeakSet(), _AnnotationEditorUIManager_getAnchorElementForSelection = function _AnnotationEditorUIManager_getAnchorElementForSelection({ anchorNode }) {
    return anchorNode.nodeType === Node.TEXT_NODE
        ? anchorNode.parentElement
        : anchorNode;
}, _AnnotationEditorUIManager_getLayerForTextLayer = function _AnnotationEditorUIManager_getLayerForTextLayer(textLayer) {
    const { currentLayer } = this;
    if (currentLayer.hasTextLayer(textLayer)) {
        return currentLayer;
    }
    for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
        if (layer.hasTextLayer(textLayer)) {
            return layer;
        }
    }
    return null;
}, _AnnotationEditorUIManager_displayHighlightToolbar = function _AnnotationEditorUIManager_displayHighlightToolbar() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
        return;
    }
    const anchorElement = __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_getAnchorElementForSelection).call(this, selection);
    const textLayer = this.getTextLayerForAnchor(anchorElement);
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
        return;
    }
    this.showEditorToolBar(anchorElement);
    // this._eventBus.dispatch("showannotationeditorui", {
    //     source: this,
    //     details: Object.assign(this.#previousStates, details),
    // });
    // this.#highlightToolbar ||= new HighlightToolbar(this);
    // this.#highlightToolbar.show(textLayer, boxes, this.direction === "ltr");
}, _AnnotationEditorUIManager_selectionChange = function _AnnotationEditorUIManager_selectionChange() {
    var _a, _b;
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedTextNode, "f")) {
            // this.#highlightToolbar?.hide();
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_selectedTextNode, null, "f");
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
                hasSelectedText: false,
            });
        }
        return;
    }
    const { anchorNode } = selection;
    if (anchorNode === __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedTextNode, "f")) {
        return;
    }
    const anchorElement = __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_getAnchorElementForSelection).call(this, selection);
    // const textLayer = anchorElement.closest(".textLayer");
    const textLayer = this.getTextLayerForAnchor(anchorElement);
    if (!textLayer) {
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedTextNode, "f")) {
            (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_highlightToolbar, "f")) === null || _a === void 0 ? void 0 : _a.hide();
            __classPrivateFieldSet(this, _AnnotationEditorUIManager_selectedTextNode, null, "f");
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
                hasSelectedText: false,
            });
        }
        return;
    }
    (_b = __classPrivateFieldGet(this, _AnnotationEditorUIManager_highlightToolbar, "f")) === null || _b === void 0 ? void 0 : _b.hide();
    __classPrivateFieldSet(this, _AnnotationEditorUIManager_selectedTextNode, anchorNode, "f");
    __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, {
        hasSelectedText: true,
    });
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") !== AnnotationEditorType.HIGHLIGHT && __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") !== AnnotationEditorType.NONE) {
        return;
    }
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.HIGHLIGHT) {
        // this.showAllEditors("highlight", true, /* updateButton = */ true);
        this.showAllEditors("highlight", true);
    }
    // this.#highlightWhenShiftUp = this.isShiftKeyDown;
    if (!this.isShiftKeyDown) {
        const activeLayer = __classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.HIGHLIGHT
            ? __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_getLayerForTextLayer).call(this, textLayer)
            : null;
        activeLayer === null || activeLayer === void 0 ? void 0 : activeLayer.toggleDrawing();
        const abortController = new AbortController();
        const signal = this.combinedSignal(abortController);
        const pointerup = e => {
            if (e.type === "pointerup" && e.button !== 0) {
                // Do nothing on right click.
                return;
            }
            abortController.abort();
            activeLayer === null || activeLayer === void 0 ? void 0 : activeLayer.toggleDrawing(true);
            if (e.type === "pointerup") {
                __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_onSelectEnd).call(this, "main_toolbar");
            }
        };
        window.removeEventListener("pointerup", pointerup);
        window.addEventListener("pointerup", pointerup, { signal });
        window.removeEventListener("blur", pointerup);
        window.addEventListener("blur", pointerup, { signal });
    }
}, _AnnotationEditorUIManager_onSelectEnd = function _AnnotationEditorUIManager_onSelectEnd(methodOfCreation = "") {
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.HIGHLIGHT) {
        this.highlightSelection(methodOfCreation);
    }
    else if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_enableHighlightFloatingButton, "f")) {
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_displayHighlightToolbar).call(this);
    }
}, _AnnotationEditorUIManager_addSelectionListener = function _AnnotationEditorUIManager_addSelectionListener() {
    document.addEventListener("selectionchange", __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_selectionChange).bind(this), { signal: this._signal });
}, _AnnotationEditorUIManager_addFocusManager = function _AnnotationEditorUIManager_addFocusManager() {
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusManagerAC, "f")) {
        return;
    }
    __classPrivateFieldSet(this, _AnnotationEditorUIManager_focusManagerAC, new AbortController(), "f");
    const signal = this.combinedSignal(__classPrivateFieldGet(this, _AnnotationEditorUIManager_focusManagerAC, "f"));
    window.addEventListener("focus", this.focus.bind(this), { signal });
    window.addEventListener("blur", this.blur.bind(this), { signal });
}, _AnnotationEditorUIManager_removeFocusManager = function _AnnotationEditorUIManager_removeFocusManager() {
    var _a;
    (_a = __classPrivateFieldGet(this, _AnnotationEditorUIManager_focusManagerAC, "f")) === null || _a === void 0 ? void 0 : _a.abort();
    __classPrivateFieldSet(this, _AnnotationEditorUIManager_focusManagerAC, null, "f");
}, _AnnotationEditorUIManager_addKeyboardManager = function _AnnotationEditorUIManager_addKeyboardManager() {
    //     if (this.#keyboardManagerAC) {
    //         return;
    //     }
    //     this.#keyboardManagerAC = new AbortController();
    //     const signal = this.combinedSignal(this.#keyboardManagerAC);
    //     // The keyboard events are caught at the container level in order to be able
    //     // to execute some callbacks even if the current page doesn't have focus.
    //     window.addEventListener("keydown", this.keydown.bind(this), { signal });
    //     window.addEventListener("keyup", this.keyup.bind(this), { signal });
}, _AnnotationEditorUIManager_removeKeyboardManager = function _AnnotationEditorUIManager_removeKeyboardManager() {
    //     this.#keyboardManagerAC?.abort();
    //     this.#keyboardManagerAC = null;
}, _AnnotationEditorUIManager_addCopyPasteListeners = function _AnnotationEditorUIManager_addCopyPasteListeners() {
    //     if (this.#copyPasteAC) {
    //         return;
    //     }
    //     this.#copyPasteAC = new AbortController();
    //     const signal = this.combinedSignal(this.#copyPasteAC);
    //     document.addEventListener("copy", this.copy.bind(this), { signal });
    //     document.addEventListener("cut", this.cut.bind(this), { signal });
    //     document.addEventListener("paste", this.paste.bind(this), { signal });
}, _AnnotationEditorUIManager_removeCopyPasteListeners = function _AnnotationEditorUIManager_removeCopyPasteListeners() {
    //     this.#copyPasteAC?.abort();
    //     this.#copyPasteAC = null;
}, _AnnotationEditorUIManager_addDragAndDropListeners = function _AnnotationEditorUIManager_addDragAndDropListeners() {
    const signal = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), { signal });
    document.addEventListener("drop", this.drop.bind(this), { signal });
}, _AnnotationEditorUIManager_dispatchUpdateStates = function _AnnotationEditorUIManager_dispatchUpdateStates(details) {
    if (!details) {
        return;
    }
    const hasChanged = Object.entries(details).some(([key, value]) => __classPrivateFieldGet(this, _AnnotationEditorUIManager_previousStates, "f")[key] !== value);
    if (hasChanged) {
        this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(__classPrivateFieldGet(this, _AnnotationEditorUIManager_previousStates, "f"), details),
        });
        // We could listen on our own event but it sounds like a bit weird and
        // it's a way to simpler to handle that stuff here instead of having to
        // add something in every place where an editor can be unselected.
        if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_mode, "f") === AnnotationEditorType.HIGHLIGHT &&
            details.hasSelectedEditor === false) {
            __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateUI).call(this, [
                [AnnotationEditorParamsType.HIGHLIGHT_FREE, true],
            ]);
        }
    }
}, _AnnotationEditorUIManager_dispatchUpdateUI = function _AnnotationEditorUIManager_dispatchUpdateUI(details) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
        source: this,
        details,
    });
}, _AnnotationEditorUIManager_enableAll = function _AnnotationEditorUIManager_enableAll() {
    if (!__classPrivateFieldGet(this, _AnnotationEditorUIManager_isEnabled, "f")) {
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_isEnabled, true, "f");
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            layer.enable();
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            editor.enable();
        }
    }
}, _AnnotationEditorUIManager_disableAll = function _AnnotationEditorUIManager_disableAll() {
    this.unselectAll();
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_isEnabled, "f")) {
        __classPrivateFieldSet(this, _AnnotationEditorUIManager_isEnabled, false, "f");
        for (const layer of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").values()) {
            layer.disable();
        }
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            editor.disable();
        }
    }
}, _AnnotationEditorUIManager_addEditorToLayer = function _AnnotationEditorUIManager_addEditorToLayer(editor) {
    const layer = __classPrivateFieldGet(this, _AnnotationEditorUIManager_allLayers, "f").get(editor.pageIndex);
    if (layer) {
        layer.addOrRebuild(editor);
    }
    else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
    }
}, _AnnotationEditorUIManager_lastSelectedEditor_get = function _AnnotationEditorUIManager_lastSelectedEditor_get() {
    let ed = null;
    for (ed of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
        // Iterate to get the last element.
    }
    return ed;
}, _AnnotationEditorUIManager_isEmpty = function _AnnotationEditorUIManager_isEmpty() {
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").size === 0) {
        return true;
    }
    if (__classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").size === 1) {
        for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_allEditors, "f").values()) {
            return editor.isEmpty();
        }
    }
    return false;
}, _AnnotationEditorUIManager_selectEditors = function _AnnotationEditorUIManager_selectEditors(editors) {
    for (const editor of __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f")) {
        editor.unselect();
    }
    __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").clear();
    for (const editor of editors) {
        if (editor.isEmpty()) {
            continue;
        }
        __classPrivateFieldGet(this, _AnnotationEditorUIManager_selectedEditors, "f").add(editor);
        editor.select();
    }
    __classPrivateFieldGet(this, _AnnotationEditorUIManager_instances, "m", _AnnotationEditorUIManager_dispatchUpdateStates).call(this, { hasSelectedEditor: this.hasSelection });
};
AnnotationEditorUIManager.TRANSLATE_SMALL = 1; // page units.
AnnotationEditorUIManager.TRANSLATE_BIG = 10; // page units.
