import { Component } from "./component";
// @ts-expect-error TS(2556): A spread argument must either have a tuple type or... Remove this comment to see the full error message
export const extend = (...args) => Object.assign(...args);
export const isObject = (value) => value && typeof (value) === "object" && !Array.isArray(value);
export const isHtmlElement = (element) => element instanceof HTMLElement;
export const isDomElement = (element) => element instanceof Element;
/* eslint-disable no-undef */
// @ts-expect-error TS(2304): Cannot find name 'DotNet'.
export const isDotNetObject = (value) => value && window && window.DotNet && window.DotNet.DotNetObject && value instanceof DotNet.DotNetObject;
/* eslint-enable no-undef */
export const deepExtend = (target, ...sources) => {
    if (!sources.length) {
        return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (source[key] instanceof Component) {
                target[key] = source[key];
            }
            else if (isHtmlElement(source[key])) {
                target[key] = source[key];
            }
            else if (key === "dotNetInstance" || isDotNetObject(source[key])) {
                // avoid cloning a DotNetObject as it might have circular properties
                // see https://github.com/telerik/blazor/issues/7507
                // the check for the name of our own option - "dotNetInstance"
                // is an additional guard against the Blazor API being different in other .NET versions
                target[key] = source[key];
            }
            else if (source[key] && source[key].buffer && source[key].buffer instanceof ArrayBuffer) {
                target[key] = source[key];
            }
            else if (isObject(source[key]) && Object.getPrototypeOf(source[key]) !== Object.prototype) {
                target[key] = source[key];
            }
            else if (isObject(source[key])) {
                if (!target[key] || !isObject(target[key])) {
                    extend(target, { [key]: {} });
                }
                deepExtend(target[key], source[key]);
            }
            else {
                extend(target, { [key]: source[key] });
            }
        }
    }
    return deepExtend(target, ...sources);
};
export const isFunction = fn => typeof (fn) === "function";
export const isString = value => typeof (value) === "string";
export const toArray = value => Array.from(value);
export const isDefined = value => typeof (value) !== "undefined";
export const isNotNull = value => value !== null;
export const hasValue = value => isDefined(value) && isNotNull(value);
export const noop = function () { };
export const convertToHtml = (htmlString, ownerDocument) => {
    const template = (ownerDocument || document).createElement('template');
    template.innerHTML = htmlString.trim();
    const content = template.content;
    if (content.childNodes.length > 1) {
        return content.childNodes;
    }
    return content.firstChild;
};
export const toPixel = value => parseFloat(value) + "px";
export const toClassSelector = (className) => (className === null || className === void 0 ? void 0 : className.startsWith(".")) ? className : `.${className}`;
export const mousewheelDelta = (e) => {
    let delta = 0;
    if (e.wheelDelta) {
        delta = -e.wheelDelta / 120;
    }
    else if (e.detail) {
        delta = e.detail / 3;
    }
    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    return delta;
};
export const createPromise = () => {
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function (resolve, reject) {
        resolveFn = resolve;
        rejectFn = reject;
    });
    // @ts-expect-error TS(2339): Property 'resolve' does not exist on type 'Promise... Remove this comment to see the full error message
    promise.resolve = resolveFn;
    // @ts-expect-error TS(2339): Property 'reject' does not exist on type 'Promise<... Remove this comment to see the full error message
    promise.reject = rejectFn;
    return promise;
};
