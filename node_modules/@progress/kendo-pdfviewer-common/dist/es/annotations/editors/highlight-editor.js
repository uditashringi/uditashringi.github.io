/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _HighlightEditor_instances, _a, _HighlightEditor_anchorNode, _HighlightEditor_anchorOffset, _HighlightEditor_boxes, _HighlightEditor_clipPathId, _HighlightEditor_focusOutlines, _HighlightEditor_focusNode, _HighlightEditor_focusOffset, _HighlightEditor_highlightDiv, _HighlightEditor_highlightOutlines, _HighlightEditor_id, _HighlightEditor_isFreeHighlight, _HighlightEditor_lastPoint, _HighlightEditor_opacity, _HighlightEditor_outlineId, _HighlightEditor_text, _HighlightEditor_thickness, _HighlightEditor_methodOfCreation, _HighlightEditor_createOutlines, _HighlightEditor_createFreeOutlines, _HighlightEditor_updateColor, _HighlightEditor_updateThickness, _HighlightEditor_cleanDrawLayer, _HighlightEditor_addToDrawLayer, _HighlightEditor_rotateBbox, _HighlightEditor_keydown, _HighlightEditor_setCaret, _HighlightEditor_getRotation, _HighlightEditor_serializeBoxes, _HighlightEditor_serializeOutlines, _HighlightEditor_highlightMove, _HighlightEditor_endHighlight;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { AnnotationEditorParamsType, AnnotationEditorType, 
// DrawLayer,
// shadow,
Util, noContextMenu } from "pdfjs-dist/legacy/build/pdf.mjs";
import { bindEvents } from "../helpers/tools";
// import { bindEvents, KeyboardManager } from "./tools.js";
// import { FreeOutliner, Outliner } from "./outliner.js";
import { AnnotationEditor } from "./annotation-editor";
import { FreeOutliner, Outliner } from "./outliner";
// import { ColorPicker } from "./color_picker.js";
// import { noContextMenu } from "../../shared/display_utils";
/**
 * Basic draw editor in order to generate an Highlight annotation.
 */
class HighlightEditor extends AnnotationEditor {
    // static get _keyboardManager() {
    //     const proto = HighlightEditor.prototype;
    //     return shadow(
    //         this,
    //         "_keyboardManager",
    //         new KeyboardManager([
    //             [["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, { args: [0] }],
    //             [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, { args: [1] }],
    //             [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, { args: [2] }],
    //             [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, { args: [3] }],
    //         ])
    //     );
    // }
    constructor(params) {
        super(Object.assign(Object.assign({}, params), { name: "k-highlight-editor highlightEditor" }));
        _HighlightEditor_instances.add(this);
        // todo: props
        this.color = "";
        // parent = null;
        // width = null;
        // height = null;
        // x = null;
        // y = null;
        // todo: props
        _HighlightEditor_anchorNode.set(this, null);
        _HighlightEditor_anchorOffset.set(this, 0);
        _HighlightEditor_boxes.set(this, void 0);
        _HighlightEditor_clipPathId.set(this, null);
        // #colorPicker = null;
        _HighlightEditor_focusOutlines.set(this, null);
        _HighlightEditor_focusNode.set(this, null);
        _HighlightEditor_focusOffset.set(this, 0);
        _HighlightEditor_highlightDiv.set(this, null);
        _HighlightEditor_highlightOutlines.set(this, null);
        _HighlightEditor_id.set(this, null);
        _HighlightEditor_isFreeHighlight.set(this, false);
        _HighlightEditor_lastPoint.set(this, null);
        _HighlightEditor_opacity.set(this, void 0);
        _HighlightEditor_outlineId.set(this, null);
        _HighlightEditor_text.set(this, "");
        _HighlightEditor_thickness.set(this, void 0);
        _HighlightEditor_methodOfCreation.set(this, "");
        this.color = params.color || _a._defaultColor;
        __classPrivateFieldSet(this, _HighlightEditor_thickness, params.thickness || _a._defaultThickness, "f");
        __classPrivateFieldSet(this, _HighlightEditor_opacity, params.opacity || _a._defaultOpacity, "f");
        __classPrivateFieldSet(this, _HighlightEditor_boxes, params.boxes || null, "f");
        __classPrivateFieldSet(this, _HighlightEditor_methodOfCreation, params.methodOfCreation || "", "f");
        __classPrivateFieldSet(this, _HighlightEditor_text, params.text || "", "f");
        this._isDraggable = false;
        if (params.highlightId > -1) {
            __classPrivateFieldSet(this, _HighlightEditor_isFreeHighlight, true, "f");
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_createFreeOutlines).call(this, params);
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_addToDrawLayer).call(this);
        }
        else {
            __classPrivateFieldSet(this, _HighlightEditor_anchorNode, params.anchorNode, "f");
            __classPrivateFieldSet(this, _HighlightEditor_anchorOffset, params.anchorOffset, "f");
            __classPrivateFieldSet(this, _HighlightEditor_focusNode, params.focusNode, "f");
            __classPrivateFieldSet(this, _HighlightEditor_focusOffset, params.focusOffset, "f");
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_createOutlines).call(this);
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_addToDrawLayer).call(this);
            this.rotate(this.rotation);
        }
    }
    /** @inheritdoc */
    get telemetryInitialData() {
        return {
            action: "added",
            type: __classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f") ? "free_highlight" : "highlight",
            color: this._uiManager.highlightColorNames.get(this.color),
            thickness: __classPrivateFieldGet(this, _HighlightEditor_thickness, "f"),
            methodOfCreation: __classPrivateFieldGet(this, _HighlightEditor_methodOfCreation, "f"),
        };
    }
    /** @inheritdoc */
    get telemetryFinalData() {
        return {
            type: "highlight",
            color: this._uiManager.highlightColorNames.get(this.color),
        };
    }
    static computeTelemetryFinalData(data) {
        // We want to know how many colors have been used.
        return { numberOfColors: data.get("color").size };
    }
    /** @inheritdoc */
    static initialize(l10n, uiManager) {
        var _b, _c, _d, _e;
        AnnotationEditor.initialize(l10n, uiManager, {});
        _a._defaultColor || (_a._defaultColor = 
        // uiManager.highlightColors?.values().next().value || "#fff066";
        // uiManager.highlightColors?.values().next().value || "#ffff00";
        ((_e = (_d = (_c = (_b = uiManager.viewer) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.annotations) === null || _d === void 0 ? void 0 : _d.highlight) === null || _e === void 0 ? void 0 : _e.color) || "#ffff00");
    }
    /** @inheritdoc */
    static updateDefaultParams(type, value) {
        switch (type) {
            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
                _a._defaultColor = value;
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                _a._defaultThickness = value;
                break;
            default: break;
        }
    }
    /** @inheritdoc */
    // translateInPage(x, y) { }
    translateInPage() { }
    /** @inheritdoc */
    get toolbarPosition() {
        return __classPrivateFieldGet(this, _HighlightEditor_lastPoint, "f");
    }
    /** @inheritdoc */
    updateParams(type, value) {
        switch (type) {
            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
                __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_updateColor).call(this, value);
                break;
            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_updateThickness).call(this, value);
                break;
            default: break;
        }
    }
    static get defaultPropertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,
                _a._defaultColor,
            ],
            [
                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
                _a._defaultThickness,
            ],
        ];
    }
    /** @inheritdoc */
    get propertiesToUpdate() {
        return [
            [
                AnnotationEditorParamsType.HIGHLIGHT_COLOR,
                this.color || _a._defaultColor,
            ],
            [
                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
                __classPrivateFieldGet(this, _HighlightEditor_thickness, "f") || _a._defaultThickness,
            ],
            [AnnotationEditorParamsType.HIGHLIGHT_FREE, __classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f")],
        ];
    }
    /** @inheritdoc */
    // async addEditToolbar() {
    //     // const toolbar = await super.addEditToolbar();
    //     // if (!toolbar) {
    //     //     return null;
    //     // }
    //     // if (this._uiManager.highlightColors) {
    //     //     // this.#colorPicker = new ColorPicker({ editor: this });
    //     //     // toolbar.addColorPicker(this.#colorPicker);
    //     // }
    //     // return toolbar;
    // }
    /** @inheritdoc */
    disableEditing() {
        super.disableEditing();
        this.div.classList.toggle("disabled", true);
        // this.div.classList.toggle("k-disabled", true);
    }
    /** @inheritdoc */
    enableEditing() {
        super.enableEditing();
        this.div.classList.toggle("disabled", false);
        // this.div.classList.toggle("k-disabled", false);
    }
    /** @inheritdoc */
    fixAndSetPosition() {
        return super.fixAndSetPosition(__classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_getRotation).call(this));
    }
    /** @inheritdoc */
    getBaseTranslation() {
        // The editor itself doesn't have any CSS border (we're drawing one
        // ourselves in using SVG).
        return [0, 0];
    }
    /** @inheritdoc */
    getRect(tx, ty) {
        return super.getRect(tx, ty, __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_getRotation).call(this));
    }
    /** @inheritdoc */
    onceAdded() {
        this.parent.addUndoableEditor(this);
        this.div.focus();
    }
    /** @inheritdoc */
    remove() {
        __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_cleanDrawLayer).call(this);
        // this._reportTelemetry({
        //     action: "deleted",
        // });
        super.remove();
    }
    /** @inheritdoc */
    rebuild() {
        if (!this.parent) {
            return;
        }
        super.rebuild();
        if (this.div === null) {
            return;
        }
        __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_addToDrawLayer).call(this);
        if (!this.isAttachedToDOM) {
            // At some point this editor was removed and we're rebuilding it,
            // hence we must add it to its parent.
            this.parent.add(this);
        }
    }
    setParent(parent) {
        var _b, _c;
        let mustBeSelected = false;
        if (this.parent && !parent) {
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_cleanDrawLayer).call(this);
        }
        else if (parent) {
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_addToDrawLayer).call(this, parent);
            // If mustBeSelected is true it means that this editor was selected
            // when its parent has been destroyed, hence we must select it again.
            mustBeSelected =
                !this.parent &&
                    (((_b = this.div) === null || _b === void 0 ? void 0 : _b.classList.contains("selectedEditor")) ||
                        ((_c = this.div) === null || _c === void 0 ? void 0 : _c.classList.contains("k-selected")));
        }
        super.setParent(parent);
        this.show(this._isVisible);
        if (mustBeSelected) {
            // We select it after the parent has been set.
            this.select();
        }
    }
    /** @inheritdoc */
    rotate(angle) {
        // We need to rotate the svgs because of the coordinates system.
        const { drawLayer } = this.parent;
        let box;
        if (__classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f")) {
            angle = (angle - this.rotation + 360) % 360;
            box = __classPrivateFieldGet(_a, _a, "m", _HighlightEditor_rotateBbox).call(_a, __classPrivateFieldGet(this, _HighlightEditor_highlightOutlines, "f").box, angle);
        }
        else {
            // An highlight annotation is always drawn horizontally.
            box = __classPrivateFieldGet(_a, _a, "m", _HighlightEditor_rotateBbox).call(_a, this, angle);
        }
        drawLayer.rotate(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), angle);
        drawLayer.rotate(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), angle);
        drawLayer.updateBox(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), box);
        drawLayer.updateBox(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), __classPrivateFieldGet(_a, _a, "m", _HighlightEditor_rotateBbox).call(_a, __classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f").box, angle));
    }
    /** @inheritdoc */
    render() {
        if (this.div) {
            return this.div;
        }
        const div = super.render();
        if (__classPrivateFieldGet(this, _HighlightEditor_text, "f")) {
            div.setAttribute("aria-label", __classPrivateFieldGet(this, _HighlightEditor_text, "f"));
            div.setAttribute("role", "mark");
        }
        if (__classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f")) {
            div.classList.add("free");
        }
        else {
            this.div.addEventListener("keydown", __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_keydown).bind(this), {
                signal: this._uiManager._signal,
            });
        }
        const highlightDiv = (__classPrivateFieldSet(this, _HighlightEditor_highlightDiv, document.createElement("div"), "f"));
        div.append(highlightDiv);
        highlightDiv.setAttribute("aria-hidden", "true");
        highlightDiv.className = "k-internal internal";
        highlightDiv.style.clipPath = __classPrivateFieldGet(this, _HighlightEditor_clipPathId, "f");
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(this.width * parentWidth, this.height * parentHeight);
        bindEvents(this, __classPrivateFieldGet(this, _HighlightEditor_highlightDiv, "f"), ["pointerover", "pointerleave"]);
        this.enableEditing();
        return div;
    }
    pointerover() {
        this.parent.drawLayer.addClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "hovered");
    }
    pointerleave() {
        this.parent.drawLayer.removeClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "hovered");
    }
    _moveCaret(direction) {
        this.parent.unselect(this);
        switch (direction) {
            case 0 /* left */:
            case 2 /* up */:
                __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_setCaret).call(this, /* start = */ true);
                break;
            case 1 /* right */:
            case 3 /* down */:
                __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_setCaret).call(this, /* start = */ false);
                break;
            default: break;
        }
    }
    /** @inheritdoc */
    select() {
        var _b, _c, _d;
        super.select();
        if (!__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f")) {
            return;
        }
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.drawLayer.removeClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "hovered");
        (_c = this.parent) === null || _c === void 0 ? void 0 : _c.drawLayer.addClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "selected");
        (_d = this.parent) === null || _d === void 0 ? void 0 : _d.drawLayer.addClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "k-selected");
    }
    /** @inheritdoc */
    unselect() {
        var _b, _c;
        super.unselect();
        if (!__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f")) {
            return;
        }
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.drawLayer.removeClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "selected");
        (_c = this.parent) === null || _c === void 0 ? void 0 : _c.drawLayer.removeClass(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), "k-selected");
        if (!__classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f")) {
            __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_setCaret).call(this, /* start = */ false);
        }
    }
    /** @inheritdoc */
    get _mustFixPosition() {
        return !__classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f");
    }
    /** @inheritdoc */
    show(visible = this._isVisible) {
        super.show(visible);
        if (this.parent) {
            this.parent.drawLayer.show(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), visible);
            this.parent.drawLayer.show(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), visible);
        }
    }
    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {
        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight, } = textLayer.getBoundingClientRect();
        const ac = new AbortController();
        const signal = parent.combinedSignal(ac);
        const pointerDown = e => {
            // Avoid to have undesired clicks during the drawing.
            e.preventDefault();
            e.stopPropagation();
        };
        const pointerUpCallback = e => {
            ac.abort();
            __classPrivateFieldGet(this, _a, "m", _HighlightEditor_endHighlight).call(this, parent, e);
        };
        window.addEventListener("blur", pointerUpCallback, { signal });
        window.addEventListener("pointerup", pointerUpCallback, { signal });
        window.addEventListener("pointerdown", pointerDown, {
            capture: true,
            passive: false,
            signal,
        });
        window.addEventListener("contextmenu", noContextMenu, { signal });
        textLayer.addEventListener("pointermove", __classPrivateFieldGet(this, _a, "m", _HighlightEditor_highlightMove).bind(this, parent), { signal });
        this._freeHighlight = new FreeOutliner({ x, y }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 
        /* innerMargin = */ 0.001);
        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } =
            parent.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, 
            /* isPathUpdatable = */ true));
    }
    /** @inheritdoc */
    static deserialize(data, parent, uiManager) {
        const editor = super.deserialize(data, parent, uiManager);
        const { rect: [blX, blY, trX, trY], color, quadPoints, } = data;
        // @ts-expect-error TS()
        editor.color = Util.makeHexColor(...color);
        __classPrivateFieldSet(editor, _HighlightEditor_opacity, data.opacity, "f");
        const [pageWidth, pageHeight] = editor.pageDimensions;
        editor.width = (trX - blX) / pageWidth;
        editor.height = (trY - blY) / pageHeight;
        const boxes = (__classPrivateFieldSet(editor, _HighlightEditor_boxes, [], "f"));
        for (let i = 0; i < quadPoints.length; i += 8) {
            boxes.push({
                x: (quadPoints[4] - trX) / pageWidth,
                y: (trY - (1 - quadPoints[i + 5])) / pageHeight,
                width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
                height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight,
            });
        }
        __classPrivateFieldGet(editor, _HighlightEditor_instances, "m", _HighlightEditor_createOutlines).call(editor);
        return editor;
    }
    /** @inheritdoc */
    serialize(isForCopying = false) {
        // It doesn't make sense to copy/paste a highlight annotation.
        if (this.isEmpty() || isForCopying) {
            return null;
        }
        const rect = this.getRect(0, 0);
        const color = AnnotationEditor._colorManager.convert(this.color);
        return {
            annotationType: AnnotationEditorType.HIGHLIGHT,
            color,
            opacity: __classPrivateFieldGet(this, _HighlightEditor_opacity, "f"),
            thickness: __classPrivateFieldGet(this, _HighlightEditor_thickness, "f"),
            quadPoints: __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_serializeBoxes).call(this),
            outlines: __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_serializeOutlines).call(this, rect),
            pageIndex: this.pageIndex,
            rect,
            rotation: __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_getRotation).call(this),
            structTreeParentId: this._structTreeParentId,
        };
    }
    static canCreateNewEmptyEditor() {
        return false;
    }
    // todo: this is necessary
    // saveDocument() has checks that test "editor instanceof AnnotationEditor", but they fail
    // because AnnotationEditor from "pdfjs-dist/legacy/build/pdf.mjs" is not exported
    // thus replace instances of editors with their serialized version
    toJSON() {
        const data = this.serialize();
        return data;
    }
}
_a = HighlightEditor, _HighlightEditor_anchorNode = new WeakMap(), _HighlightEditor_anchorOffset = new WeakMap(), _HighlightEditor_boxes = new WeakMap(), _HighlightEditor_clipPathId = new WeakMap(), _HighlightEditor_focusOutlines = new WeakMap(), _HighlightEditor_focusNode = new WeakMap(), _HighlightEditor_focusOffset = new WeakMap(), _HighlightEditor_highlightDiv = new WeakMap(), _HighlightEditor_highlightOutlines = new WeakMap(), _HighlightEditor_id = new WeakMap(), _HighlightEditor_isFreeHighlight = new WeakMap(), _HighlightEditor_lastPoint = new WeakMap(), _HighlightEditor_opacity = new WeakMap(), _HighlightEditor_outlineId = new WeakMap(), _HighlightEditor_text = new WeakMap(), _HighlightEditor_thickness = new WeakMap(), _HighlightEditor_methodOfCreation = new WeakMap(), _HighlightEditor_instances = new WeakSet(), _HighlightEditor_createOutlines = function _HighlightEditor_createOutlines() {
    const outliner = new Outliner(__classPrivateFieldGet(this, _HighlightEditor_boxes, "f"), /* borderWidth = */ 0.001);
    __classPrivateFieldSet(this, _HighlightEditor_highlightOutlines, outliner.getOutlines(), "f");
    ({
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
    } = __classPrivateFieldGet(this, _HighlightEditor_highlightOutlines, "f").box);
    const outlinerForOutline = new Outliner(__classPrivateFieldGet(this, _HighlightEditor_boxes, "f"), 
    /* borderWidth = */ 0.0025, 
    /* innerMargin = */ 0.001, this._uiManager.direction === "ltr");
    __classPrivateFieldSet(this, _HighlightEditor_focusOutlines, outlinerForOutline.getOutlines(), "f");
    // The last point is in the pages coordinate system.
    const { lastPoint } = __classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f").box;
    __classPrivateFieldSet(this, _HighlightEditor_lastPoint, [
        (lastPoint[0] - this.x) / this.width,
        (lastPoint[1] - this.y) / this.height,
    ], "f");
}, _HighlightEditor_createFreeOutlines = function _HighlightEditor_createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {
    __classPrivateFieldSet(this, _HighlightEditor_highlightOutlines, highlightOutlines, "f");
    const extraThickness = 1.5;
    __classPrivateFieldSet(this, _HighlightEditor_focusOutlines, highlightOutlines.getNewOutline(
    /* Slightly bigger than the highlight in order to have a little
       space between the highlight and the outline. */
    __classPrivateFieldGet(this, _HighlightEditor_thickness, "f") / 2 + extraThickness, 
    /* innerMargin = */ 0.0025), "f");
    if (highlightId >= 0) {
        __classPrivateFieldSet(this, _HighlightEditor_id, highlightId, "f");
        __classPrivateFieldSet(this, _HighlightEditor_clipPathId, clipPathId, "f");
        // We need to redraw the highlight because we change the coordinates to be
        // in the box coordinate system.
        this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
        __classPrivateFieldSet(this, _HighlightEditor_outlineId, this.parent.drawLayer.highlightOutline(__classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f")), "f");
    }
    else if (this.parent) {
        const angle = this.parent.viewport.rotation;
        this.parent.drawLayer.updateLine(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), highlightOutlines);
        this.parent.drawLayer.updateBox(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), __classPrivateFieldGet(_a, _a, "m", _HighlightEditor_rotateBbox).call(_a, __classPrivateFieldGet(this, _HighlightEditor_highlightOutlines, "f").box, (angle - this.rotation + 360) % 360));
        this.parent.drawLayer.updateLine(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), __classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f"));
        this.parent.drawLayer.updateBox(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"), __classPrivateFieldGet(_a, _a, "m", _HighlightEditor_rotateBbox).call(_a, __classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f").box, angle));
    }
    const { x, y, width, height } = highlightOutlines.box;
    switch (this.rotation) {
        case 0:
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            break;
        case 90: {
            const [pageWidth, pageHeight] = this.parentDimensions;
            this.x = y;
            this.y = 1 - x;
            this.width = (width * pageHeight) / pageWidth;
            this.height = (height * pageWidth) / pageHeight;
            break;
        }
        case 180:
            this.x = 1 - x;
            this.y = 1 - y;
            this.width = width;
            this.height = height;
            break;
        case 270: {
            const [pageWidth, pageHeight] = this.parentDimensions;
            this.x = 1 - y;
            this.y = x;
            this.width = (width * pageHeight) / pageWidth;
            this.height = (height * pageWidth) / pageHeight;
            break;
        }
        default: break;
    }
    const { lastPoint } = __classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f").box;
    __classPrivateFieldSet(this, _HighlightEditor_lastPoint, [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height], "f");
}, _HighlightEditor_updateColor = function _HighlightEditor_updateColor(color) {
    if (!color) {
        return;
    }
    const setColor = col => {
        var _b;
        this.color = col;
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.drawLayer.changeColor(__classPrivateFieldGet(this, _HighlightEditor_id, "f"), col);
        // this.#colorPicker?.updateColor(col);
    };
    const savedColor = this.color;
    this.addCommands({
        cmd: setColor.bind(this, color),
        undo: setColor.bind(this, savedColor),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
        overwriteIfSameType: true,
        keepUndo: true,
    });
    // this._reportTelemetry(
    //     {
    //         action: "color_changed",
    //         color: this._uiManager.highlightColorNames.get(color),
    //     },
    //     /* mustWait = */ true
    // );
}, _HighlightEditor_updateThickness = function _HighlightEditor_updateThickness(thickness) {
    if (!thickness) {
        return;
    }
    // const savedThickness = this.#thickness;
    // const setThickness = th => {
    //     this.#thickness = th;
    //     this.#changeThickness(th);
    // };
    // this.addCommands({
    //     cmd: setThickness.bind(this, thickness),
    //     undo: setThickness.bind(this, savedThickness),
    //     post: this._uiManager.updateUI.bind(this._uiManager, this),
    //     mustExec: true,
    //     type: AnnotationEditorParamsType.INK_THICKNESS,
    //     overwriteIfSameType: true,
    //     keepUndo: true,
    // });
    // this._reportTelemetry(
    //     { action: "thickness_changed", thickness },
    // /* mustWait = */ true
    // );
}, _HighlightEditor_cleanDrawLayer = function _HighlightEditor_cleanDrawLayer() {
    if (__classPrivateFieldGet(this, _HighlightEditor_id, "f") === null || !this.parent) {
        return;
    }
    this.parent.drawLayer.remove(__classPrivateFieldGet(this, _HighlightEditor_id, "f"));
    __classPrivateFieldSet(this, _HighlightEditor_id, null, "f");
    this.parent.drawLayer.remove(__classPrivateFieldGet(this, _HighlightEditor_outlineId, "f"));
    __classPrivateFieldSet(this, _HighlightEditor_outlineId, null, "f");
}, _HighlightEditor_addToDrawLayer = function _HighlightEditor_addToDrawLayer(parent = this.parent) {
    var _b, _c;
    if (__classPrivateFieldGet(this, _HighlightEditor_id, "f") !== null) {
        return;
    }
    (_b = this, _c = this, { id: ({ set value(_a) { __classPrivateFieldSet(_b, _HighlightEditor_id, _a, "f"); } }).value, clipPathId: ({ set value(_a) { __classPrivateFieldSet(_c, _HighlightEditor_clipPathId, _a, "f"); } }).value } =
        parent.drawLayer.highlight(__classPrivateFieldGet(this, _HighlightEditor_highlightOutlines, "f"), this.color, __classPrivateFieldGet(this, _HighlightEditor_opacity, "f")));
    __classPrivateFieldSet(this, _HighlightEditor_outlineId, parent.drawLayer.highlightOutline(__classPrivateFieldGet(this, _HighlightEditor_focusOutlines, "f")), "f");
    // // todo: manually set styles, so that SVG elements are properly displayed
    // if (parent.drawLayer.parent) {
    //     Array.from(parent.drawLayer.parent.querySelectorAll(".highlight")).forEach(x => {
    //         const element = x as any;
    //         element.style["--blend-mode"] = "multiply";
    //         element.style.position = "absolute";
    //         element.style["mix-blend-mode"] = "var(--blend-mode)";
    //         element.style.transform = "none";
    //     });
    // }
    if (__classPrivateFieldGet(this, _HighlightEditor_highlightDiv, "f")) {
        __classPrivateFieldGet(this, _HighlightEditor_highlightDiv, "f").style.clipPath = __classPrivateFieldGet(this, _HighlightEditor_clipPathId, "f");
    }
}, _HighlightEditor_rotateBbox = function _HighlightEditor_rotateBbox({ x, y, width, height }, angle) {
    switch (angle) {
        case 90:
            return {
                x: 1 - y - height,
                y: x,
                width: height,
                height: width,
            };
        case 180:
            return {
                x: 1 - x - width,
                y: 1 - y - height,
                width,
                height,
            };
        case 270:
            return {
                x: y,
                y: 1 - x - width,
                width: height,
                height: width,
            };
        default: break;
    }
    return {
        x,
        y,
        width,
        height,
    };
}, _HighlightEditor_keydown = function _HighlightEditor_keydown(event) {
    if (!event) {
        return;
    }
    // HighlightEditor._keyboardManager.exec(this, event);
}, _HighlightEditor_setCaret = function _HighlightEditor_setCaret(start) {
    if (!__classPrivateFieldGet(this, _HighlightEditor_anchorNode, "f")) {
        return;
    }
    const selection = window.getSelection();
    if (start) {
        selection.setPosition(__classPrivateFieldGet(this, _HighlightEditor_anchorNode, "f"), __classPrivateFieldGet(this, _HighlightEditor_anchorOffset, "f"));
    }
    else {
        selection.setPosition(__classPrivateFieldGet(this, _HighlightEditor_focusNode, "f"), __classPrivateFieldGet(this, _HighlightEditor_focusOffset, "f"));
    }
}, _HighlightEditor_getRotation = function _HighlightEditor_getRotation() {
    // Highlight annotations are always drawn horizontally but if
    // a free highlight annotation can be rotated.
    return __classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f") ? this.rotation : 0;
}, _HighlightEditor_serializeBoxes = function _HighlightEditor_serializeBoxes() {
    if (__classPrivateFieldGet(this, _HighlightEditor_isFreeHighlight, "f")) {
        return null;
    }
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const boxes = __classPrivateFieldGet(this, _HighlightEditor_boxes, "f");
    const quadPoints = new Float32Array(boxes.length * 8);
    let i = 0;
    for (const { x, y, width, height } of boxes) {
        const sx = x * pageWidth + pageX;
        const sy = (1 - y - height) * pageHeight + pageY;
        // The specifications say that the rectangle should start from the bottom
        // left corner and go counter-clockwise.
        // But when opening the file in Adobe Acrobat it appears that this isn't
        // correct hence the 4th and 6th numbers are just swapped.
        quadPoints[i] = quadPoints[i + 4] = sx;
        quadPoints[i + 1] = quadPoints[i + 3] = sy;
        quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
        quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;
        i += 8;
    }
    return quadPoints;
}, _HighlightEditor_serializeOutlines = function _HighlightEditor_serializeOutlines(rect) {
    return __classPrivateFieldGet(this, _HighlightEditor_highlightOutlines, "f").serialize(rect, __classPrivateFieldGet(this, _HighlightEditor_instances, "m", _HighlightEditor_getRotation).call(this));
}, _HighlightEditor_highlightMove = function _HighlightEditor_highlightMove(parent, event) {
    if (this._freeHighlight.add(event)) {
        // Redraw only if the point has been added.
        parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
    }
}, _HighlightEditor_endHighlight = function _HighlightEditor_endHighlight(parent, event) {
    if (!this._freeHighlight.isEmpty()) {
        parent.createAndAddNewEditor(event, false, {
            highlightId: this._freeHighlightId,
            highlightOutlines: this._freeHighlight.getOutlines(),
            clipPathId: this._freeHighlightClipId,
            methodOfCreation: "main_toolbar",
        });
    }
    else {
        parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
    }
    this._freeHighlightId = -1;
    this._freeHighlight = null;
    this._freeHighlightClipId = "";
};
HighlightEditor._defaultColor = null;
HighlightEditor._defaultOpacity = 1;
HighlightEditor._defaultThickness = 12;
HighlightEditor._type = "highlight";
HighlightEditor._editorType = AnnotationEditorType.HIGHLIGHT;
HighlightEditor._freeHighlightId = -1;
HighlightEditor._freeHighlight = null;
HighlightEditor._freeHighlightClipId = "";
export { HighlightEditor };
