var _PdfViewer_instances, _PdfViewer_annotationEditorMode, _PdfViewer_switchAnnotationEditorModeTimeoutId, _PdfViewer_eventAbortController, _PdfViewer_onPageRenderedCallback, _PdfViewer_switchToEditAnnotationMode, _PdfViewer_scrollIntoView;
import { __awaiter, __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { deepExtend, Component, isString, toArray, noop, hasValue, toClassSelector, addClass, removeClass, mousewheelDelta, convertToHtml, clamp, createPromise } from "../common/main";
import { currentPage, parsePdfFromBase64String, scale as getScale, adjustCanvasSize, createElement } from "../utils";
import { SearchService } from "../search";
import { Scroller } from "../scroller";
import { throttle } from "../scroller";
import { saveAs } from "@progress/kendo-file-saver";
import { getDocument, AnnotationEditorParamsType, AnnotationEditorType, PixelsPerInch, shadow, } from "pdfjs-dist/legacy/build/pdf.mjs";
import { AnnotationEditorUIManager } from "../annotations/annotation-editor-ui-manager";
import { EventBus } from '../annotations/shared/event_utils';
import { Page } from "./page";
import { AnnotationMode } from "../annotations/shared/utils";
import { scrollIntoView, TextLayerMode, ScrollMode } from "../annotations/shared/ui_utils";
import { AnnotationStorage } from "../annotations/helpers/annotation-storage";
import { LinkTarget, PDFLinkService } from "../links/link-service";
import { PdfViewerInteractionMode } from "../enums/PdfViewerInteractionMode";
const PDF_JS = "pdfjs";
const ERROR = "error";
const ZOOM_START = "zoomStart";
const ZOOM_END = "zoomEnd";
const PAGES_LOAD = "pagesLoad";
const PRINT_END = "printEnd";
const SCROLL = "scroll";
const DOWNLOAD = "download";
const ANNOTATION_EDITOR_TOOLBAR_SHOW = "annotationEditorToolBarShow";
const ANNOTATION_EDITOR_TOOLBAR_HIDE = "annotationEditorToolBarHide";
const DEFAULT_ZOOM_LEVEL = 1.25;
const FRAMES_PER_SECOND = 1000 / 60;
export class PdfViewer extends Component {
    constructor(element, options) {
        super(element, options);
        _PdfViewer_instances.add(this);
        this.options = {
            pdfServiceType: PDF_JS,
            // this is a flag used mainly in tests as CSSStyleSheet.replaceSync
            // fails with jsdom
            // a better solution is not to load a stylesheet in setHiddenCanvasStyles
            // but rather create a class like "k-hidden-canvas-element"
            // and override the rendering from pdf.js
            pdfjsSetHiddenCanvasStyles: true,
            fileData: [],
            page: 1,
            fileDescriptor: null,
            downloadFileName: "Document",
            minZoom: 0.5,
            maxZoom: 4,
            zoomRate: 0.25,
            zoomLevel: DEFAULT_ZOOM_LEVEL,
            zoomBeforePrint: false,
            zoomLevelForPrint: 3,
            searchMatchScrollLeftOffset: 0,
            // add some default offset, so that the found match
            // does not appear on the top edge of the page when navigated to
            searchMatchScrollTopOffset: -64,
            // what percentage of the page should be scrolled,
            // so that the page is considered to be changed to the next one
            pageChangeScrollThreshold: 0.85,
            // values higher than 200ms can result in browser zoom
            pageWheelThrottleDelay: 200,
            // ported from pdf.js
            printResolution: 150,
            loadOnDemand: false,
            loadOnDemandPageSize: 2,
            messages: {
                freeTextEditorPlaceholder: "Start typing",
                errorMessages: {
                    parseError: "PDF file fails to process.",
                    notFound: "File is not found.",
                    popupBlocked: "Popup is blocked."
                }
            },
            annotations: {
                highlight: {
                    color: "#ffff00"
                }
            },
            elementSelectors: {
                pageSelector: "k-page:not(.k-blank-page)",
                pagesContainerClass: "k-pdf-viewer-pages",
                pageCanvasWrapper: "k-canvas-wrapper",
                documentContainerClass: "k-pdf-viewer-canvas",
                textLayerClass: "k-text-layer",
                searchHighlightClass: "k-search-highlight",
                searchHighlightMarkClass: "k-search-highlight-mark",
                charClass: "k-text-char",
                textElementSelector: "span[role='presentation']",
                renderedPageSelector: "k-page[data-page-number]",
                enabledTextSelectionClass: "k-enable-text-select",
                enabledPanningClass: "k-enable-panning"
            },
            events: {
                [PAGES_LOAD]: noop,
                [PRINT_END]: noop,
                [ZOOM_START]: noop,
                [ZOOM_END]: noop,
                [ERROR]: noop,
                [SCROLL]: noop,
                [ANNOTATION_EDITOR_TOOLBAR_SHOW]: noop,
                [ANNOTATION_EDITOR_TOOLBAR_HIDE]: noop
            }
        };
        // todo: props
        // isPageEditing = null;
        this.interactionMode = PdfViewerInteractionMode.TextSelection;
        this.printContainer = null;
        // todo: props ported from pdf.js
        this._scrollMode = ScrollMode.PAGE;
        this.isInPresentationMode = false;
        this._currentPageNumber = 1;
        this.linkService = null;
        this.annotationStorage = null;
        this._annotationStorageModified = false;
        this._hasAnnotationEditors = false;
        _PdfViewer_annotationEditorMode.set(this, AnnotationEditorType.NONE);
        this.annotationEditorUIManager = null;
        _PdfViewer_switchAnnotationEditorModeTimeoutId.set(this, null);
        // #buffer = null;
        // #altTextManager = null;
        // #annotationEditorHighlightColors = null;
        // #annotationEditorMode = AnnotationEditorType.NONE;
        // #annotationEditorUIManager = null;
        // #annotationMode = AnnotationMode.ENABLE_FORMS;
        // #containerTopLeft = null;
        // #enableHWA = false;
        // #enableHighlightFloatingButton = false;
        // #enablePermissions = false;
        // #enableUpdatedAddImage = false;
        // #enableNewAltTextWhenAddingImage = false;
        _PdfViewer_eventAbortController.set(this, null);
        // #mlManager = null;
        _PdfViewer_onPageRenderedCallback.set(this, null);
        // #switchAnnotationEditorModeTimeoutId = null;
        // #getAllTextInProgress = false;
        // #hiddenCopyElement = null;
        // #interruptCopyCondition = false;
        // #previousContainerHeight = 0;
        // #resizeObserver = new ResizeObserver(this.#resizeObserverCallback.bind(this));
        // #scrollModePageState = null;
        // #scaleTimeoutId = null;
        // #textLayerMode = TextLayerMode.ENABLE;
        // todo: props
        this.state = {};
        this.pdfDocument = null;
        this.pages = [];
        this.triggerError = (e) => {
            this.trigger(ERROR, {
                error: e
            });
        };
        this.triggerPrintEnd = (e) => {
            this.trigger(PRINT_END, e);
        };
        this.onPagesLoad = (args) => {
            this.state.pdfDocument = args.pdfDoc;
            this.state.pdfPages = args.pdfPages;
            this.clearSearch();
            this.initSearchService();
            this.enableDocumentScrollEventsTracking();
            this.triggerPagesLoad(args);
        };
        this.onDocumentScrollerScroll = (e) => {
            const currentPageIndex = this.getCurrentPageIndex();
            const pages = this.pages;
            const page = pages[currentPageIndex];
            const nextPage = pages[currentPageIndex + 1];
            const previousPage = pages[currentPageIndex - 1];
            if (page && page.isBlank()) {
                this.drawPageAsync({ pageIndex: currentPageIndex });
            }
            if (nextPage && nextPage.isBlank()) {
                this.drawPageAsync({ pageIndex: currentPageIndex + 1 });
            }
            if (previousPage && previousPage.isBlank()) {
                this.drawPageAsync({ pageIndex: currentPageIndex - 1 });
            }
            this.tryTriggerScroll(e);
        };
        // this is mainly used by blazor to track the page number
        // as this can only be obtained by JS
        this.tryTriggerScroll = (e) => {
            let isPageChanged = false;
            const pageNumber = currentPage(this.element) + 1;
            if (pageNumber !== this.state.activePageNumber && (pageNumber >= 1 && pageNumber <= this.state.pdfDocument.numPagesh)) {
                isPageChanged = true;
                this.state.activePageNumber = pageNumber;
            }
            if (this.shouldPreventScroll) {
                this.shouldPreventScroll = false;
            }
            else {
                this.trigger(SCROLL, {
                    scrollLeft: e.scrollLeft,
                    scrollTop: e.scrollTop,
                    pageNumber: this.state.activePageNumber,
                    isPageChanged: isPageChanged
                });
            }
        };
        this.printDocumentAsync = () => {
            this.initPrintContainer();
            const pagePrintPromises = this.getPagesPrintContentAsync(this.printContainer);
            const printPromise = createPromise();
            Promise.all(pagePrintPromises)
                .then(() => {
                // print the document during next render task
                setTimeout(() => {
                    this.openPrintDialog();
                    // @ts-expect-error TS()
                    printPromise.resolve();
                }, FRAMES_PER_SECOND);
            });
            return printPromise;
        };
        this.onDocumentWheel = (e) => {
            if (!e.ctrlKey && !e.metaKey) {
                return;
            }
            e.preventDefault();
            const wheelDelta = mousewheelDelta(e);
            const zoomModifier = wheelDelta < 0 ? 1 : -1;
            const zoomLevel = this.state.zoomLevel + (zoomModifier * this.options.zoomRate);
            this.triggerZoomStart({
                zoomLevel: zoomLevel
            });
            this.zoom({
                zoomLevel: zoomLevel
            });
            this.triggerZoomEnd({
                zoomLevel: zoomLevel
            });
        };
        this.extendOptions(options);
        this.throwIfInvalidOptions();
        this.wrapper = this.element;
        this.initEventBus();
        __classPrivateFieldSet(this, _PdfViewer_eventAbortController, new AbortController(), "f");
        this.resetState();
        this.bindEvents();
        this.initLinkService();
        this.initDocumentContainer();
        this.loadFile(this.options.fileDescriptor || {
            data: this.options.fileData,
            page: this.options.page
        });
    }
    destroy() {
        this.destroyEventBus();
        this.unbindEvents();
        this.destroySearchService();
        this.destroyAnnotationEditorUIManager();
        this.destroyDocumentScroller();
    }
    throwIfInvalidOptions() {
        if (this.options.minZoom > this.options.maxZoom) {
            throw new Error("The min zoom should be greater than max zoom");
        }
    }
    set annotationEditorParams({ type, value }) {
        if (!this.annotationEditorUIManager) {
            return;
        }
        this.annotationEditorUIManager.updateParams(type, value);
    }
    get annotationEditorMode() {
        return this.annotationEditorUIManager
            ? __classPrivateFieldGet(this, _PdfViewer_annotationEditorMode, "f")
            : AnnotationEditorType.DISABLE;
    }
    set annotationEditorMode({ mode, editId = null, isFromKeyboard = false }) {
        // todo: set isFromKeyboard intentionally to allow editor creation
        // set annotationEditorMode({ mode, editId = null, isFromKeyboard = true }) {
        if (!this.annotationEditorUIManager) {
            // throw new Error(`The AnnotationEditor is not enabled.`);
        }
        if (__classPrivateFieldGet(this, _PdfViewer_annotationEditorMode, "f") === mode) {
            return; // The AnnotationEditor mode didn't change.
        }
        if (!this.isValidAnnotationEditorMode(mode)) {
            // throw new Error(`Invalid AnnotationEditor mode: ${mode}`);
            return;
        }
        if (!this.pdfDocument) {
            return;
        }
        if (mode === AnnotationEditorType.STAMP) {
            // this.#mlManager?.loadModel("altText");
        }
        const { eventBus } = this;
        const updater = () => {
            this.cleanupSwitchAnnotationEditorMode();
            __classPrivateFieldSet(this, _PdfViewer_annotationEditorMode, mode, "f");
            this.annotationEditorUIManager.updateMode(mode, editId, isFromKeyboard);
            eventBus.dispatch("annotationeditormodechanged", {
                source: this,
                mode,
            });
        };
        // // todo: fix
        // const isEditingPage = (this.pages || []).some(x => x.isEditing);
        if (mode === AnnotationEditorType.NONE || __classPrivateFieldGet(this, _PdfViewer_annotationEditorMode, "f") === AnnotationEditorType.NONE) {
            const isEditing = mode !== AnnotationEditorType.NONE;
            if (!isEditing) {
                this.pdfDocument.annotationStorage.resetModifiedIds();
            }
            for (const pageView of this.pages) {
                pageView.toggleEditingMode(isEditing);
            }
            // We must call #switchToEditAnnotationMode unconditionally to ensure that
            // page is rendered if it's useful or not.
            const idsToRefresh = __classPrivateFieldGet(this, _PdfViewer_instances, "m", _PdfViewer_switchToEditAnnotationMode).call(this);
            if (isEditing && idsToRefresh) {
                // We're editing so we must switch to editing mode when the rendering is
                // done.
                this.cleanupSwitchAnnotationEditorMode();
                __classPrivateFieldSet(this, _PdfViewer_onPageRenderedCallback, ({ pageNumber }) => {
                    idsToRefresh.delete(pageNumber);
                    if (idsToRefresh.size === 0) {
                        __classPrivateFieldSet(this, _PdfViewer_switchAnnotationEditorModeTimeoutId, setTimeout(updater, 0), "f");
                    }
                }, "f");
                const { signal } = __classPrivateFieldGet(this, _PdfViewer_eventAbortController, "f");
                eventBus._on("pagerendered", __classPrivateFieldGet(this, _PdfViewer_onPageRenderedCallback, "f"), { signal });
            }
        }
        updater();
    }
    extendOptions(options) {
        this.options = deepExtend(this.options, options);
    }
    setOptions(options) {
        this.options = options;
    }
    bindEvents() {
        this.bindPagesWheel();
    }
    bindPagesWheel() {
        const documentContainer = this.getDocumentContainer();
        if (!documentContainer) {
            return;
        }
        if (this.options.pageWheelThrottleDelay > 0) {
            // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
            this.throttledPagesWheel = throttle(this.onDocumentWheel, this.options.pageWheelThrottleDelay);
        }
        else {
            // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
            this.throttledPagesWheel = this.onDocumentWheel;
        }
        // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
        documentContainer.addEventListener("wheel", this.throttledPagesWheel);
    }
    unbindEvents() {
        this.unbindPagesWheel();
    }
    unbindPagesWheel() {
        const documentContainer = this.getDocumentContainer();
        if (!documentContainer) {
            return;
        }
        // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
        if (this.throttledPagesWheel && this.throttledPagesWheel.cancel) {
            // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
            this.throttledPagesWheel.cancel();
        }
        // @ts-expect-error TS(2339): Property 'throttledPagesWheel' does not exist on t... Remove this comment to see the full error message
        documentContainer.removeEventListener("wheel", this.throttledPagesWheel);
    }
    setState(newState) {
        this.state = deepExtend(this.state || {}, newState);
    }
    resetState() {
        this.setState({
            activePageNumber: 1,
            visiblePagesCount: 1,
            pagePromises: [],
            downloadFilePromise: null,
            pdfDocument: null,
            zoomLevel: this.options.zoomLevel,
            zoomLevelType: this.options.zoomLevelType,
            zoomLevelBeforePrint: null
        });
    }
    initEventBus() {
        this.eventBus = new EventBus();
    }
    destroyEventBus() {
    }
    initLinkService() {
        var _a;
        this.linkService = new PDFLinkService({
            eventBus: this.eventBus,
            externalLinkTarget: LinkTarget.BLANK,
            externalLinkRel: "noopener noreferrer nofollow",
            ignoreDestinationZoom: false,
        });
        (_a = this.linkService) === null || _a === void 0 ? void 0 : _a.setViewer(this);
    }
    initAnnotationEditorUIManager() {
        this.annotationEditorUIManager = new AnnotationEditorUIManager({
            container: this.getDocumentContainer(),
            // todo: pdf.js expects a dom element and not a component
            viewer: this.element,
            pdfViewer: this,
            pdfDocument: this.state.pdfDocument,
            eventBus: this.eventBus
        });
        this.setAnnotationEditorUIManagerScale();
    }
    setAnnotationEditorUIManagerScale() {
        var _a;
        // this is required when loading a new document
        // so that annotation editors have correct positions during dragging
        (_a = this.annotationEditorUIManager) === null || _a === void 0 ? void 0 : _a.onScaleChanging({
            scale: this.options.zoomLevel
        });
    }
    destroyAnnotationEditorUIManager() {
        var _a;
        (_a = this.annotationEditorUIManager) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    bindEventBusAnnotationsEvents() {
        const eventBus = this.eventBus = this.eventBus || new EventBus();
        eventBus._on("switchannotationeditorparams", (evt) => {
            this.annotationEditorParams = evt;
        }
        // { signal }
        );
        eventBus._on("switchannotationeditormode", evt => {
            // todo: inline the call to this.annotationEditorMode = evt;
            // this.annotationEditorMode = evt;
            this.annotationEditorUIManager.updateParams(evt.type, evt.value);
            const { mode, editId, isFromKeyboard } = evt;
            this.annotationEditorUIManager.annotationEditorMode = evt;
            this.annotationEditorUIManager.updateMode(mode, editId, isFromKeyboard);
            eventBus.dispatch("annotationeditormodechanged", {
                source: this,
                mode,
            });
        }
        // { signal }
        );
        eventBus._on("kendoAnnotationEditorToolBarShow", (evt) => {
            var _a;
            if (!evt) {
                return;
            }
            const annotationEditorMode = this.annotationEditorUIManager.getMode();
            if (annotationEditorMode === AnnotationEditorType.HIGHLIGHT ||
                annotationEditorMode === AnnotationEditorType.FREETEXT) {
                if (annotationEditorMode === AnnotationEditorType.HIGHLIGHT) {
                    this.addHighlightAnnotation();
                }
                this.triggerAnnotationEditorToolBarShow(Object.assign(Object.assign({}, evt), { annotationEditorMode: annotationEditorMode === AnnotationEditorType.HIGHLIGHT ? "highlight" : "freeText", anchor: evt.anchor || ((_a = this.annotationEditorUIManager.firstSelectedEditor) === null || _a === void 0 ? void 0 : _a.div) }));
            }
        }
        // { signal }
        );
        eventBus._on("kendoAnnotationEditorToolBarHide", (evt) => {
            if (!evt) {
                return;
            }
            const annotationEditorMode = this.annotationEditorUIManager.getMode();
            if (annotationEditorMode === AnnotationEditorType.HIGHLIGHT ||
                annotationEditorMode === AnnotationEditorType.FREETEXT) {
                this.triggerAnnotationEditorToolBarHide(Object.assign(Object.assign({}, evt), { annotationEditorMode: annotationEditorMode === AnnotationEditorType.HIGHLIGHT ? "highlight" : "freeText" }));
            }
        }
        // { signal }
        );
        eventBus._on("showannotationeditorui", (evt) => {
            switch (evt.mode) {
                case AnnotationEditorType.HIGHLIGHT:
                    // editorHighlightButton.click();
                    eventBus.dispatch("switchannotationeditormode", {
                        source: this,
                        mode: AnnotationEditorType.HIGHLIGHT,
                        // {},...eventDetails,
                        // evt.detail is the number of clicks.
                        // isFromKeyboard: evt.detail === 0,
                        isFromKeyboard: false
                    });
                    break;
                default: break;
            }
        }
        // { signal }
        );
    }
    unbindEventBusAnnotationsEvents() {
        // this.eventBus.off();
    }
    loadFile(args) {
        const fileData = args.data;
        const loadFileOptions = {
            data: null,
            url: "",
            arrayBuffer: null,
            typedArray: null
        };
        if (fileData && (fileData.buffer instanceof ArrayBuffer || fileData instanceof ArrayBuffer)) {
            loadFileOptions.arrayBuffer = fileData.buffer || fileData;
        }
        else if (isString(fileData) && fileData !== "") {
            loadFileOptions.data = fileData;
            loadFileOptions.url = null;
        }
        else if (isString(args.url) && args.url !== "") {
            loadFileOptions.data = null;
            loadFileOptions.url = args.url;
        }
        else if (args.typedArray) {
            loadFileOptions.typedArray = args.typedArray;
        }
        if (args.data || args.url || args.arrayBuffer || args.typedArray) {
            const readOptions = Object.assign({ dom: this.getPagesContainer(), zoom: this.options.zoomLevel }, loadFileOptions);
            this.disableDocumentScrollEventsTracking();
            this.clearDocument();
            this.loadDocument(readOptions);
            this.setScaleFactor(this.options.zoomLevel);
        }
    }
    loadDocument(options) {
        const params = this.getDocumentParameters(options);
        const { zoom } = options;
        this.clearDocumentState();
        getDocument(params)
            .promise.then((pdfDoc) => {
            var _a;
            (_a = this.linkService) === null || _a === void 0 ? void 0 : _a.setDocument(pdfDoc);
            this.initDocumentAnnotationStorage(pdfDoc);
            this.initAnnotationEditorUIManager();
            this.bindEventBusAnnotationsEvents();
            const pagesPromises = [];
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                pagesPromises.push(pdfDoc.getPage(i));
            }
            return { pagesPromises: pagesPromises, pdfDoc };
        })
            .then(({ pagesPromises: pagesPromises, pdfDoc }) => {
            this.state.pagesPromises = pagesPromises;
            this.destroyPageComponents();
            return this.drawPagesFromPromisesAsync(pagesPromises)
                .then((pdfPages) => {
                this.setHiddenCanvasStyles();
                this.onPagesLoad({ pdfPages, pdfDoc, zoom });
            })
                .catch((e) => {
                this.triggerError(e);
            });
        })
            .catch((e) => {
            this.triggerError(e);
        });
    }
    initDocumentAnnotationStorage(pdfDocument) {
        this.state.pdfDocument = pdfDocument;
        this.pdfDocument = pdfDocument;
        this.annotationStorage = new AnnotationStorage();
        // todo: intentionally override the default value
        // as it relies on checks like "instanceof <something>"
        // but the classes from pdf.js are not exported
        // and thus they are migrated, see https://github.com/mozilla/pdf.js/issues/18656
        // Object.defineProperty(Object.getPrototypeOf(this.pdfDocument), 'annotationStorage', {
        //     get: () => {
        //         if (this.state.isPrintingInProgress) {
        //             return this.annotationStorage?.print;
        //         } else {
        //             return this.annotationStorage;
        //         }
        //     },
        //     set: (value) => {
        //         this.annotationStorage = value;
        //     },
        //     // this is required
        //     configurable: true
        // });
        Object.defineProperty(Object.getPrototypeOf(this.pdfDocument._transport), 'annotationStorage', {
            get: () => {
                var _a;
                if (this.state.isPrintingInProgress) {
                    return (_a = this.annotationStorage) === null || _a === void 0 ? void 0 : _a.print;
                }
                else {
                    return this.annotationStorage;
                }
            },
            set: (value) => {
                this.annotationStorage = value;
            },
            // this is required
            configurable: true
        });
        this._initializeAnnotationStorageCallbacks(pdfDocument);
    }
    _initializeAnnotationStorageCallbacks(pdfDocument) {
        if (pdfDocument !== this.pdfDocument) {
            return;
        }
        const { annotationStorage } = pdfDocument;
        annotationStorage.onSetModified = () => {
            // window.addEventListener("beforeunload", beforeUnload);
            // if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
            this._annotationStorageModified = true;
            // }
        };
        annotationStorage.onResetModified = () => {
            // window.removeEventListener("beforeunload", beforeUnload);
            // if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
            delete this._annotationStorageModified;
            // }
        };
        annotationStorage.onAnnotationEditor = typeStr => {
            this._hasAnnotationEditors = !!typeStr;
            // this.setTitle();
        };
    }
    drawPagesFromPromisesAsync(pagesPromises) {
        return Promise.all(pagesPromises)
            .then((pdfPages) => __awaiter(this, void 0, void 0, function* () {
            const pages = yield Promise.all(this.drawPagesAsync(pdfPages));
            this.appendPages(pages);
            return pdfPages;
        }));
    }
    drawPagesAsync(pdfPages) {
        pdfPages = pdfPages || this.state.pdfPages;
        const hasPages = (this.pages || []).length > 0;
        if (!hasPages) {
            this.initPageComponents(pdfPages);
        }
        else {
            for (let i = 0; i < this.pages.length; i++) {
                const pageViewport = this.pages[i].getViewport({
                    scale: this.state.zoomLevel
                });
                // todo: adjust page viewport manually
                // otherwise, loading a document with links to the document
                // will not scroll to the specific page on click
                // pdf.js handles this in a more complex way
                // that will require porting more code
                this.pages[i].viewport = pageViewport;
            }
        }
        const pageRenderPromises = [];
        pdfPages.map((pdfPage, pageIndex) => __awaiter(this, void 0, void 0, function* () {
            const page = this.pages[pageIndex];
            if (this.options.loadOnDemand &&
                pageIndex >= this.options.loadOnDemandPageSize &&
                !page.element) {
                const blankPageElements = this.createBlankPageElements({ pdfPage, zoom: this.state.zoomLevel });
                if (page && !page.element) {
                    page.element = blankPageElements.pageElement;
                    page.setBlank(true);
                }
                const pageRenderPromise = createPromise();
                pageRenderPromises.push(pageRenderPromise);
                pageRenderPromise.then((renderedPage) => {
                    return renderedPage;
                });
                pageRenderPromise.resolve(page.element);
            }
            else if (this.options.loadOnDemand && page.isBlank()) {
                // keep blank pages on reload
                const pageRenderPromise = createPromise();
                pageRenderPromises.push(pageRenderPromise);
                pageRenderPromise.then((renderedPage) => {
                    return renderedPage;
                });
                pageRenderPromise.resolve(page.element);
            }
            else {
                const pageRenderPromise = this.drawPageAsync({ pageIndex });
                pageRenderPromises.push(pageRenderPromise);
                pageRenderPromise.then((renderedPage) => {
                    return renderedPage;
                });
            }
        }));
        return pageRenderPromises;
    }
    createBlankPageElements({ pdfPage, zoom }) {
        const pageElements = this.createPageElements({ pdfPage, zoom });
        pageElements.canvasWrapper.appendChild(pageElements.canvas);
        pageElements.pageElement.appendChild(pageElements.canvasWrapper);
        return pageElements;
    }
    getDocumentParameters(options) {
        let params = {
            verbosity: 0,
            isEvalSupported: true
        };
        if (typeof options.data === 'string' && options.data !== "") {
            params.data = parsePdfFromBase64String(options.data);
        }
        else if (typeof options.url === 'string' && options.url !== "") {
            params.url = options.url;
        }
        else if (options.arrayBuffer instanceof ArrayBuffer) {
            params = options.arrayBuffer;
        }
        else if (options.typedArray) {
            params = options.typedArray;
        }
        return params;
    }
    appendPages(pages) {
        pages.forEach(page => this.appendPage(page));
    }
    appendPage(page, pageIndex = null) {
        const pagesContainer = this.getPagesContainer();
        if (hasValue(pageIndex)) {
            pagesContainer === null || pagesContainer === void 0 ? void 0 : pagesContainer.insertBefore(page, pagesContainer.children[pageIndex]);
        }
        else {
            pagesContainer === null || pagesContainer === void 0 ? void 0 : pagesContainer.appendChild(page);
        }
    }
    drawPageAsync({ pageIndex = 0 }) {
        var _a;
        const index = clamp(pageIndex, 0, Math.max(0, this.state.pdfDocument.numPages - 1));
        return (_a = this.pages[index]) === null || _a === void 0 ? void 0 : _a.draw().then(() => {
            return this.pages[index].element;
        });
    }
    createPageElements({ pdfPage = null, zoom = 1, }) {
        if (zoom <= 0) {
            return;
        }
        const viewportScale = getScale();
        const scaleNum = zoom || viewportScale;
        const viewport = pdfPage === null || pdfPage === void 0 ? void 0 : pdfPage.getViewport({ scale: viewportScale });
        const { adjustedWidth, adjustedHeight, adjustRatio } = adjustCanvasSize(viewport.width, viewport.height);
        // const styles = {
        //     width: Math.floor(viewport.width / scaleNum) * zoom + 'pt',
        //     height: Math.floor(viewport.height / scaleNum) * zoom + 'pt'
        // };
        // use PageView.setLayerDimensions
        const { pageWidth, pageHeight } = viewport.rawDims;
        const styles = {
            // "round" is supported in all browsers since May 2024
            // https://developer.mozilla.org/en-US/docs/Web/CSS/round#browser_compatibility
            width: `round(var(--scale-factor) * ${pageWidth}px, 1px)`,
            height: `round(var(--scale-factor) * ${pageHeight}px, 1px)`
        };
        const pageElement = createElement("div", "k-page", styles);
        const canvas = createElement("canvas", '', {
            width: "100%",
            height: "100%"
        });
        canvas.height = adjustedHeight;
        canvas.width = adjustedWidth;
        const canvasContext = canvas.getContext("2d");
        const canvasWrapper = convertToHtml(`
            <div class="${this.options.elementSelectors.pageCanvasWrapper}"></div>
        `);
        // canvasWrapper.appendChild(canvas);
        // pageElement.appendChild(canvasWrapper);
        const adjustedScale = adjustRatio * scaleNum;
        viewport.width = adjustedWidth;
        viewport.height = adjustedHeight;
        viewport.scale = adjustedScale;
        return {
            canvasContext,
            canvasWrapper,
            canvas,
            viewport,
            scaleNum,
            pageElement,
            styles,
        };
    }
    triggerPagesLoad(e) {
        this.trigger(PAGES_LOAD, e);
    }
    triggerZoomStart(e) {
        this.trigger(ZOOM_START, e);
    }
    triggerZoomEnd(e) {
        this.trigger(ZOOM_END, e);
    }
    triggerDownload(e) {
        return this.trigger(DOWNLOAD, e);
    }
    triggerAnnotationEditorToolBarShow(e) {
        this.trigger(ANNOTATION_EDITOR_TOOLBAR_SHOW, e);
    }
    triggerAnnotationEditorToolBarHide(e) {
        this.trigger(ANNOTATION_EDITOR_TOOLBAR_HIDE, e);
    }
    clearDocument() {
        var _a;
        this.clearPagesElements();
        this.clearDocumentState();
        (_a = this.linkService) === null || _a === void 0 ? void 0 : _a.setDocument(null);
    }
    clearDocumentState() {
        this.state.pdfDocument = null;
        this.state.pdfPages = [];
        this.pages.forEach(x => x.destroy());
        this.pages = [];
    }
    initPageComponents(pdfPages) {
        // const scale = this.currentScale;
        // const currentScale = scale();
        const currentScale = this.options.zoomLevel;
        const viewport = pdfPages[0].getViewport({
            scale: currentScale * PixelsPerInch.PDF_TO_CSS_UNITS,
        });
        for (let pageNum = 1; pageNum <= pdfPages.length; pageNum++) {
            const pageIndex = pageNum - 1;
            const pageView = new Page(null, {
                pdfViewer: this,
                container: this.element,
                eventBus: this.eventBus,
                id: pageNum,
                scale: currentScale,
                viewport: viewport,
                defaultViewport: viewport,
                // optionalContentConfigPromise,
                // renderingQueue: this.renderingQueue,
                textLayerMode: TextLayerMode.ENABLE,
                annotationMode: AnnotationMode.ENABLE,
                // imageResourcesPath: this.imageResourcesPath,
                // maxCanvasPixels: this.maxCanvasPixels,
                // pageColors,
                // l10n: this.l10n,
                layerProperties: this._layerProperties,
                // enableHWA: this.#enableHWA,
            });
            this.pages.push(pageView);
            this.pages[pageIndex].setPdfPage(pdfPages[pageIndex]);
        }
    }
    destroyPageComponents() {
        this.pages.forEach(x => x.destroy());
        this.pages = [];
    }
    clearPagesElements() {
        const documentContainer = this.getDocumentContainer();
        const pagesContainer = this.getPagesContainer();
        if (!documentContainer || !pagesContainer || !this.hasDocument()) {
            return;
        }
        const pages = this.getPagesElements();
        pages.forEach(page => {
            // @ts-expect-error TS(2345): Argument of type 'unknown' is not assignable to pa... Remove this comment to see the full error message
            pagesContainer.removeChild(page);
        });
    }
    initDocumentContainer() {
        if (this.documentContainer) {
            return;
        }
        this.documentContainer = this.getDocumentContainer();
        this.initDocumentScroller(this.documentContainer);
    }
    initDocumentScroller(element) {
        if (this.documentScroller || !element) {
            return;
        }
        this.documentScroller = this.createDocumentScroller(element, {
            filter: toClassSelector(this.options.elementSelectors.pageSelector),
            events: {
                [SCROLL]: this.onDocumentScrollerScroll
            }
        });
    }
    createDocumentScroller(element, options) {
        return new Scroller(element, options);
    }
    destroyDocumentScroller() {
        if (!this.documentScroller) {
            return;
        }
        this.documentScroller.destroy();
        this.documentScroller = null;
    }
    enableDocumentScrollEventsTracking() {
        var _a;
        (_a = this.documentScroller) === null || _a === void 0 ? void 0 : _a.enableScrollEventsTracking();
    }
    disableDocumentScrollEventsTracking() {
        var _a;
        (_a = this.documentScroller) === null || _a === void 0 ? void 0 : _a.disableScrollEventsTracking();
    }
    getCurrentPageIndex() {
        return currentPage(this.element) || 0;
    }
    downloadFile({ fileName, saveOptions = {} }) {
        this.downloadDocument({
            options: {
                pdf: this.state.pdfDocument
            },
            fileName: fileName || this.options.downloadFileName,
            saveOptions: saveOptions
        });
    }
    downloadDocument({ options, fileName = "Document", saveOptions = {}, }) {
        if (options.pdf) {
            let exportMethod = options.pdf.getData.bind(options.pdf);
            let serializedAnnotationStorage = {};
            let originalAnnotationStorage = {};
            if (options.pdf.annotationStorage.size > 0) {
                exportMethod = options.pdf.saveDocument.bind(options.pdf);
                // saveDocument() has checks that test "editor instanceof AnnotationEditor", but they fail
                // because AnnotationEditor from "pdfjs-dist/legacy/build/pdf.mjs" is not exported
                // thus replace instances of editors with their serialized version
                // and then revert
                serializedAnnotationStorage = {};
                originalAnnotationStorage = options.pdf.annotationStorage.getAll();
                Object.keys(originalAnnotationStorage).forEach((key) => {
                    serializedAnnotationStorage[key] = originalAnnotationStorage[key].toJSON();
                });
                Object.keys(originalAnnotationStorage).forEach((key) => {
                    options.pdf.annotationStorage.remove(key);
                });
                Object.keys(serializedAnnotationStorage).forEach((key) => {
                    options.pdf.annotationStorage.setValue(key, serializedAnnotationStorage[key]);
                });
            }
            exportMethod()
                .then((data) => {
                return new Blob([data], { type: 'application/pdf' });
            })
                .then((blob) => {
                if (!this.triggerDownload({ blob, fileName, saveOptions })) {
                    this.saveFile(blob, fileName, saveOptions);
                }
            })
                .catch((e) => {
                this.triggerError(e);
            })
                .finally(() => {
                var _a;
                if (((_a = options.pdf) === null || _a === void 0 ? void 0 : _a.annotationStorage.size) <= 0) {
                    return;
                }
                const currentAnnotationStorage = options.pdf.annotationStorage.getAll();
                Object.keys(currentAnnotationStorage).forEach((key) => {
                    options.pdf.annotationStorage.remove(key);
                });
                Object.keys(originalAnnotationStorage).forEach((key) => {
                    options.pdf.annotationStorage.setValue(key, originalAnnotationStorage[key]);
                });
            });
        }
    }
    ;
    saveFile(blob, fileName, saveOptions) {
        try {
            saveAs(blob, fileName, saveOptions);
        }
        catch (_a) {
            return false;
        }
        return true;
    }
    hasDocument() {
        return hasValue(this.state.pdfDocument);
    }
    zoom(args) {
        args.zoomLevel = this.calculateZoomLevel({
            zoomLevel: args.zoomLevel,
            zoomLevelType: args.zoomLevelType,
            currentZoom: this.options.zoomLevel,
        });
        this.options.zoomLevel = args.zoomLevel;
        this.state.zoomLevel = args.zoomLevel;
        this.eventBus.dispatch("scalechanging", {
            source: this,
            scale: this.options.zoomLevel,
        });
        this.reloadFile(this.state.pdfDocument);
    }
    calculateZoomLevel({ zoomLevel, zoomLevelType, currentZoom }) {
        const documentContainer = this.getDocumentContainer();
        const page = documentContainer.querySelector(toClassSelector(this.options.elementSelectors.pageSelector));
        const pageSize = { width: page.offsetWidth, height: page.offsetHeight };
        let calculatedZoomLevel = clamp(zoomLevel || DEFAULT_ZOOM_LEVEL, this.options.minZoom, this.options.maxZoom);
        if (zoomLevelType === "ActualWidth" || zoomLevelType === "actualWidth") {
            calculatedZoomLevel = 1;
        }
        else if (zoomLevelType === "FitToWidth" || zoomLevelType === "fitToWidth") {
            calculatedZoomLevel = documentContainer.offsetWidth / (pageSize.width / currentZoom);
        }
        else if (zoomLevelType === "FitToPage" || zoomLevelType === "fitToPage") {
            calculatedZoomLevel = documentContainer.offsetHeight / (pageSize.height / currentZoom);
        }
        return calculatedZoomLevel;
    }
    reloadFile(pdfDoc) {
        const pagesPromises = [];
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            pagesPromises.push(pdfDoc.getPage(i));
        }
        this.disableDocumentScrollEventsTracking();
        this.drawPagesFromPromisesAsync(pagesPromises)
            .then((pdfPages) => {
            this.setHiddenCanvasStyles();
            this.onPagesLoad({ pdfPages, pdfDoc });
        })
            .catch((e) => {
            this.triggerError(e);
        });
        this.setScaleFactor(this.state.zoomLevel);
    }
    setHiddenCanvasStyles() {
        if (!this.options.pdfjsSetHiddenCanvasStyles) {
            return;
        }
        // required after pdf.js 4.x version
        const sheet = new CSSStyleSheet();
        sheet.replaceSync(`.hiddenCanvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            display: none;
        }`);
        this.getPagesContainer().ownerDocument.adoptedStyleSheets = [sheet];
    }
    printFile() {
        if (!this.hasDocument()) {
            return;
        }
        this.setState({
            isPrintingInProgress: true
        });
        if (this.options.zoomBeforePrint) {
            // such option existed in the Kendo jQuery version internally
            this.cacheZoomLevelBeforePrint();
            this.loadDocumentForPrintAsync({
                zoomLevel: this.options.zoomLevelBeforePrint,
                force: true
            })
                .then(() => {
                this.printDocumentAsync()
                    .then(() => {
                    this.trigger(PRINT_END);
                });
            })
                .catch(this.triggerError)
                .finally(() => {
                this.setState({
                    isPrintingInProgress: false
                });
                this.restoreZoomLevelBeforePrint();
            });
        }
        else {
            this.loadDocumentForPrintAsync({
                zoomLevel: this.state.zoomLevel,
                force: true
            })
                .then(() => {
                this.printDocumentAsync()
                    .then(() => {
                    this.trigger(PRINT_END);
                });
            })
                .catch(this.triggerError)
                .finally(() => {
                this.setState({
                    isPrintingInProgress: false
                });
            });
        }
    }
    loadDocumentForPrintAsync({ zoomLevel = DEFAULT_ZOOM_LEVEL, force = false }) {
        const pages = this.pages;
        const pageLoadPromises = [];
        const loadPromise = createPromise();
        for (let i = 0; i < pages.length; i++) {
            const pageLoadPromise = pages[i].loadForPrintAsync({
                zoomLevel: zoomLevel,
                force: force
            });
            pageLoadPromises.push(pageLoadPromise);
        }
        Promise.all(pageLoadPromises)
            .then(() => {
            // @ts-expect-error TS()
            loadPromise.resolve();
        });
        return loadPromise;
    }
    getPagesPrintContentAsync(printContainer) {
        const pages = this.pages;
        const pagePrintPromises = [];
        for (let i = 0; i < pages.length; i++) {
            const pagePrintPromise = pages[i].getPrintContentAsync();
            pagePrintPromise.then((pagePrintContent) => {
                const pageWrapper = convertToHtml(`<div></div>`);
                pageWrapper.appendChild(pagePrintContent);
                printContainer.appendChild(pageWrapper);
            });
            pagePrintPromises.push(pagePrintPromise);
        }
        return pagePrintPromises;
    }
    initPrintContainer() {
        this.printContainer = convertToHtml(`<div></div>`);
    }
    openPrintDialog() {
        const pages = this.pages;
        const width = pages[0].rawWidth;
        const height = pages[0].rawHeight;
        const printDialog = window.open('', '', 'innerWidth=' + width + ',innerHeight=' + height + 'location=no,titlebar=no,toolbar=no');
        if (!printDialog || !printDialog.document) {
            this.triggerError({
                message: this.options.messages.errorMessages.popupBlocked
            });
            return;
        }
        printDialog.document.body.style.margin = '0';
        printDialog.document.body.appendChild(this.printContainer);
        const afterPrintHandler = () => {
            printDialog.removeEventListener("afterprint", afterPrintHandler);
            printDialog.close();
        };
        printDialog.addEventListener("afterprint", afterPrintHandler);
        printDialog.focus();
        printDialog.print();
        // setTimeout(() => {
        // printDialog.print();
        // done();
        // });
    }
    cacheZoomLevelBeforePrint() {
        this.setState({
            zoomLevelBeforePrint: this.state.zoomLevel
        });
    }
    restoreZoomLevelBeforePrint() {
        if (this.state.zoomLevelBeforePrint === this.state.zoomLevel) {
            return;
        }
        this.zoom({
            zoomLevel: this.state.zoomLevelBeforePrint,
            zoomLevelType: this.state.zoomLevelType,
            currentZoom: this.state.zoomLevel
        });
    }
    searchText(options = { text: "", matchCase: false }) {
        var _a;
        this.initSearchService();
        const matches = (_a = this.searchService) === null || _a === void 0 ? void 0 : _a.search(options);
        return matches;
    }
    clearSearch() {
        this.destroySearchService();
    }
    initSearchService() {
        const textLayers = Array.from(this.wrapper.querySelectorAll(toClassSelector(this.options.elementSelectors.textLayerClass)) || []);
        if (this.searchService) {
            // refresh text nodes as text layers have changed
            if (textLayers.every((x, i) => x === this.searchService.options.textContainers[i])) {
                return;
            }
            else {
                this.destroySearchService();
            }
        }
        this.searchService = new SearchService({
            textContainers: textLayers,
            highlightClass: this.options.elementSelectors.searchHighlightClass,
            highlightMarkClass: this.options.elementSelectors.searchHighlightMarkClass,
            charClass: this.options.elementSelectors.charClass
        });
    }
    destroySearchService() {
        if (!this.searchService) {
            return;
        }
        this.searchService.destroy();
        this.searchService = null;
    }
    goToNextSearchMatch() {
        if (!this.searchService) {
            return;
        }
        this.searchService.markNextMatch();
        const matchElement = this.searchService.getActiveMatchElement();
        this.scrollToSearchMatch(matchElement);
    }
    goToPreviousSearchMatch() {
        if (!this.searchService) {
            return;
        }
        this.searchService.markPreviousMatch();
        const matchElement = this.searchService.getActiveMatchElement();
        this.scrollToSearchMatch(matchElement);
    }
    getPagesContainer() {
        return this.element.querySelector(toClassSelector(this.options.elementSelectors.pagesContainerClass));
    }
    getDocumentContainer() {
        return this.wrapper.querySelector(toClassSelector(this.options.elementSelectors.documentContainerClass));
    }
    getPagesElements() {
        const documentContainer = this.getDocumentContainer();
        if (!documentContainer) {
            return [];
        }
        return toArray(documentContainer.querySelectorAll(toClassSelector(this.options.elementSelectors.pageSelector)));
    }
    scrollToSearchMatch(matchElement) {
        if (!matchElement) {
            return;
        }
        const closestCharElement = matchElement.closest('.k-text-char');
        const closestTextElement = closestCharElement
            ? closestCharElement.closest('span[role="presentation"]')
            : null;
        if (!closestTextElement) {
            return;
        }
        const closestPageElement = closestTextElement.closest('.k-page');
        if (!closestPageElement) {
            return;
        }
        const scrollLeft = closestPageElement.offsetLeft +
            -1 * this.documentScroller.element.offsetLeft +
            closestTextElement.offsetLeft +
            this.options.searchMatchScrollLeftOffset;
        const scrollTop = closestPageElement.offsetTop +
            -1 * this.documentScroller.element.offsetTop +
            closestTextElement.offsetTop +
            this.options.searchMatchScrollTopOffset;
        this.documentScroller.scrollTo(scrollLeft, scrollTop, { trackScrollEvent: false });
    }
    resetInteractionMode() {
        this.setInteractionMode({
            mode: PdfViewerInteractionMode.TextSelection
        });
    }
    setInteractionMode(args) {
        this.interactionMode = args.mode;
        if (this.interactionMode === PdfViewerInteractionMode.TextSelection) {
            this.disableScrollerEventsTracking();
            addClass(this.options.elementSelectors.enabledTextSelectionClass, this.documentScroller.element);
            removeClass(this.options.elementSelectors.enabledPanningClass, this.documentScroller.element);
        }
        else if (this.interactionMode === PdfViewerInteractionMode.Pan) {
            this.enableScrollerEventsTracking();
            removeClass(this.options.elementSelectors.enabledTextSelectionClass, this.documentScroller.element);
            addClass(this.options.elementSelectors.enabledPanningClass, this.documentScroller.element);
        }
    }
    enableScrollerEventsTracking() {
        if (!this.documentScroller) {
            return;
        }
        this.documentScroller.enablePanEventsTracking();
    }
    disableScrollerEventsTracking() {
        if (!this.documentScroller) {
            return;
        }
        this.documentScroller.disablePanEventsTracking();
    }
    setScaleFactor(scaleFactor) {
        this.element.style.setProperty('--scale-factor', String(scaleFactor * PixelsPerInch.PDF_TO_CSS_UNITS));
    }
    activatePageNumber(pageNumber) {
        const page = this.getPageByNumber(pageNumber);
        if (!page) {
            return;
        }
        const pageIndex = pageNumber - 1;
        if (this.state.activePageNumber === pageNumber) {
            return;
        }
        this.state.activePageNumber = pageNumber;
        if (page.isBlank()) {
            this.drawPageAsync({ pageIndex: pageIndex })
                .then(() => {
                this.scrollToPage({
                    pageNumber
                });
            });
        }
        else {
            this.scrollToPage({
                pageNumber
            });
        }
    }
    scrollToPage({ pageNumber }) {
        const { left, top } = this.getPageNumberScrollOffset(pageNumber);
        this.scrollDocument({
            left: left,
            top: top
        });
    }
    scrollDocument({ left, top }) {
        var _a;
        (_a = this.documentScroller) === null || _a === void 0 ? void 0 : _a.scrollTo(left, top, {
            // as we are manually scrolling to the page
            // we want to ignore the scroller's element scroll event
            // to avoid double handling of the scrolling
            trackScrollEvent: false
        });
    }
    getPageNumberScrollOffset(pageNumber) {
        const page = this.getPageByNumber(pageNumber);
        if (!page) {
            return {
                left: 0,
                top: 0
            };
        }
        // pages might have different sizes
        // although pdf.js does not fully support this
        const previousPages = this.pages.slice(0, Math.max(0, pageNumber - 1));
        const previousPagesScrollOffset = previousPages
            .map(x => {
            const pageScrollOffset = this.getPageScrollOffset(x);
            return pageScrollOffset;
        })
            .reduce((sum, pageScrollOffset) => sum + pageScrollOffset, 0);
        return {
            left: 0,
            top: previousPagesScrollOffset
        };
    }
    getPageScrollOffset(page) {
        var _a;
        const pageHeight = ((_a = page === null || page === void 0 ? void 0 : page.element) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().height) || 0;
        const computedStyles = getComputedStyle(page.element);
        const pageMarginTop = parseFloat(computedStyles.marginTop) || 0;
        return pageHeight + pageMarginTop;
    }
    getPageByNumber(pageNumber) {
        const page = this.pages && this.pages[pageNumber - 1];
        return page;
    }
    addHighlightAnnotation() {
        var _a;
        (_a = this.annotationEditorUIManager) === null || _a === void 0 ? void 0 : _a.highlightSelection();
    }
    setHighlightColor(color) {
        this.executeAnnotationCommand({
            commandType: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
            commandValue: color
        });
    }
    deleteAnnotation() {
        var _a;
        (_a = this.annotationEditorUIManager) === null || _a === void 0 ? void 0 : _a.delete();
    }
    resetAnnotationEditorMode() {
        this.setAnnotationEditorMode({
            mode: AnnotationEditorType.NONE,
            editId: null,
            isFromKeyboard: false
        });
    }
    setAnnotationEditorMode(modeDescriptor) {
        this.annotationEditorMode = modeDescriptor;
    }
    setFreeTextColor(color) {
        this.executeAnnotationCommand({
            commandType: AnnotationEditorParamsType.FREETEXT_COLOR,
            commandValue: color
        });
    }
    setFreeTextFontSize(fontSize) {
        this.executeAnnotationCommand({
            commandType: AnnotationEditorParamsType.FREETEXT_SIZE,
            commandValue: parseFloat(fontSize)
        });
    }
    executeAnnotationCommand({ commandType, commandValue }) {
        this.eventBus.dispatch("switchannotationeditorparams", {
            source: this,
            type: commandType,
            value: commandValue
        });
    }
    // todo: ported from pdf.js
    isValidAnnotationEditorMode(mode) {
        return Object.values(AnnotationEditorType).includes(mode) && mode !== AnnotationEditorType.DISABLE;
    }
    cleanupSwitchAnnotationEditorMode() {
        if (__classPrivateFieldGet(this, _PdfViewer_onPageRenderedCallback, "f")) {
            this.eventBus._off("pagerendered", __classPrivateFieldGet(this, _PdfViewer_onPageRenderedCallback, "f"));
            __classPrivateFieldSet(this, _PdfViewer_onPageRenderedCallback, null, "f");
        }
        if (__classPrivateFieldGet(this, _PdfViewer_switchAnnotationEditorModeTimeoutId, "f") !== null) {
            clearTimeout(__classPrivateFieldGet(this, _PdfViewer_switchAnnotationEditorModeTimeoutId, "f"));
            __classPrivateFieldSet(this, _PdfViewer_switchAnnotationEditorModeTimeoutId, null, "f");
        }
    }
    _getVisiblePages() {
        // const views =
        //     this._scrollMode === ScrollMode.PAGE
        //         ? this.#scrollModePageState.pages
        //         : this._pages,
        //     horizontal = this._scrollMode === ScrollMode.HORIZONTAL,
        //     rtl = horizontal && this._isContainerRtl;
        // return getVisibleElements({
        //     scrollEl: this.container,
        //     views,
        //     sortByVisibility: true,
        //     horizontal,
        //     rtl,
        // });
        return this.pages;
    }
    get _layerProperties() {
        const self = this;
        return shadow(this, "_layerProperties", {
            get annotationEditorUIManager() {
                return self.annotationEditorUIManager;
            },
            get annotationStorage() {
                var _a;
                return (_a = self.pdfDocument) === null || _a === void 0 ? void 0 : _a.annotationStorage;
            },
            // get downloadManager() {
            //     return self.downloadManager;
            // },
            // get enableScripting() {
            //     return !!self._scriptingManager;
            // },
            // get fieldObjectsPromise() {
            //     return self.pdfDocument?.getFieldObjects();
            // },
            // get findController() {
            //     return self.findController;
            // },
            // get hasJSActionsPromise() {
            //     return self.pdfDocument?.hasJSActions();
            // },
            get linkService() {
                return self.linkService;
            },
        });
    }
    /**
     * Scrolls page into view.
     * @param {ScrollPageIntoViewParameters} params
     */
    scrollPageIntoView({ pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false, }) {
        if (!this.pdfDocument) {
            return;
        }
        const pageView = Number.isInteger(pageNumber) && this.pages[pageNumber - 1];
        if (!pageView) {
            // console.error(
            //     `scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`
            // );
            return;
        }
        if (this.isInPresentationMode || !destArray) {
            this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);
            return;
        }
        let x = 0, y = 0;
        const width = 0, height = 0;
        // widthScale,
        // heightScale;
        const changeOrientation = pageView.rotation % 180 !== 0;
        // const pageWidth =
        //     (changeOrientation ? pageView.height : pageView.width) /
        //     pageView.scale /
        //     PixelsPerInch.PDF_TO_CSS_UNITS;
        const pageHeight = (changeOrientation ? pageView.rawWidth : pageView.rawHeight) /
            pageView.scale /
            PixelsPerInch.PDF_TO_CSS_UNITS;
        // let scale: any = 0;
        switch (destArray[1].name) {
            case "XYZ":
                x = destArray[2];
                y = destArray[3];
                // scale = destArray[4];
                // If x and/or y coordinates are not supplied, default to
                // _top_ left of the page (not the obvious bottom left,
                // since aligning the bottom of the intended page with the
                // top of the window is rarely helpful).
                x = x !== null ? x : 0;
                y = y !== null ? y : pageHeight;
                break;
            // case "Fit":
            // case "FitB":
            //     scale = "page-fit";
            //     break;
            // case "FitH":
            // case "FitBH":
            //     y = destArray[2];
            //     scale = "page-width";
            //     // According to the PDF spec, section 12.3.2.2, a `null` value in the
            //     // parameter should maintain the position relative to the new page.
            //     if (y === null && this._location) {
            //         x = this._location.left;
            //         y = this._location.top;
            //     } else if (typeof y !== "number" || y < 0) {
            //         // The "top" value isn't optional, according to the spec, however some
            //         // bad PDF generators will pretend that it is (fixes bug 1663390).
            //         y = pageHeight;
            //     }
            //     break;
            // case "FitV":
            // case "FitBV":
            //     x = destArray[2];
            //     width = pageWidth;
            //     height = pageHeight;
            //     scale = "page-height";
            //     break;
            // case "FitR":
            //     x = destArray[2];
            //     y = destArray[3];
            //     width = destArray[4] - x;
            //     height = destArray[5] - y;
            //     let hPadding = SCROLLBAR_PADDING,
            //         vPadding = VERTICAL_PADDING;
            //     if (
            //         (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) &&
            //         this.removePageBorders
            //     ) {
            //         hPadding = vPadding = 0;
            //     }
            //     widthScale =
            //         (this.container.clientWidth - hPadding) /
            //         width /
            //         PixelsPerInch.PDF_TO_CSS_UNITS;
            //     heightScale =
            //         (this.container.clientHeight - vPadding) /
            //         height /
            //         PixelsPerInch.PDF_TO_CSS_UNITS;
            //     scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
            //     break;
            default:
                // console.error(
                //     `scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`
                // );
                return;
        }
        if (!ignoreDestinationZoom) {
            // if (scale && scale !== this.options.zoomLevel) {
            // }
            // if (scale && scale !== this._currentScale) {
            // this.currentScaleValue = scale;
            // } else if (this._currentScale === UNKNOWN_SCALE) {
            // this.currentScaleValue = DEFAULT_SCALE_VALUE;
            // }
        }
        // if (scale === "page-fit" && !destArray[4]) {
        //     this.#scrollIntoView(pageView);
        //     return;
        // }
        const boundingRect = [
            pageView.viewport.convertToViewportPoint(x, y),
            pageView.viewport.convertToViewportPoint(x + width, y + height),
        ];
        let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
        let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
        if (!allowNegativeOffset) {
            // Some bad PDF generators will create destinations with e.g. top values
            // that exceeds the page height. Ensure that offsets are not negative,
            // to prevent a previous page from becoming visible (fixes bug 874482).
            left = Math.max(left, 0);
            top = Math.max(top, 0);
        }
        // left *= scale || this.state.zoomLevel;
        // top *= scale || this.state.zoomLevel;
        __classPrivateFieldGet(this, _PdfViewer_instances, "m", _PdfViewer_scrollIntoView).call(this, pageView, /* pageSpot = */ { left, top });
    }
    /**
     * @returns {boolean} Whether the pageNumber is valid (within bounds).
     * @private
     */
    _setCurrentPageNumber(val, resetCurrentPageView = false) {
        if (this._currentPageNumber === val) {
            if (resetCurrentPageView) {
                // this.#resetCurrentPageView();
            }
            return true;
        }
        // if (!(0 < val && val <= this.pagesCount)) {
        if (!(0 < val && val <= this.state.pdfDocument.numPages)) {
            return false;
        }
        const previous = this._currentPageNumber;
        this._currentPageNumber = val;
        this.eventBus.dispatch("pagechanging", {
            source: this,
            pageNumber: val,
            // pageLabel: this._pageLabels?.[val - 1] ?? null,
            previous,
        });
        // if (resetCurrentPageView) {
        //     this.#resetCurrentPageView();
        // }
        return true;
    }
}
_PdfViewer_annotationEditorMode = new WeakMap(), _PdfViewer_switchAnnotationEditorModeTimeoutId = new WeakMap(), _PdfViewer_eventAbortController = new WeakMap(), _PdfViewer_onPageRenderedCallback = new WeakMap(), _PdfViewer_instances = new WeakSet(), _PdfViewer_switchToEditAnnotationMode = function _PdfViewer_switchToEditAnnotationMode() {
    // const visible = this._getVisiblePages();
    // const visible = this._getVisiblePages();
    const pagesToRefresh = [];
    // const { ids, views } = visible;
    // for (const page of views) {
    const ids = new Set();
    this.pages.forEach(x => {
        ids.add(x.id);
    });
    for (const page of this.pages) {
        // const { view } = page;
        const view = page;
        if (!view.hasEditableAnnotations()) {
            ids.delete(view.id);
            continue;
        }
        pagesToRefresh.push(page);
    }
    if (pagesToRefresh.length === 0) {
        return null;
    }
    // this.renderingQueue.renderHighestPriority({
    //     first: pagesToRefresh[0],
    //     last: pagesToRefresh.at(-1),
    //     views: pagesToRefresh,
    //     ids,
    // });
    // todo: render pages instead of using renderingQueue
    // as this will require porting more code
    this.drawPagesAsync(this.state.pdfPages);
    return ids;
}, _PdfViewer_scrollIntoView = function _PdfViewer_scrollIntoView(pageView, pageSpot = null) {
    const { div, id } = pageView;
    // Ensure that `this._currentPageNumber` is correct, when `#scrollIntoView`
    // is called directly (and not from `#resetCurrentPageView`).
    if (this._currentPageNumber !== id) {
        this._setCurrentPageNumber(id);
    }
    // if (this._scrollMode === ScrollMode.PAGE) {
    //     this.#ensurePageViewVisible();
    //     // Ensure that rendering always occurs, to avoid showing a blank page,
    //     // even if the current position doesn't change when the page is scrolled.
    //     this.update();
    // }
    if (!pageSpot && !this.isInPresentationMode) {
        const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth;
        // const { scrollLeft, clientWidth } = this.container;
        const { scrollLeft, clientWidth } = this.element;
        if (this._scrollMode === ScrollMode.HORIZONTAL ||
            left < scrollLeft ||
            right > scrollLeft + clientWidth) {
            pageSpot = { left: 0, top: 0 };
        }
    }
    scrollIntoView(div, pageSpot);
    // // Ensure that the correct *initial* document position is set, when any
    // // OpenParameters are used, for documents with non-default Scroll/Spread
    // // modes (fixes issue 15695). This is necessary since the scroll-handler
    // // invokes the `update`-method asynchronously, and `this._location` could
    // // thus be wrong when the initial zooming occurs in the default viewer.
    // if (!this._currentScaleValue && this._location) {
    //     this._location = null;
    // }
};
