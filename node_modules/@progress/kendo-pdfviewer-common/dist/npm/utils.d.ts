import { SaveOptions } from '@progress/kendo-file-saver';
import { PDFPageProxy, PDFDocumentProxy } from "pdfjs-dist/legacy/build/pdf.mjs";
import { TypedArray } from "pdfjs-dist/types/src/display/api";
/**
 * @hidden
 */
export type DoneFn = (result: {
    pdfPages: PDFPageProxy[];
    pdfDoc: PDFDocumentProxy;
    zoom: number;
}) => void;
/**
 * @hidden
 */
export type ErrorFn = (e?: any) => void;
/**
 * @hidden
 */
export interface PDFReadParameters {
    url?: string;
    data?: string;
    arrayBuffer?: ArrayBuffer;
    typedArray?: TypedArray;
    loadOnDemand?: boolean;
    loadOnDemandPageSize?: number;
    error: ErrorFn;
}
/**
 * @hidden
 */
export interface PDFReadOptions extends PDFReadParameters {
    rootElement?: HTMLElement | null;
    dom: HTMLDivElement;
    zoom: number;
    done: DoneFn;
}
/**
 * @hidden
 */
export interface PDFReloadParameters {
    pdfDoc: PDFDocumentProxy;
    zoom: number;
    dom: HTMLElement;
    rootElement?: HTMLElement | null;
    loadOnDemand?: boolean;
    done: (pdfPages: PDFPageProxy[]) => void;
    error: ErrorFn;
}
/**
 * @hidden
 */
export declare const DEFAULT_ZOOM_LEVEL = 1.25;
export declare const scale: () => number;
export declare const parsePdfFromBase64String: (base64String: string) => string;
/**
 * @hidden
 */
export declare const removeChildren: (dom: HTMLElement) => void;
/**
 * @hidden
 */
export declare const download: (options: {
    pdf: PDFDocumentProxy | null;
    error: ErrorFn;
}, fileName: string, saveOptions: SaveOptions, onDownload: (blob: Blob, fileName: string, saveOptions: SaveOptions) => boolean) => void;
/**
 * @hidden
 */
export declare const loadPDF: (options: PDFReadOptions) => void;
/**
 * @hidden
 */
export declare const reloadDocument: (params: PDFReloadParameters) => void;
/**
 * @hidden
 */
export declare const print: (pages: PDFPageProxy[], done: () => void, error: ErrorFn) => void;
export declare const createElement: <T>(name: string, className: string, styles: {
    [key: string]: string;
}) => T;
export declare const transforms: {
    [rotation: string]: string;
};
export declare const renderPage: (page: PDFPageProxy, emptyPage: any, error: ErrorFn) => any;
/**
 * @hidden
 */
export declare const goToNextSearchMatch: (ref: any) => void;
/**
 * @hidden
 */
export declare const goToPreviousSearchMatch: (ref: any) => void;
/**
 * @hidden
 */
export declare const calculateZoomLevel: (zoomLevel: number, zoomLevelType: string, currentZoom: number, dom: HTMLDivElement) => number;
/**
 * Scrolls the PDFViewer document to the passed page number.
 *
 * @param rootElement The root HTML element of the PDFViewer component.
 * @param pageNumber The page number.
 */
export declare const scrollToPage: (rootElement: HTMLElement, pageNumber: number) => void;
/**
 * A function which gives you the page number of the document according to the scroll position.
 *
 * @param rootElement The root HTML element of the PDFViewer component.
 * @returns The page number.
 */
export declare const currentPage: (rootElement: HTMLElement) => number;
/**
 * @hidden
 *
 * related to https://github.com/telerik/kendo-pdfviewer-common/issues/6
 * the bigger the canvas size, the worse the performance;
 * if initial size after scaling is greater than browser limits,
 * we are limiting it to the limits, then halving it for performance.
 */
export declare const adjustCanvasSize: (targetWidth: number, targetHeight: number) => {
    adjustedWidth: number;
    adjustedHeight: number;
    adjustRatio: number;
};
