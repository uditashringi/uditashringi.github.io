"use strict";
/* Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _Outliner_instances, _Outliner_box, _Outliner_verticalEdges, _Outliner_intervals, _Outliner_getOutlines, _Outliner_binarySearch, _Outliner_insert, _Outliner_remove, _Outliner_breakEdge, _HighlightOutline_box, _HighlightOutline_outlines, _FreeOutliner_instances, _a, _FreeOutliner_box, _FreeOutliner_bottom, _FreeOutliner_innerMargin, _FreeOutliner_isLTR, _FreeOutliner_top, _FreeOutliner_last, _FreeOutliner_lastX, _FreeOutliner_lastY, _FreeOutliner_min, _FreeOutliner_min_dist, _FreeOutliner_scaleFactor, _FreeOutliner_thickness, _FreeOutliner_points, _FreeOutliner_MIN_DIST, _FreeOutliner_MIN_DIFF, _FreeOutliner_MIN, _FreeOutliner_getLastCoords, _FreeHighlightOutline_instances, _FreeHighlightOutline_box, _FreeHighlightOutline_bbox, _FreeHighlightOutline_innerMargin, _FreeHighlightOutline_isLTR, _FreeHighlightOutline_points, _FreeHighlightOutline_scaleFactor, _FreeHighlightOutline_outline, _FreeHighlightOutline_rescale, _FreeHighlightOutline_rescaleAndSwap, _FreeHighlightOutline_computeMinMax;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FreeOutliner = exports.Outliner = void 0;
const tslib_1 = require("tslib");
const pdf_mjs_1 = require("pdfjs-dist/legacy/build/pdf.mjs");
// import { Util } from "../../shared/utils";
class Outliner {
    /*
     * Construct an outliner.
     * @param {Array<Object>} boxes - An array of axis-aligned rectangles.
     * @param {number} borderWidth - The width of the border of the boxes, it
     *   allows to make the boxes bigger (or smaller).
     * @param {number} innerMargin - The margin between the boxes and the
     *   outlines. It's important to not have a null innerMargin when we want to
     *   draw the outline else the stroked outline could be clipped because of its
     *   width.
     * @param {boolean} isLTR - true if we're in LTR mode. It's used to determine
     *   the last point of the boxes.
     */
    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
        _Outliner_instances.add(this);
        _Outliner_box.set(this, void 0);
        _Outliner_verticalEdges.set(this, []);
        _Outliner_intervals.set(this, []);
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        // We round the coordinates to slightly reduce the number of edges in the
        // final outlines.
        const NUMBER_OF_DIGITS = 4;
        const EPSILON = Math.pow(10, -NUMBER_OF_DIGITS);
        // The coordinates of the boxes are in the page coordinate system.
        for (const { x, y, width, height } of boxes) {
            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
            const left = [x1, y1, y2, true];
            const right = [x2, y1, y2, false];
            tslib_1.__classPrivateFieldGet(this, _Outliner_verticalEdges, "f").push(left, right);
            minX = Math.min(minX, x1);
            maxX = Math.max(maxX, x2);
            minY = Math.min(minY, y1);
            maxY = Math.max(maxY, y2);
        }
        const bboxWidth = maxX - minX + 2 * innerMargin;
        const bboxHeight = maxY - minY + 2 * innerMargin;
        const shiftedMinX = minX - innerMargin;
        const shiftedMinY = minY - innerMargin;
        const lastEdge = tslib_1.__classPrivateFieldGet(this, _Outliner_verticalEdges, "f").at(isLTR ? -1 : -2);
        const lastPoint = [lastEdge[0], lastEdge[2]];
        // Convert the coordinates of the edges into box coordinates.
        for (const edge of tslib_1.__classPrivateFieldGet(this, _Outliner_verticalEdges, "f")) {
            const [x, y1, y2] = edge;
            edge[0] = (x - shiftedMinX) / bboxWidth;
            edge[1] = (y1 - shiftedMinY) / bboxHeight;
            edge[2] = (y2 - shiftedMinY) / bboxHeight;
        }
        tslib_1.__classPrivateFieldSet(this, _Outliner_box, {
            x: shiftedMinX,
            y: shiftedMinY,
            width: bboxWidth,
            height: bboxHeight,
            lastPoint
        }, "f");
    }
    getOutlines() {
        // We begin to sort lexicographically the vertical edges by their abscissa,
        // and then by their ordinate.
        tslib_1.__classPrivateFieldGet(this, _Outliner_verticalEdges, "f").sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
        // We're now using a sweep line algorithm to find the outlines.
        // We start with the leftmost vertical edge, and we're going to iterate
        // over all the vertical edges from left to right.
        // Each time we encounter a left edge, we're going to insert the interval
        // [y1, y2] in the set of intervals.
        // This set of intervals is used to break the vertical edges into chunks:
        // we only take the part of the vertical edge that isn't in the union of
        // the intervals.
        const outlineVerticalEdges = [];
        for (const edge of tslib_1.__classPrivateFieldGet(this, _Outliner_verticalEdges, "f")) {
            if (edge[3]) {
                // Left edge.
                outlineVerticalEdges.push(...tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_breakEdge).call(this, edge));
                tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_insert).call(this, edge);
            }
            else {
                // Right edge.
                tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_remove).call(this, edge);
                outlineVerticalEdges.push(...tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_breakEdge).call(this, edge));
            }
        }
        return tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_getOutlines).call(this, outlineVerticalEdges);
    }
}
exports.Outliner = Outliner;
_Outliner_box = new WeakMap(), _Outliner_verticalEdges = new WeakMap(), _Outliner_intervals = new WeakMap(), _Outliner_instances = new WeakSet(), _Outliner_getOutlines = function _Outliner_getOutlines(outlineVerticalEdges) {
    const edges = [];
    const allEdges = new Set();
    for (const edge of outlineVerticalEdges) {
        const [x, y1, y2] = edge;
        edges.push([x, y1, edge], [x, y2, edge]);
    }
    // We sort lexicographically the vertices of each edge by their ordinate and
    // by their abscissa.
    // Every pair (v_2i, v_{2i + 1}) of vertices defines a horizontal edge.
    // So for every vertical edge, we're going to add the two vertical edges
    // which are connected to it through a horizontal edge.
    edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
    for (let i = 0, ii = edges.length; i < ii; i += 2) {
        const edge1 = edges[i][2];
        const edge2 = edges[i + 1][2];
        edge1.push(edge2);
        edge2.push(edge1);
        allEdges.add(edge1);
        allEdges.add(edge2);
    }
    const outlines = [];
    let outline;
    while (allEdges.size > 0) {
        const edge = allEdges.values().next().value;
        let [x, y1, y2, edge1, edge2] = edge;
        allEdges.delete(edge);
        let lastPointX = x;
        let lastPointY = y1;
        outline = [x, y2];
        outlines.push(outline);
        while (true) {
            let e;
            if (allEdges.has(edge1)) {
                e = edge1;
            }
            else if (allEdges.has(edge2)) {
                e = edge2;
            }
            else {
                break;
            }
            allEdges.delete(e);
            [x, y1, y2, edge1, edge2] = e;
            if (lastPointX !== x) {
                outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
                lastPointX = x;
            }
            lastPointY = lastPointY === y1 ? y2 : y1;
        }
        outline.push(lastPointX, lastPointY);
    }
    return new HighlightOutline(outlines, tslib_1.__classPrivateFieldGet(this, _Outliner_box, "f"));
}, _Outliner_binarySearch = function _Outliner_binarySearch(y) {
    const array = tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f");
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
        const middle = (start + end) >> 1;
        const y1 = array[middle][0];
        if (y1 === y) {
            return middle;
        }
        if (y1 < y) {
            start = middle + 1;
        }
        else {
            end = middle - 1;
        }
    }
    return end + 1;
}, _Outliner_insert = function _Outliner_insert([, y1, y2]) {
    const index = tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_binarySearch).call(this, y1);
    tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f").splice(index, 0, [y1, y2]);
}, _Outliner_remove = function _Outliner_remove([, y1, y2]) {
    const index = tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_binarySearch).call(this, y1);
    for (let i = index; i < tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f").length; i++) {
        const [start, end] = tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f")[i];
        if (start !== y1) {
            break;
        }
        if (start === y1 && end === y2) {
            tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f").splice(i, 1);
            return;
        }
    }
    for (let i = index - 1; i >= 0; i--) {
        const [start, end] = tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f")[i];
        if (start !== y1) {
            break;
        }
        if (start === y1 && end === y2) {
            tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f").splice(i, 1);
            return;
        }
    }
}, _Outliner_breakEdge = function _Outliner_breakEdge(edge) {
    const [x, y1, y2] = edge;
    const results = [[x, y1, y2]];
    const index = tslib_1.__classPrivateFieldGet(this, _Outliner_instances, "m", _Outliner_binarySearch).call(this, y2);
    for (let i = 0; i < index; i++) {
        const [start, end] = tslib_1.__classPrivateFieldGet(this, _Outliner_intervals, "f")[i];
        for (let j = 0, jj = results.length; j < jj; j++) {
            const [, y3, y4] = results[j];
            if (end <= y3 || y4 <= start) {
                // There is no intersection between the interval and the edge, hence
                // we keep it as is.
                continue;
            }
            if (y3 >= start) {
                if (y4 > end) {
                    results[j][1] = end;
                }
                else {
                    if (jj === 1) {
                        return [];
                    }
                    // The edge is included in the interval, hence we remove it.
                    results.splice(j, 1);
                    j--;
                    jj--;
                }
                continue;
            }
            results[j][2] = start;
            if (y4 > end) {
                results.push([x, end, y4]);
            }
        }
    }
    return results;
};
class Outline {
    /**
     * @returns {string} The SVG path of the outline.
     */
    toSVGPath() {
        throw new Error("Abstract method `toSVGPath` must be implemented.");
    }
    /**
     * @type {Object|null} The bounding box of the outline.
     */
    get box() {
        throw new Error("Abstract getter `box` must be implemented.");
    }
    // serialize() {
    // serialize(_bbox, _rotation) {
    serialize([blX, blY, trX, trY]) {
        // throw new Error("Abstract method `serialize` must be implemented.");
        if (!blX || !blY || !trX || !trY) {
            return;
        }
    }
    get free() {
        return this instanceof FreeHighlightOutline;
        // return false;
    }
}
class HighlightOutline extends Outline {
    constructor(outlines, box) {
        super();
        _HighlightOutline_box.set(this, void 0);
        _HighlightOutline_outlines.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _HighlightOutline_outlines, outlines, "f");
        tslib_1.__classPrivateFieldSet(this, _HighlightOutline_box, box, "f");
    }
    toSVGPath() {
        const buffer = [];
        for (const polygon of tslib_1.__classPrivateFieldGet(this, _HighlightOutline_outlines, "f")) {
            let [prevX, prevY] = polygon;
            buffer.push(`M${prevX} ${prevY}`);
            for (let i = 2; i < polygon.length; i += 2) {
                const x = polygon[i];
                const y = polygon[i + 1];
                if (x === prevX) {
                    buffer.push(`V${y}`);
                    prevY = y;
                }
                else if (y === prevY) {
                    buffer.push(`H${x}`);
                    prevX = x;
                }
            }
            buffer.push("Z");
        }
        return buffer.join(" ");
    }
    /*
     * Serialize the outlines into the PDF page coordinate system.
     * @param {Array<number>} _bbox - the bounding box of the annotation.
     * @param {number} _rotation - the rotation of the annotation.
     * @returns {Array<Array<number>>}
     */
    // serialize([blX, blY, trX, trY], _rotation) {
    serialize([blX, blY, trX, trY]) {
        const outlines = [];
        const width = trX - blX;
        const height = trY - blY;
        for (const outline of tslib_1.__classPrivateFieldGet(this, _HighlightOutline_outlines, "f")) {
            const points = new Array(outline.length);
            for (let i = 0; i < outline.length; i += 2) {
                points[i] = blX + outline[i] * width;
                points[i + 1] = trY - outline[i + 1] * height;
            }
            outlines.push(points);
        }
        return outlines;
    }
    get box() {
        return tslib_1.__classPrivateFieldGet(this, _HighlightOutline_box, "f");
    }
}
_HighlightOutline_box = new WeakMap(), _HighlightOutline_outlines = new WeakMap();
class FreeOutliner {
    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        _FreeOutliner_instances.add(this);
        _FreeOutliner_box.set(this, void 0);
        _FreeOutliner_bottom.set(this, []);
        _FreeOutliner_innerMargin.set(this, void 0);
        _FreeOutliner_isLTR.set(this, void 0);
        _FreeOutliner_top.set(this, []);
        // The first 6 elements are the last 3 points of the top part of the outline.
        // The next 6 elements are the last 3 points of the line.
        // The next 6 elements are the last 3 points of the bottom part of the
        // outline.
        // We track the last 3 points in order to be able to:
        //  - compute the normal of the line,
        //  - compute the control points of the quadratic Bézier curve.
        _FreeOutliner_last.set(this, new Float64Array(18));
        _FreeOutliner_lastX.set(this, void 0);
        _FreeOutliner_lastY.set(this, void 0);
        _FreeOutliner_min.set(this, void 0);
        _FreeOutliner_min_dist.set(this, void 0);
        _FreeOutliner_scaleFactor.set(this, void 0);
        _FreeOutliner_thickness.set(this, void 0);
        _FreeOutliner_points.set(this, []);
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_box, box, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_thickness, thickness * scaleFactor, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_isLTR, isLTR, "f");
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([NaN, NaN, NaN, NaN, x, y], 6);
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_innerMargin, innerMargin, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_min_dist, tslib_1.__classPrivateFieldGet(_a, _a, "f", _FreeOutliner_MIN_DIST) * scaleFactor, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_min, tslib_1.__classPrivateFieldGet(_a, _a, "f", _FreeOutliner_MIN) * scaleFactor, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_scaleFactor, scaleFactor, "f");
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_points, "f").push(x, y);
    }
    get free() {
        return true;
    }
    isEmpty() {
        // When we add a second point then this.#last.slice(6) will be something
        // like [NaN, NaN, firstX, firstY, secondX, secondY,...] so having a NaN
        // at index 8 means that we've only one point.
        return isNaN(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[8]);
    }
    add({ x, y }) {
        var _b;
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_lastX, x, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeOutliner_lastY, y, "f");
        const [layerX, layerY, layerWidth, layerHeight] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f");
        let [x1, y1, x2, y2] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(8, 12);
        const diffX = x - x2;
        const diffY = y - y2;
        const d = Math.hypot(diffX, diffY);
        if (d < tslib_1.__classPrivateFieldGet(this, _FreeOutliner_min, "f")) {
            // The idea is to avoid garbage points around the last point.
            // When the points are too close, it just leads to bad normal vectors and
            // control points.
            return false;
        }
        const diffD = d - tslib_1.__classPrivateFieldGet(this, _FreeOutliner_min_dist, "f");
        const K = diffD / d;
        const shiftX = K * diffX;
        const shiftY = K * diffY;
        // We update the last 3 points of the line.
        let x0 = x1;
        let y0 = y1;
        x1 = x2;
        y1 = y2;
        x2 += shiftX;
        y2 += shiftY;
        // We keep track of the points in order to be able to compute the focus
        // outline.
        (_b = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_points, "f")) === null || _b === void 0 ? void 0 : _b.push(x, y);
        // Create the normal unit vector.
        // |(shiftX, shiftY)| = |K| * |(diffX, diffY)| = |K| * d = diffD.
        const nX = -shiftY / diffD;
        const nY = shiftX / diffD;
        const thX = nX * tslib_1.__classPrivateFieldGet(this, _FreeOutliner_thickness, "f");
        const thY = nY * tslib_1.__classPrivateFieldGet(this, _FreeOutliner_thickness, "f");
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(2, 8), 0);
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x2 + thX, y2 + thY], 4);
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(14, 18), 12);
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x2 - thX, y2 - thY], 16);
        if (isNaN(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[6])) {
            if (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f").length === 0) {
                tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x1 + thX, y1 + thY], 2);
                tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f").push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
                tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x1 - thX, y1 - thY], 14);
                tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f").push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
            }
            tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x0, y0, x1, y1, x2, y2], 6);
            return !this.isEmpty();
        }
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").set([x0, y0, x1, y1, x2, y2], 6);
        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
        if (angle < Math.PI / 2) {
            // In order to avoid some possible artifacts, we're going to use the a
            // straight line instead of a quadratic Bézier curve.
            [x1, y1, x2, y2] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(2, 6);
            tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f").push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
            [x1, y1, x0, y0] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(14, 18);
            tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f").push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
            return true;
        }
        // Control points and the final point for the quadratic Bézier curve.
        [x0, y0, x1, y1, x2, y2] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(0, 6);
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f").push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        [x2, y2, x1, y1, x0, y0] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(12, 18);
        tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f").push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        return true;
    }
    toSVGPath() {
        if (this.isEmpty()) {
            // We've only one point.
            return "";
        }
        const top = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f");
        const bottom = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f");
        const lastTop = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(4, 6);
        const lastBottom = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(16, 18);
        const [x, y, width, height] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f");
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_instances, "m", _FreeOutliner_getLastCoords).call(this);
        if (isNaN(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[6]) && !this.isEmpty()) {
            // We've only two points.
            return `M${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[2] - x) / width} ${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[3] - y) / height} L${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[4] - x) / width} ${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[16] - x) / width} ${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[17] - y) / height} L${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[14] - x) / width} ${(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f")[15] - y) / height} Z`;
        }
        const buffer = [];
        buffer.push(`M${top[4]} ${top[5]}`);
        for (let i = 6; i < top.length; i += 6) {
            if (isNaN(top[i])) {
                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
            }
            else {
                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
            }
        }
        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
        for (let i = bottom.length - 6; i >= 6; i -= 6) {
            if (isNaN(bottom[i])) {
                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
            }
            else {
                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
            }
        }
        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
        return buffer.join(" ");
    }
    getOutlines() {
        var _b, _c;
        const top = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f");
        const bottom = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f");
        const last = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f");
        const lastTop = last.subarray(4, 6);
        const lastBottom = last.subarray(16, 18);
        const [layerX, layerY, layerWidth, layerHeight] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f");
        const points = new Float64Array(((_c = (_b = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_points, "f")) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) + 2);
        for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
            points[i] = (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_points, "f")[i] - layerX) / layerWidth;
            points[i + 1] = (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_points, "f")[i + 1] - layerY) / layerHeight;
        }
        points[points.length - 2] = (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastX, "f") - layerX) / layerWidth;
        points[points.length - 1] = (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastY, "f") - layerY) / layerHeight;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_instances, "m", _FreeOutliner_getLastCoords).call(this);
        if (isNaN(last[6]) && !this.isEmpty()) {
            // We've only two points.
            const outlineObj = new Float64Array(36);
            outlineObj.set([
                NaN,
                NaN,
                NaN,
                NaN,
                (last[2] - layerX) / layerWidth,
                (last[3] - layerY) / layerHeight,
                NaN,
                NaN,
                NaN,
                NaN,
                (last[4] - layerX) / layerWidth,
                (last[5] - layerY) / layerHeight,
                NaN,
                NaN,
                NaN,
                NaN,
                lastTopX,
                lastTopY,
                NaN,
                NaN,
                NaN,
                NaN,
                lastBottomX,
                lastBottomY,
                NaN,
                NaN,
                NaN,
                NaN,
                (last[16] - layerX) / layerWidth,
                (last[17] - layerY) / layerHeight,
                NaN,
                NaN,
                NaN,
                NaN,
                (last[14] - layerX) / layerWidth,
                (last[15] - layerY) / layerHeight,
            ], 0);
            return new FreeHighlightOutline(outlineObj, points, tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_scaleFactor, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_innerMargin, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_isLTR, "f"));
        }
        const outline = new Float64Array(tslib_1.__classPrivateFieldGet(this, _FreeOutliner_top, "f").length + 24 + tslib_1.__classPrivateFieldGet(this, _FreeOutliner_bottom, "f").length);
        let N = top.length;
        for (let i = 0; i < N; i += 2) {
            if (isNaN(top[i])) {
                outline[i] = outline[i + 1] = NaN;
                continue;
            }
            outline[i] = top[i];
            outline[i + 1] = top[i + 1];
        }
        outline.set([
            NaN,
            NaN,
            NaN,
            NaN,
            (lastTop[0] - layerX) / layerWidth,
            (lastTop[1] - layerY) / layerHeight,
            NaN,
            NaN,
            NaN,
            NaN,
            lastTopX,
            lastTopY,
            NaN,
            NaN,
            NaN,
            NaN,
            lastBottomX,
            lastBottomY,
            NaN,
            NaN,
            NaN,
            NaN,
            (lastBottom[0] - layerX) / layerWidth,
            (lastBottom[1] - layerY) / layerHeight,
        ], N);
        N += 24;
        for (let i = bottom.length - 6; i >= 6; i -= 6) {
            for (let j = 0; j < 6; j += 2) {
                if (isNaN(bottom[i + j])) {
                    outline[N] = outline[N + 1] = NaN;
                    N += 2;
                    continue;
                }
                outline[N] = bottom[i + j];
                outline[N + 1] = bottom[i + j + 1];
                N += 2;
            }
        }
        outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], N);
        return new FreeHighlightOutline(outline, points, tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_scaleFactor, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_innerMargin, "f"), tslib_1.__classPrivateFieldGet(this, _FreeOutliner_isLTR, "f"));
    }
}
exports.FreeOutliner = FreeOutliner;
_a = FreeOutliner, _FreeOutliner_box = new WeakMap(), _FreeOutliner_bottom = new WeakMap(), _FreeOutliner_innerMargin = new WeakMap(), _FreeOutliner_isLTR = new WeakMap(), _FreeOutliner_top = new WeakMap(), _FreeOutliner_last = new WeakMap(), _FreeOutliner_lastX = new WeakMap(), _FreeOutliner_lastY = new WeakMap(), _FreeOutliner_min = new WeakMap(), _FreeOutliner_min_dist = new WeakMap(), _FreeOutliner_scaleFactor = new WeakMap(), _FreeOutliner_thickness = new WeakMap(), _FreeOutliner_points = new WeakMap(), _FreeOutliner_instances = new WeakSet(), _FreeOutliner_getLastCoords = function _FreeOutliner_getLastCoords() {
    const lastTop = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(4, 6);
    const lastBottom = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_last, "f").subarray(16, 18);
    const [x, y, width, height] = tslib_1.__classPrivateFieldGet(this, _FreeOutliner_box, "f");
    return [
        (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastX, "f") + (lastTop[0] - lastBottom[0]) / 2 - x) / width,
        (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastY, "f") + (lastTop[1] - lastBottom[1]) / 2 - y) / height,
        (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastX, "f") + (lastBottom[0] - lastTop[0]) / 2 - x) / width,
        (tslib_1.__classPrivateFieldGet(this, _FreeOutliner_lastY, "f") + (lastBottom[1] - lastTop[1]) / 2 - y) / height,
    ];
};
_FreeOutliner_MIN_DIST = { value: 8 };
_FreeOutliner_MIN_DIFF = { value: 2 };
_FreeOutliner_MIN = { value: tslib_1.__classPrivateFieldGet(_a, _a, "f", _FreeOutliner_MIN_DIST) + tslib_1.__classPrivateFieldGet(_a, _a, "f", _FreeOutliner_MIN_DIFF) };
class FreeHighlightOutline extends Outline {
    constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
        super();
        _FreeHighlightOutline_instances.add(this);
        _FreeHighlightOutline_box.set(this, void 0);
        _FreeHighlightOutline_bbox.set(this, null);
        _FreeHighlightOutline_innerMargin.set(this, void 0);
        _FreeHighlightOutline_isLTR.set(this, void 0);
        _FreeHighlightOutline_points.set(this, void 0);
        _FreeHighlightOutline_scaleFactor.set(this, void 0);
        _FreeHighlightOutline_outline.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_outline, outline, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_points, points, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_box, box, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_scaleFactor, scaleFactor, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_innerMargin, innerMargin, "f");
        tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_isLTR, isLTR, "f");
        tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_computeMinMax).call(this, isLTR);
        const { x, y, width, height } = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_bbox, "f");
        for (let i = 0, ii = outline.length; i < ii; i += 2) {
            outline[i] = (outline[i] - x) / width;
            outline[i + 1] = (outline[i + 1] - y) / height;
        }
        for (let i = 0, ii = points.length; i < ii; i += 2) {
            points[i] = (points[i] - x) / width;
            points[i + 1] = (points[i + 1] - y) / height;
        }
    }
    toSVGPath() {
        const buffer = [`M${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[4]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[5]}`];
        for (let i = 6, ii = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f").length; i < ii; i += 6) {
            if (isNaN(tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i])) {
                buffer.push(`L${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 4]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 5]}`);
                continue;
            }
            buffer.push(`C${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 1]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 2]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 3]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 4]} ${tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f")[i + 5]}`);
        }
        buffer.push("Z");
        return buffer.join(" ");
    }
    // @ts-expect-error(TS:2556)
    serialize([blX, blY, trX, trY], rotation) {
        const width = trX - blX;
        const height = trY - blY;
        let outline;
        let points;
        switch (rotation) {
            case 0:
                outline = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescale).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f"), blX, trY, width, -height);
                points = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescale).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f"), blX, trY, width, -height);
                break;
            case 90:
                outline = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescaleAndSwap).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f"), blX, blY, width, height);
                points = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescaleAndSwap).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f"), blX, blY, width, height);
                break;
            case 180:
                outline = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescale).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f"), trX, blY, -width, height);
                points = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescale).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f"), trX, blY, -width, height);
                break;
            case 270:
                outline = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescaleAndSwap).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f"), trX, trY, -width, -height);
                points = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_instances, "m", _FreeHighlightOutline_rescaleAndSwap).call(this, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f"), trX, trY, -width, -height);
                break;
            default: break;
        }
        return { outline: Array.from(outline), points: [Array.from(points)] };
    }
    get box() {
        return tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_bbox, "f");
    }
    getNewOutline(thickness, innerMargin) {
        // Build the outline of the highlight to use as the focus outline.
        const { x, y, width, height } = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_bbox, "f");
        const [layerX, layerY, layerWidth, layerHeight] = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_box, "f");
        const sx = width * layerWidth;
        const sy = height * layerHeight;
        const tx = x * layerWidth + layerX;
        const ty = y * layerHeight + layerY;
        const outliner = new FreeOutliner({
            x: tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f")[0] * sx + tx,
            y: tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f")[1] * sy + ty,
        }, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_box, "f"), tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_scaleFactor, "f"), thickness, tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_isLTR, "f"), innerMargin !== null && innerMargin !== void 0 ? innerMargin : tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_innerMargin, "f"));
        for (let i = 2; i < tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f").length; i += 2) {
            outliner.add({
                x: tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f")[i] * sx + tx,
                y: tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_points, "f")[i + 1] * sy + ty,
            });
        }
        return outliner.getOutlines();
    }
}
_FreeHighlightOutline_box = new WeakMap(), _FreeHighlightOutline_bbox = new WeakMap(), _FreeHighlightOutline_innerMargin = new WeakMap(), _FreeHighlightOutline_isLTR = new WeakMap(), _FreeHighlightOutline_points = new WeakMap(), _FreeHighlightOutline_scaleFactor = new WeakMap(), _FreeHighlightOutline_outline = new WeakMap(), _FreeHighlightOutline_instances = new WeakSet(), _FreeHighlightOutline_rescale = function _FreeHighlightOutline_rescale(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i = 0, ii = src.length; i < ii; i += 2) {
        dest[i] = tx + src[i] * sx;
        dest[i + 1] = ty + src[i + 1] * sy;
    }
    return dest;
}, _FreeHighlightOutline_rescaleAndSwap = function _FreeHighlightOutline_rescaleAndSwap(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i = 0, ii = src.length; i < ii; i += 2) {
        dest[i] = tx + src[i + 1] * sx;
        dest[i + 1] = ty + src[i] * sy;
    }
    return dest;
}, _FreeHighlightOutline_computeMinMax = function _FreeHighlightOutline_computeMinMax(isLTR) {
    const outline = tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_outline, "f");
    let lastX = outline[4];
    let lastY = outline[5];
    let minX = lastX;
    let minY = lastY;
    let maxX = lastX;
    let maxY = lastY;
    let lastPointX = lastX;
    let lastPointY = lastY;
    const ltrCallback = isLTR ? Math.max : Math.min;
    for (let i = 6, ii = outline.length; i < ii; i += 6) {
        if (isNaN(outline[i])) {
            minX = Math.min(minX, outline[i + 4]);
            minY = Math.min(minY, outline[i + 5]);
            maxX = Math.max(maxX, outline[i + 4]);
            maxY = Math.max(maxY, outline[i + 5]);
            if (lastPointY < outline[i + 5]) {
                lastPointX = outline[i + 4];
                lastPointY = outline[i + 5];
            }
            else if (lastPointY === outline[i + 5]) {
                lastPointX = ltrCallback(lastPointX, outline[i + 4]);
            }
        }
        else {
            const bbox = pdf_mjs_1.Util.bezierBoundingBox(lastX, lastY, 
            // @ts-expect-error(TS:2556)
            ...outline.slice(i, i + 6));
            minX = Math.min(minX, bbox[0]);
            minY = Math.min(minY, bbox[1]);
            maxX = Math.max(maxX, bbox[2]);
            maxY = Math.max(maxY, bbox[3]);
            if (lastPointY < bbox[3]) {
                lastPointX = bbox[2];
                lastPointY = bbox[3];
            }
            else if (lastPointY === bbox[3]) {
                lastPointX = ltrCallback(lastPointX, bbox[2]);
            }
        }
        lastX = outline[i + 4];
        lastY = outline[i + 5];
    }
    const x = minX - tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_innerMargin, "f"), y = minY - tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_innerMargin, "f"), width = maxX - minX + 2 * tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_innerMargin, "f"), height = maxY - minY + 2 * tslib_1.__classPrivateFieldGet(this, _FreeHighlightOutline_innerMargin, "f");
    tslib_1.__classPrivateFieldSet(this, _FreeHighlightOutline_bbox, { x, y, width, height, lastPoint: [lastPointX, lastPointY] }, "f");
};
// export { Outliner };
