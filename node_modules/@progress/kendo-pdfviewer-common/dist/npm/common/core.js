"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPromise = exports.mousewheelDelta = exports.toClassSelector = exports.toPixel = exports.convertToHtml = exports.noop = exports.hasValue = exports.isNotNull = exports.isDefined = exports.toArray = exports.isString = exports.isFunction = exports.deepExtend = exports.isDotNetObject = exports.isDomElement = exports.isHtmlElement = exports.isObject = exports.extend = void 0;
const component_1 = require("./component");
// @ts-expect-error TS(2556): A spread argument must either have a tuple type or... Remove this comment to see the full error message
const extend = (...args) => Object.assign(...args);
exports.extend = extend;
const isObject = (value) => value && typeof (value) === "object" && !Array.isArray(value);
exports.isObject = isObject;
const isHtmlElement = (element) => element instanceof HTMLElement;
exports.isHtmlElement = isHtmlElement;
const isDomElement = (element) => element instanceof Element;
exports.isDomElement = isDomElement;
/* eslint-disable no-undef */
// @ts-expect-error TS(2304): Cannot find name 'DotNet'.
const isDotNetObject = (value) => value && window && window.DotNet && window.DotNet.DotNetObject && value instanceof DotNet.DotNetObject;
exports.isDotNetObject = isDotNetObject;
/* eslint-enable no-undef */
const deepExtend = (target, ...sources) => {
    if (!sources.length) {
        return target;
    }
    const source = sources.shift();
    if ((0, exports.isObject)(target) && (0, exports.isObject)(source)) {
        for (const key in source) {
            if (source[key] instanceof component_1.Component) {
                target[key] = source[key];
            }
            else if ((0, exports.isHtmlElement)(source[key])) {
                target[key] = source[key];
            }
            else if (key === "dotNetInstance" || (0, exports.isDotNetObject)(source[key])) {
                // avoid cloning a DotNetObject as it might have circular properties
                // see https://github.com/telerik/blazor/issues/7507
                // the check for the name of our own option - "dotNetInstance"
                // is an additional guard against the Blazor API being different in other .NET versions
                target[key] = source[key];
            }
            else if (source[key] && source[key].buffer && source[key].buffer instanceof ArrayBuffer) {
                target[key] = source[key];
            }
            else if ((0, exports.isObject)(source[key]) && Object.getPrototypeOf(source[key]) !== Object.prototype) {
                target[key] = source[key];
            }
            else if ((0, exports.isObject)(source[key])) {
                if (!target[key] || !(0, exports.isObject)(target[key])) {
                    (0, exports.extend)(target, { [key]: {} });
                }
                (0, exports.deepExtend)(target[key], source[key]);
            }
            else {
                (0, exports.extend)(target, { [key]: source[key] });
            }
        }
    }
    return (0, exports.deepExtend)(target, ...sources);
};
exports.deepExtend = deepExtend;
const isFunction = fn => typeof (fn) === "function";
exports.isFunction = isFunction;
const isString = value => typeof (value) === "string";
exports.isString = isString;
const toArray = value => Array.from(value);
exports.toArray = toArray;
const isDefined = value => typeof (value) !== "undefined";
exports.isDefined = isDefined;
const isNotNull = value => value !== null;
exports.isNotNull = isNotNull;
const hasValue = value => (0, exports.isDefined)(value) && (0, exports.isNotNull)(value);
exports.hasValue = hasValue;
const noop = function () { };
exports.noop = noop;
const convertToHtml = (htmlString, ownerDocument) => {
    const template = (ownerDocument || document).createElement('template');
    template.innerHTML = htmlString.trim();
    const content = template.content;
    if (content.childNodes.length > 1) {
        return content.childNodes;
    }
    return content.firstChild;
};
exports.convertToHtml = convertToHtml;
const toPixel = value => parseFloat(value) + "px";
exports.toPixel = toPixel;
const toClassSelector = (className) => (className === null || className === void 0 ? void 0 : className.startsWith(".")) ? className : `.${className}`;
exports.toClassSelector = toClassSelector;
const mousewheelDelta = (e) => {
    let delta = 0;
    if (e.wheelDelta) {
        delta = -e.wheelDelta / 120;
    }
    else if (e.detail) {
        delta = e.detail / 3;
    }
    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    return delta;
};
exports.mousewheelDelta = mousewheelDelta;
const createPromise = () => {
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function (resolve, reject) {
        resolveFn = resolve;
        rejectFn = reject;
    });
    // @ts-expect-error TS(2339): Property 'resolve' does not exist on type 'Promise... Remove this comment to see the full error message
    promise.resolve = resolveFn;
    // @ts-expect-error TS(2339): Property 'reject' does not exist on type 'Promise<... Remove this comment to see the full error message
    promise.reject = rejectFn;
    return promise;
};
exports.createPromise = createPromise;
