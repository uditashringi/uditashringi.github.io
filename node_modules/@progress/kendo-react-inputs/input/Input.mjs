/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as r from "react";
import a from "prop-types";
import { validatePackage as J, applyDefaultProps as Q, useUnstyled as W, useId as X, classNames as Y, uInput as Z, createPropsContext as _ } from "@progress/kendo-react-common";
import { FloatingLabel as $ } from "@progress/kendo-react-labels";
import { packageMetadata as ee } from "../package-metadata.mjs";
const C = r.forwardRef((I, L) => {
  const M = r.useContext(te).call(void 0, I);
  J(ee);
  const [, P] = r.useReducer((t) => t, !0), i = Q(M, ae), {
    className: x,
    label: o,
    labelClassName: E,
    id: N,
    validationMessage: p,
    defaultValue: k,
    valid: f,
    unstyled: R,
    // Removed to support direct use in Form Field component
    visited: ie,
    touched: ne,
    modified: se,
    autoFocus: V,
    ariaLabelledBy: w,
    ariaDescribedBy: F,
    validityStyles: m,
    style: y,
    ariaLabel: U,
    ...B
  } = i, D = W(), u = R || D, O = u && u.uInput, S = X(), [T, q] = r.useState({
    value: k
  }), g = N || S, e = r.useRef(null), s = r.useRef(void 0), c = r.useRef(null), A = () => {
    e.current && e.current.focus();
  }, d = () => s.current !== void 0 ? s.current : i.value !== void 0 ? i.value : T.value, l = () => {
    const t = {
      badInput: e.current ? e.current.validity.badInput : !1,
      patternMismatch: e.current ? e.current.validity.patternMismatch : !1,
      rangeOverflow: e.current ? e.current.validity.rangeOverflow : !1,
      rangeUnderflow: e.current ? e.current.validity.rangeUnderflow : !1,
      stepMismatch: e.current ? e.current.validity.stepMismatch : !1,
      tooLong: e.current ? e.current.validity.tooLong : !1,
      typeMismatch: e.current ? e.current.validity.typeMismatch : !1,
      valueMissing: e.current ? e.current.validity.valueMissing : !1
    };
    return {
      ...t,
      customError: p !== void 0,
      valid: f !== void 0 ? f : e.current ? !G(t) : !0
    };
  };
  r.useImperativeHandle(c, () => ({
    element: e.current,
    props: i,
    get value() {
      return d();
    },
    name: i.name,
    get validity() {
      return l();
    },
    focus: A
  })), r.useImperativeHandle(L, () => c.current);
  const G = (t) => {
    let n = !1;
    for (const h in t)
      t.hasOwnProperty(h) && (n = n || !!t[h]);
    return n;
  }, v = !m || l().valid, H = Y(
    x,
    Z.input({
      c: O,
      invalid: !v,
      disabled: i.disabled
    })
  ), K = () => {
    e.current && e.current.setCustomValidity && (l().valid || !m ? e.current.classList.remove("k-invalid") : e.current.classList.add("k-invalid"), e.current.setCustomValidity(l().valid ? "" : p || ""));
  }, j = (t) => {
    q({
      value: t.target.value
    }), s.current = t.target.value, i.onChange && i.onChange.call(void 0, {
      syntheticEvent: t,
      nativeEvent: t.nativeEvent,
      value: t.target.value,
      target: c.current
    }), s.current = void 0;
  }, z = (t) => {
    if (t.animationName === "autoFillStart") {
      const n = t.target.parentNode;
      n && n.classList.contains("k-empty") && n.classList.remove("k-empty");
    }
  };
  r.useEffect(() => {
    P();
  }, []), r.useEffect(() => {
    K();
  });
  const b = /* @__PURE__ */ r.createElement(
    "input",
    {
      "aria-labelledby": w,
      "aria-describedby": F,
      "aria-disabled": i.disabled || void 0,
      "aria-invalid": !v || void 0,
      "aria-label": U || void 0,
      ...B,
      style: o ? void 0 : y,
      value: d(),
      id: g,
      autoFocus: V,
      className: H,
      onChange: j,
      onAnimationStart: z,
      ref: e
    }
  );
  return o ? /* @__PURE__ */ r.createElement(
    $,
    {
      label: o,
      labelClassName: E,
      editorId: g,
      editorValue: String(d()),
      editorValid: v,
      editorDisabled: i.disabled,
      editorPlaceholder: i.placeholder,
      children: b,
      style: y,
      dir: i.dir,
      unstyled: u
    }
  ) : b;
}), te = _(), ae = {
  defaultValue: "",
  required: !1,
  validityStyles: !0,
  autoFocus: !1
};
C.displayName = "KendoReactInput";
C.propTypes = {
  label: a.string,
  labelClassName: a.string,
  validationMessage: a.string,
  required: a.bool,
  validate: a.bool,
  id: a.string,
  ariaLabelledBy: a.string,
  ariaDescribedBy: a.string,
  ariaLabel: a.string,
  autoFocus: a.bool,
  value: a.oneOfType([a.string, a.number, a.array])
};
export {
  C as Input,
  te as InputPropsContext
};
