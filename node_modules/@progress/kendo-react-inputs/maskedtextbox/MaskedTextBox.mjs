/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as d from "react";
import e from "prop-types";
import { MaskingService as k } from "./masking.service.mjs";
import { defaultRules as v, maskingChanged as E, returnFalse as m } from "./utils.mjs";
import { validatePackage as O, useCustomComponent as g, classNames as y, uMaskedTextBox as b, getTabIndex as V, createPropsContext as w, withIdHOC as I, withPropsContext as M, withUnstyledHOC as D } from "@progress/kendo-react-common";
import { FloatingLabel as H } from "@progress/kendo-react-labels";
import { packageMetadata as q } from "../package-metadata.mjs";
const l = class l extends d.Component {
  constructor(i) {
    super(i), this.state = {}, this._inputId = `k_${this.props.id}`, this._service = new k(), this._isPasted = !1, this._selection = [null, null], this._input = null, this.focus = () => {
      this._input && this._input.focus();
    }, this.pasteHandler = (t) => {
      const { selectionStart: r, selectionEnd: s } = t.target;
      s !== r && (this._isPasted = !0, this._selection = [r || 0, s || 0]);
    }, this.onChangeHandler = (t) => {
      const r = t.currentTarget, s = r.value, o = this._selection[0] || 0, a = this._selection[1] || 0;
      if (!this.props.mask) {
        this._isPasted = !1, this._selection = [null, null], this.triggerOnChange(s, t);
        return;
      }
      const p = this.value;
      let n;
      if (this._isPasted) {
        this._isPasted = !1;
        const u = p.length - a, h = s.length - u;
        n = this._service.maskInRange(s.slice(o, h), p, o, a);
      } else
        n = this._service.maskInput(s, p, r.selectionStart || 0);
      this._selection = [n.selection, n.selection], this.triggerOnChange(n.value, t);
    }, this.focusHandler = (t) => {
      this.state.focused || (this.setState({ focused: !0 }), this.props.onFocus && this.props.onFocus.call(void 0, {
        target: this,
        syntheticEvent: t,
        nativeEvent: t.nativeEvent
      }));
    }, this.blurHandler = (t) => {
      this.state.focused && (this.setState({ focused: !1 }), this.props.onBlur && this.props.onBlur.call(void 0, {
        target: this,
        syntheticEvent: t,
        nativeEvent: t.nativeEvent
      }));
    }, this.setValidity = () => {
      this.element && this.element.setCustomValidity(this.validity.valid ? "" : this.props.validationMessage || "");
    }, O(q);
  }
  /**
   * Gets the element of the MaskedTextBox.
   *
   * @return - An `HTMLInputElement`.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *     }
   *     element = null;
   *     render() {
   *         return (
   *             <div>
   *                 <MaskedTextBox
   *                     ref={(component) =>
   *                         this.element = component ? component.element : null}
   *                 />
   *                 <button onClick={() => console.log(this.element)}>console.log the element</button>
   *             </div>
   *         );
   *     }
   * }
   *
   * ReactDOM.render(
   *     <App />,
   *     document.getElementsByTagName('my-app')[0]
   * );
   * ```
   */
  get element() {
    return this._input;
  }
  /**
   * Gets the value with the mask of the MaskedTextBox.
   */
  get value() {
    return this._valueDuringOnChange !== void 0 ? this._valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value !== void 0 ? this.state.value : this.props.defaultValue !== void 0 ? this.props.defaultValue : "";
  }
  /**
   * Gets the raw value without the mask of the MaskedTextBox.
   */
  get rawValue() {
    return this._service.rawValue(this.value);
  }
  /**
   * Represents the validity state into which the MaskedTextBox is set.
   */
  get validity() {
    const i = this.value, t = this._service.validationValue(i), r = this.props.validationMessage !== void 0, s = this.props.valid !== void 0 ? this.props.valid : (!this.required || !!t) && (!this.props.maskValidation || !this.props.prompt || i.indexOf(this.props.prompt) === -1);
    return {
      customError: r,
      valid: s,
      valueMissing: !t
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : l.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : !1;
  }
  /**
   * Gets the `name` property of the MaskedTextBox.
   */
  get name() {
    return this.props.name;
  }
  /**
   * @hidden
   */
  componentDidUpdate(i, t) {
    if (this.element && this.state.focused && t.focused) {
      let [r, s] = this._selection;
      const o = i.selection, a = this.props.selection;
      (!o && a || o && a && (o.start !== a.start || o.end !== a.end)) && (r = a.start, s = a.end), r !== null && s !== null && this.element.setSelectionRange(r, s);
    }
    E(i, this.props) && this.updateService(), this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.updateService(), this.setValidity();
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: i = l.defaultProps.size,
      fillMode: t = l.defaultProps.fillMode,
      rounded: r = l.defaultProps.rounded,
      autoFocus: s = l.defaultProps.autoFocus,
      unstyled: o,
      className: a
    } = this.props, p = this.props.id || this._inputId, n = !this.validityStyles || this.validity.valid, u = this.props.style || {}, h = o && o.uMaskedTextBox, {
      prefix: P = l.defaultProps.prefix,
      suffix: _ = l.defaultProps.suffix
    } = this.props, [C] = g(P), [x] = g(_), f = /* @__PURE__ */ d.createElement(
      "span",
      {
        dir: this.props.dir,
        className: y(
          b.wrapper({
            c: h,
            invalid: !n,
            disabled: this.props.disabled,
            size: i,
            fillMode: t,
            rounded: r
          }),
          a
        ),
        style: this.props.label ? u : { width: this.props.width, ...u }
      },
      /* @__PURE__ */ d.createElement(C, null),
      /* @__PURE__ */ d.createElement(
        "input",
        {
          type: "text",
          autoComplete: "off",
          autoCorrect: "off",
          autoCapitalize: "off",
          autoFocus: s,
          spellCheck: !1,
          className: y(b.inputInner({ c: h })),
          value: this.value,
          id: p,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-describedby": this.props.ariaDescribedBy,
          "aria-placeholder": this.props.mask,
          "aria-required": this.props.required,
          name: this.props.name,
          tabIndex: V(this.props.tabIndex, this.props.disabled, !0),
          accessKey: this.props.accessKey,
          title: this.props.title,
          disabled: this.props.disabled || void 0,
          readOnly: this.props.readonly || void 0,
          placeholder: this.props.placeholder,
          ref: (S) => this._input = S,
          onChange: this.onChangeHandler,
          onPaste: this.pasteHandler,
          onFocus: this.focusHandler,
          onBlur: this.blurHandler,
          onDragStart: m,
          onDrop: m
        }
      ),
      /* @__PURE__ */ d.createElement(x, null)
    );
    return this.props.label ? /* @__PURE__ */ d.createElement(
      H,
      {
        label: this.props.label,
        editorId: p,
        editorValue: this.value,
        editorValid: n,
        editorDisabled: this.props.disabled,
        editorPlaceholder: this.props.placeholder,
        children: f,
        style: { width: this.props.width },
        dir: this.props.dir
      }
    ) : f;
  }
  triggerOnChange(i, t) {
    if (this.setState({
      value: i
    }), this.props.onChange) {
      this._valueDuringOnChange = i;
      const r = {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        selectionStart: this._selection[0],
        selectionEnd: this._selection[1],
        target: this,
        value: this.value
      };
      this.props.onChange.call(void 0, r), this._valueDuringOnChange = void 0;
    }
  }
  updateService(i) {
    const t = Object.assign(
      {
        includeLiterals: this.props.includeLiterals,
        mask: this.props.mask,
        prompt: this.props.prompt,
        promptPlaceholder: this.props.promptPlaceholder,
        rules: this.rules
      },
      i
    );
    this._service.update(t);
  }
  get rules() {
    return Object.assign({}, v, this.props.rules);
  }
};
l.displayName = "MaskedTextBox", l.propTypes = {
  value: e.string,
  defaultValue: e.string,
  placeholder: e.string,
  title: e.string,
  dir: e.string,
  id: e.string,
  style: e.object,
  className: e.string,
  prefix: e.any,
  suffix: e.any,
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  width: e.oneOfType([e.string, e.number]),
  tabIndex: e.number,
  accessKey: e.string,
  disabled: e.bool,
  readonly: e.bool,
  prompt: e.string,
  promptPlaceholder: e.string,
  includeLiterals: e.bool,
  maskValidation: e.bool,
  mask: e.string,
  rules: function(i, t, r) {
    const s = i.rules;
    return s !== void 0 && !Object.entries(s).some((a) => typeof a != "string" || !(s[a] instanceof RegExp)) ? new Error(
      "Invalid prop `" + t + "` supplied to `" + r + "`. Validation failed."
    ) : null;
  },
  selection: e.shape({
    start: e.number.isRequired,
    end: e.number.isRequired
  }),
  name: e.string,
  label: e.string,
  validationMessage: e.string,
  required: e.bool,
  valid: e.bool,
  validityStyles: e.bool,
  onChange: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  autoFocus: e.bool
}, l.defaultProps = {
  prompt: "_",
  promptPlaceholder: " ",
  includeLiterals: !1,
  maskValidation: !0,
  rules: v,
  validityStyles: !0,
  prefix: (i) => null,
  suffix: (i) => null,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: !1
};
let c = l;
const B = w(), F = I(
  M(
    B,
    D(c)
  )
);
F.displayName = "KendoReactMaskedTextBox";
export {
  F as MaskedTextBox,
  B as MaskedTextBoxPropsContext,
  c as MaskedTextBoxWithoutContext
};
