/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import R from "prop-types";
import { createPropsContext as Y, validatePackage as _, usePropsContext as j, useDir as F, Keys as m, useDraggable as J, classNames as Q, getTabIndex as M } from "@progress/kendo-react-common";
import { sliderDragTitle as S, messages as V } from "../messages/index.mjs";
import { useLocalization as Z } from "@progress/kendo-react-intl";
import { RANGE_ACTION as r, rangeReducer as ee } from "./range-raducer.mjs";
import { packageMetadata as te } from "../package-metadata.mjs";
const ae = (n, s, p) => {
  const [e, c] = a.useState(n), u = a.useCallback(
    (g) => {
      const b = ee(s.state || e, { ...g, ...s });
      p && p(b, g.event), c(b);
    },
    [s, p]
  );
  return [e, u];
}, re = Y(), z = a.forwardRef((n, s) => {
  _(te);
  const p = j(re, n), e = {
    step: y.step,
    largeStep: y.largeStep,
    defaultValue: y.defaultValue,
    vertical: y.vertical,
    disabled: y.disabled,
    ...p
  }, c = a.useRef(null), u = a.useRef(null), g = a.useRef(null), b = a.useRef(null), I = a.useRef(null), P = a.useCallback(() => {
    b.current && b.current.focus();
  }, [b]);
  a.useImperativeHandle(c, () => ({
    element: u.current,
    focus: P,
    props: e
  })), a.useImperativeHandle(s, () => c.current);
  const f = a.useMemo(() => e.min, [e.min]), k = a.useMemo(() => e.max, [e.max]), K = a.useMemo(
    () => e.step !== void 0 ? e.step : y.step,
    [e.step, y.step]
  ), A = a.useMemo(
    () => e.largeStep !== void 0 ? e.largeStep : y.largeStep,
    [e.largeStep, y.largeStep]
  ), d = F(u, e.dir), H = (t, o) => {
    e.onChange && c.current && e.onChange.call(void 0, {
      value: t,
      target: c.current,
      syntheticEvent: o
    });
  }, [T, E] = a.useState(""), [x, l] = ae(
    e.defaultValue || y.defaultValue,
    {
      min: f,
      max: k,
      step: K,
      largeStep: A,
      state: e.value
    },
    H
  ), i = a.useMemo(() => e.value || x, [e.value, x]), N = a.useRef(null), w = a.useRef(null), h = a.useMemo(() => (i.start - f) / (k - f) * 100, [i.start, f, k]), D = a.useMemo(() => (i.end - f) / (k - f) * 100, [i.end, f, k]), q = a.useMemo(
    () => e.vertical ? { paddingTop: 0, height: "100%" } : {},
    [e.vertical]
  ), B = a.useMemo(
    () => e.vertical ? { marginTop: "0.5rem", marginBottom: "0.5rem" } : { marginLeft: "0.5rem", marginRight: "0.5rem" },
    [e.vertical]
  ), L = Z(), $ = a.useCallback(
    (t) => {
      if (!w.current)
        return;
      const o = w.current.getBoundingClientRect(), v = e.vertical ? o.bottom - t.clientY : d === "rtl" ? o.right - t.clientX : t.clientX - o.left, C = e.vertical ? o.height : o.width, W = v / C;
      return f + W * (k - f);
    },
    [
      w,
      e.vertical,
      d,
      f,
      k,
      x.start,
      x.end,
      e.value && e.value.start,
      e.value && e.value.end
    ]
  ), G = a.useCallback(
    (t) => t <= i.start ? "start" : t >= i.end ? "end" : 2 * t < i.end + i.start ? "start" : "end",
    [x.start, x.end, e.value && e.value.start, e.value && e.value.end]
  ), O = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case m.right:
          t.preventDefault(), l({
            type: d === "rtl" ? r.decrease : r.increase,
            key: "start",
            event: t
          });
          break;
        case m.up:
          t.preventDefault(), l({ type: r.increase, key: "start", event: t });
          break;
        case m.left:
          t.preventDefault(), l({
            type: d === "rtl" ? r.increase : r.decrease,
            key: "start",
            event: t
          });
          break;
        case m.down:
          t.preventDefault(), l({ type: r.decrease, key: "start", event: t });
          break;
        case m.home:
          t.preventDefault(), l({ type: r.min, key: "start", event: t });
          break;
        case m.end:
          t.preventDefault(), l({ type: r.max, key: "start", event: t });
          break;
        case m.pageDown:
          t.preventDefault(), l({
            type: d === "rtl" ? r.increaseLarge : r.decreaseLarge,
            key: "start",
            event: t
          });
          break;
        case m.pageUp:
          t.preventDefault(), l({
            type: d === "rtl" ? r.decreaseLarge : r.increaseLarge,
            key: "start",
            event: t
          });
          break;
      }
    },
    [l]
  ), U = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case m.right:
          t.preventDefault(), l({
            type: d === "rtl" ? r.decrease : r.increase,
            key: "end",
            event: t
          });
          break;
        case m.up:
          t.preventDefault(), l({ type: r.increase, key: "end", event: t });
          break;
        case m.left:
          t.preventDefault(), l({
            type: d === "rtl" ? r.increase : r.decrease,
            key: "end",
            event: t
          });
          break;
        case m.down:
          t.preventDefault(), l({ type: r.decrease, key: "end", event: t });
          break;
        case m.home:
          t.preventDefault(), l({ type: r.min, key: "end", event: t });
          break;
        case m.end:
          t.preventDefault(), l({ type: r.max, key: "end", event: t });
          break;
        case m.pageDown:
          t.preventDefault(), l({
            type: d === "rtl" ? r.increaseLarge : r.decreaseLarge,
            key: "end",
            event: t
          });
          break;
        case m.pageUp:
          t.preventDefault(), l({
            type: d === "rtl" ? r.decreaseLarge : r.increaseLarge,
            key: "end",
            event: t
          });
          break;
      }
    },
    [l, d]
  ), X = a.useCallback(
    (t) => {
      const o = $(t), v = G(o);
      E(v), v === "end" ? I.current.focus() : b.current.focus();
      const C = v === "end" ? r.end : r.start;
      l({ type: C, payload: o, event: t });
    },
    [e.vertical, f, k, l]
  );
  return J(
    w,
    {
      onPress: X,
      onDrag: (t) => {
        const o = $(t), v = T === "end" ? r.end : r.start;
        l({ type: v, payload: o, event: t });
      },
      onRelease: (t) => {
        const o = $(t), v = T === "end" ? r.end : r.start;
        l({ type: v, payload: o, event: t }), E("");
      }
    },
    { autoScroll: !1 }
  ), /* @__PURE__ */ a.createElement(
    "div",
    {
      id: e.id,
      style: e.style,
      ref: u,
      dir: d,
      className: Q(
        "k-slider",
        {
          "k-rtl": d === "rtl",
          "k-disabled": e.disabled,
          "k-slider-vertical": e.vertical,
          "k-slider-horizontal": !e.vertical
        },
        e.className
      )
    },
    /* @__PURE__ */ a.createElement(
      "div",
      {
        ref: w,
        className: "k-slider-track-wrap",
        style: {
          flexGrow: 1,
          position: "relative",
          touchAction: "none",
          ...B
        }
      },
      e.children && /* @__PURE__ */ a.createElement("ul", { className: "k-reset k-slider-items", style: { ...q } }, a.Children.map(e.children, (t, o) => t && a.cloneElement(
        t,
        {
          position: 100 * (t.props.position - e.min) / (e.max - e.min),
          vertical: e.vertical,
          firstTick: o === 0,
          lastTick: o === a.Children.count(e.children) - 1
        },
        t.props.children
      ))),
      /* @__PURE__ */ a.createElement(
        "div",
        {
          ref: N,
          className: "k-slider-track",
          style: e.vertical ? { bottom: 0, height: "100%" } : { [d === "rtl" ? "right" : "left"]: 0, width: "100%" }
        },
        h !== null && D !== null && /* @__PURE__ */ a.createElement(
          "div",
          {
            "data-selection": !0,
            ref: g,
            title: `${i.start} - ${i.end}`,
            className: "k-slider-selection",
            style: e.vertical ? { height: D - h + "%", bottom: h + "%" } : {
              [d === "rtl" ? "right" : "left"]: h + "%",
              width: D - h + "%"
            }
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: b,
            role: "slider",
            tabIndex: M(e.startTabIndex, e.disabled, void 0),
            "aria-valuemin": f,
            "aria-valuemax": Math.max(k, i.end),
            "aria-valuenow": i.start,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${i.start} - ${i.end}`,
            className: "k-draghandle k-draghandle-start",
            title: L.toLanguageString(S, V[S]),
            style: e.vertical ? { bottom: "calc(" + h + "%)", zIndex: 1 } : d === "rtl" ? { right: "calc(" + h + "% - 13px)", zIndex: 1 } : { left: "calc(" + h + "%)", zIndex: 1 },
            onKeyDown: O
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: I,
            role: "slider",
            tabIndex: M(e.endTabIndex, e.disabled, void 0),
            "aria-valuemin": Math.min(f, i.start),
            "aria-valuemax": k,
            "aria-valuenow": i.end,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${i.start} - ${i.end}`,
            className: "k-draghandle k-draghandle-end",
            title: L.toLanguageString(S, V[S]),
            style: e.vertical ? { bottom: "calc(" + D + "%)", zIndex: 1 } : d === "rtl" ? { right: "calc(" + D + "% - 13px)", zIndex: 1 } : { left: "calc(" + D + "%)", zIndex: 1 },
            onKeyDown: U
          }
        )
      )
    )
  );
}), ne = {
  value: (n, s, p) => {
    if (n.value) {
      const e = n.value.start, c = n.value.end, u = n.min, g = n.max;
      if (e > c || e > g || e < u || c > g || c < u || c < e)
        return new Error(
          `Invalid prop + ${s} supplied to ${p}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  defaultValue: (n, s, p) => {
    if (n.defaultValue) {
      const e = n.defaultValue.start, c = n.defaultValue.end, u = n.min, g = n.max;
      if (e > c || e > g || e < u || c > g || c < u || c < e)
        return new Error(
          `Invalid prop + ${s} supplied to ${p}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  onChange: R.func,
  step: R.number,
  min: (n, s, p) => {
    const e = n[s], c = n.min, u = n.max;
    return c === void 0 ? new Error(
      `Invalid prop + ${s} supplied to ${p}.
                ${s} value can not be undefined.
                `
    ) : e && c >= u ? new Error(
      `Invalid prop + ${s} supplied to ${p}.
                ${s} value can not be equal to or bigger than the max value.
                `
    ) : null;
  },
  max: (n, s, p) => {
    const e = n[s], c = n.min, u = n.max;
    return u === void 0 ? new Error(
      `Invalid prop + ${s} supplied to ${p}.
                ${s} value can not be undefined.
                `
    ) : e && u <= c ? new Error(
      `Invalid prop + ${s} supplied to ${p}.
                ${s} value can not be equal to or smaller than the min value.
                `
    ) : null;
  },
  vertical: R.bool,
  disabled: R.bool,
  dir: R.oneOf(["ltr", "rtl"])
}, y = {
  step: 1,
  largeStep: 10,
  defaultValue: {
    start: 0,
    end: 0
  },
  vertical: !1,
  disabled: !1
};
z.displayName = "KendoReactRangeSlider";
z.propTypes = ne;
export {
  z as RangeSlider,
  re as RangeSliderPropsContext
};
