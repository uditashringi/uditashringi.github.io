/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import e from "prop-types";
import { createPropsContext as ie, usePropsContext as ue, useCustomComponent as F, useId as de, useDir as ce, useIsomorphicLayoutEffect as fe, dispatchEvent as y, classNames as M, getTabIndex as me, kendoThemeMaps as O } from "@progress/kendo-react-common";
const pe = ie(), S = t.forwardRef((w, A) => {
  const n = ue(pe, w), {
    size: c = d.size,
    rounded: f = d.rounded,
    fillMode: k = d.fillMode,
    autoFocus: N = d.autoFocus,
    prefix: H = null,
    suffix: R = null,
    ariaDescribedBy: $,
    ariaLabelledBy: q,
    autoSize: C,
    className: D,
    defaultValue: L,
    disabled: r,
    readOnly: j,
    required: s,
    rows: K,
    id: G,
    name: J,
    placeholder: Q,
    style: U,
    tabIndex: W,
    value: m,
    valid: z,
    validationMessage: I,
    validityStyles: P,
    onChange: p,
    onFocus: b,
    onBlur: x,
    // Removed to support direct use in Form Field component
    visited: be,
    touched: xe,
    modified: ge,
    resizable: g,
    ...X
  } = n, a = t.useRef(null), T = t.useCallback(() => {
    a.current && a.current.focus();
  }, []), [V, B] = t.useState(L), [Y, Z] = F(H), [_, ee] = F(R), l = m !== void 0, i = l ? m : V, u = t.useCallback(() => ({
    element: a,
    focus: T,
    get value() {
      return i;
    },
    get name() {
      return a.current && a.current.name;
    }
  }), [T, i]);
  t.useImperativeHandle(A, u);
  const [te, E] = t.useState("auto"), ae = de(), re = ce(a, n.dir), v = z !== void 0 ? z : s ? !!i : !0;
  t.useEffect(() => {
    a.current && a.current.setCustomValidity && a.current.setCustomValidity(v ? "" : I || "");
  }, [v, I]), fe(() => {
    a.current && E(`${a.current.scrollHeight}px`);
  }, [i]);
  const oe = t.useCallback(
    (o) => {
      const h = o.target.value;
      E("auto"), !l && !r && B(h), p && !r && y(
        p,
        o,
        {
          ...u(),
          value: h
        },
        { value: h }
      );
    },
    [B, p, r, l]
  ), ne = t.useCallback(
    (o) => {
      b && !r && y(b, o, u(), void 0);
    },
    [b, r]
  ), se = t.useCallback(
    (o) => {
      x && !r && y(x, o, u(), void 0);
    },
    [x, r]
  ), le = {
    id: G || ae,
    role: "textbox",
    name: J,
    className: M("k-input-inner", "!k-overflow-auto", { "k-resize": !C && g !== "none" }),
    ref: a,
    disabled: r,
    rows: K,
    placeholder: Q,
    readOnly: j,
    required: s,
    tabIndex: me(W, r),
    autoFocus: N,
    style: C ? { resize: "none", overflow: "hidden", height: te } : g ? { resize: g } : {},
    "aria-labelledby": q,
    "aria-describedby": $,
    "aria-multiline": !0,
    "aria-disabled": r || void 0,
    "aria-required": s,
    value: l ? m : V,
    ...X,
    onChange: oe,
    onFocus: ne,
    onBlur: se
  };
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      className: M(
        "k-input",
        "k-textarea",
        {
          [`k-input-${O.sizeMap[c] || c}`]: c,
          [`k-input-${k}`]: k,
          [`k-rounded-${O.roundedMap[f] || f}`]: f,
          "k-invalid": !(v || P !== void 0 || P === !0),
          "k-required": s,
          "k-disabled": r
        },
        D
      ),
      style: U,
      dir: re
    },
    n.prefix && /* @__PURE__ */ t.createElement(Y, { ...Z }),
    /* @__PURE__ */ t.createElement("textarea", { ...le }),
    n.suffix && /* @__PURE__ */ t.createElement(_, { ...ee })
  );
});
S.propTypes = {
  ariaDescribedBy: e.string,
  ariaLabelledBy: e.string,
  autoSize: e.bool,
  className: e.string,
  defaultValue: e.string,
  dir: e.string,
  disabled: e.bool,
  readOnly: e.bool,
  rows: e.number,
  id: e.string,
  name: e.string,
  placeholder: e.string,
  style: e.object,
  tabIndex: e.number,
  value: e.oneOfType([e.string, e.arrayOf(e.string), e.number]),
  onChange: e.func,
  onFocus: e.func,
  onBlur: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  resizable: e.oneOf(["none", "both", "horizontal", "vertical"]),
  autoFocus: e.bool
};
const d = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: !1
};
S.displayName = "KendoTextArea";
export {
  S as TextArea,
  pe as TextAreaPropsContext
};
