/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as i from "react";
import s from "prop-types";
import { ColorPaletteService as E } from "./utils/color-palette.service.mjs";
import { KEYS as a, validatePackage as k, classNames as C, getTabIndex as R, dispatchEvent as F, createPropsContext as N, withIdHOC as P, withPropsContext as T } from "@progress/kendo-react-common";
import { packageMetadata as I } from "../package-metadata.mjs";
import { PALETTEPRESETS as D } from "./models/palette-presets.mjs";
import { isPresent as L } from "./utils/misc.mjs";
import { parseColor as U } from "./utils/color-parser.mjs";
const x = 24, m = 10, z = "office", n = class n extends i.Component {
  constructor(t) {
    super(t), this.wrapperRef = i.createRef(), this.paletteService = null, this.focus = () => {
      this.wrapperRef && this.wrapperRef.current && this.wrapperRef.current.focus();
    }, this.onKeyDown = (e) => {
      switch (e.key) {
        case a.down:
          this.handleCellNavigation(0, 1);
          break;
        case a.up:
          this.handleCellNavigation(0, -1);
          break;
        case a.right:
          this.handleCellNavigation(1, 0);
          break;
        case a.left:
          this.handleCellNavigation(-1, 0);
          break;
        case a.enter:
          this.handleEnter(e);
          break;
        default:
          return;
      }
      e.preventDefault();
    }, this.onColorClick = (e, o) => {
      this.isUncontrolled ? this.setState({ selectedColor: e, focusedColor: e }) : this.setState({ focusedColor: e }), this.dispatchChangeEvent(e, o);
    }, this.onFocus = (e) => {
      this.paletteService && (this.setState({ focusedColor: this.state.selectedColor || this.paletteService.colorRows[0][0] }), this.props.onFocus && this.props.onFocus.call(void 0, e));
    }, this.onBlur = () => {
      this.setState({ focusedColor: void 0 });
    }, k(I), this.state = {
      selectedColor: this.props.value !== void 0 ? this.props.value : this.props.defaultValue ? this.props.defaultValue : void 0,
      isFirstRender: !0
    };
  }
  get guid() {
    return this.props.id;
  }
  /**
   * @hidden
   */
  render() {
    const t = this.getPaletteInfo(), e = this.paletteService = new E();
    e.setColorMatrix(t.colors, t.columns);
    const o = e.getCellCoordsFor(this.state.selectedColor), r = e.getCellCoordsFor(this.state.focusedColor), l = C("k-colorpalette", { "k-disabled": this.props.disabled }, this.props.className);
    return t.colors.length ? /* @__PURE__ */ i.createElement(
      "div",
      {
        id: this.props.id,
        role: "grid",
        className: l,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        "aria-disabled": this.props.ariaDisabled || (this.props.disabled ? "true" : void 0),
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        tabIndex: R(this.props.tabIndex, this.props.disabled),
        ref: this.wrapperRef
      },
      /* @__PURE__ */ i.createElement("table", { className: "k-colorpalette-table", role: "presentation" }, /* @__PURE__ */ i.createElement("tbody", { role: "rowgroup" }, this.renderRows(e.colorRows, o, r)))
    ) : "";
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t, e) {
    if (!e.isFirstRender && t.value !== void 0) {
      if (t.value === "" && e.selectedColor !== void 0)
        return { selectedColor: void 0 };
      if (t.value !== "" && t.value !== e.selectedColor)
        return { selectedColor: t.value };
    } else if (e.isFirstRender)
      return { isFirstRender: !1 };
    return null;
  }
  handleCellNavigation(t, e) {
    if (this.paletteService)
      if (this.focusedColorCooridanates) {
        const o = this.paletteService.getNextCell(
          this.focusedColorCooridanates,
          t,
          e
        );
        this.setState({ focusedColor: this.paletteService.getColorAt(o) });
      } else
        this.setState({ focusedColor: this.paletteService.colorRows[0][0] });
  }
  handleEnter(t) {
    this.isUncontrolled && this.setState({ selectedColor: this.state.focusedColor }), this.dispatchChangeEvent(this.state.focusedColor, t);
  }
  dispatchChangeEvent(t, e) {
    F(this.props.onChange, e, this, { value: t, rgbaValue: U(t, "rgba") });
  }
  get focusedColorCooridanates() {
    return this.state.focusedColor && this.paletteService ? this.paletteService.getCellCoordsFor(this.state.focusedColor) : void 0;
  }
  get isUncontrolled() {
    return this.props.value === void 0;
  }
  getPaletteInfo() {
    if (typeof this.props.palette == "string") {
      const t = D[this.props.palette];
      return L(t) ? {
        colors: t.colors,
        columns: this.props.columns || t.columns || m
      } : { colors: [], columns: 0 };
    }
    return { colors: this.props.palette || [], columns: this.props.columns || m };
  }
  renderRows(t, e, o) {
    return t.map((r, l) => /* @__PURE__ */ i.createElement("tr", { role: "row", key: l }, this.renderColumns(r, l, e, o)));
  }
  renderColumns(t, e, o, r) {
    const l = o !== void 0 && o.row === e, g = o && o.col, v = r !== void 0 && r.row === e, b = r && r.col, h = typeof this.props.tileSize != "number" ? this.props.tileSize : { width: this.props.tileSize, height: this.props.tileSize }, u = h.width + "px", S = h.height + "px";
    return t.map((d, c) => {
      const f = l && g === c, w = C("k-colorpalette-tile", {
        "k-selected": f,
        "k-focus": v && b === c
      });
      return /* @__PURE__ */ i.createElement(
        "td",
        {
          role: "gridcell",
          className: w,
          "aria-label": d,
          "aria-selected": f ? !0 : this.props.disabled ? void 0 : !1,
          style: { backgroundColor: d, width: u, height: S, minWidth: u },
          onClick: (y) => this.onColorClick(d, y),
          id: this.createCellId({ row: e, col: c }),
          key: c
        }
      );
    });
  }
  createCellId(t) {
    return `${this.guid}_${t.row}_${t.col}`;
  }
};
n.displayName = "ColorPalette", n.propTypes = {
  palette: s.oneOfType([s.arrayOf(s.string.isRequired), s.string]),
  columns: s.number,
  tileSize: s.any,
  defaultValue: s.string,
  value: s.string,
  disabled: s.bool,
  tabIndex: s.number,
  onChange: s.func,
  onFocus: s.func,
  id: s.string,
  ariaLabelledBy: s.string,
  ariaDescribedBy: s.string,
  className: s.string
}, n.defaultProps = {
  palette: z,
  tileSize: x
};
let p = n;
const B = N(), A = P(
  T(
    B,
    p
  )
);
A.displayName = "KendoReactColorPalette";
export {
  A as ColorPalette,
  B as ColorPalettePropsContext,
  p as ColorPaletteWithoutContext,
  m as DEFAULT_COLUMNS_COUNT,
  z as DEFAULT_PRESET,
  x as DEFAULT_TILE_SIZE
};
