/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import o from "prop-types";
import { createPropsContext as fe, validatePackage as me, usePropsContext as ve, Navigation as ke, getActiveElement as ge, keepFocusInContainer as h, focusFirstFocusableChild as be, useDir as Ee, classNames as A, kendoThemeMaps as _, getTabIndex as Ce, IconWrap as we, svgIconPropType as ye } from "@progress/kendo-react-common";
import { packageMetadata as Te } from "../package-metadata.mjs";
import { Picker as Se } from "./Picker.mjs";
import { ColorGradient as Pe } from "./ColorGradient.mjs";
import { ColorPalette as Ie, DEFAULT_PRESET as Re, DEFAULT_TILE_SIZE as De } from "./ColorPalette.mjs";
import { Button as Ne } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as he } from "@progress/kendo-svg-icons";
import { colorPickerDropdownButtonAriaLabel as K, messages as Ae } from "../messages/index.mjs";
import { useLocalization as Fe } from "@progress/kendo-react-intl";
const Le = {
  opacity: !0
}, xe = {
  palette: Re,
  tileSize: De
}, F = (b) => b !== void 0, Be = fe(), U = e.forwardRef((b, G) => {
  me(Te);
  const a = ve(Be, b), $ = Fe(), {
    size: E = d.size,
    rounded: C = d.rounded,
    fillMode: L = d.fillMode,
    gradientSettings: W = d.gradientSettings,
    paletteSettings: Z = d.paletteSettings,
    view: s = d.view,
    popupSettings: j,
    valid: q,
    disabled: w,
    tabIndex: J,
    icon: y,
    svgIcon: T,
    iconClassName: m,
    onChange: S,
    onFocus: P,
    onBlur: I,
    onActiveColorClick: R,
    className: Q
  } = a, r = e.useRef(null), f = e.useRef(null), v = e.useRef(null), p = e.useRef(), X = e.useRef(null), [Y, x] = e.useState(!1), [ee, te] = e.useState(a.defaultValue), [ne, oe] = e.useState(!1), D = F(a.value), c = F(a.open), l = D ? a.value : ee, k = c ? a.open : ne, B = e.useCallback(() => {
    r.current && r.current.focus();
  }, []);
  e.useImperativeHandle(
    G,
    () => ({
      // we agreed that each element will have focus method exposed
      element: r.current,
      actionElement: X.current,
      value: l,
      focus: B
    }),
    [l, B]
  );
  const u = e.useCallback(
    (t, i) => {
      c || (!t && !i && r && r.current && r.current.focus(), oe(t));
    },
    [c]
  ), M = e.useMemo(() => new ke({
    root: r,
    selectors: [".k-colorpicker", ".k-color-picker-popup"],
    tabIndex: 0,
    keyboardEvents: {
      keydown: {
        Escape: (t, i, n) => {
          u(!1);
        },
        Enter: (t, i, n) => {
          !c && t === r.current && (n.preventDefault(), n.stopPropagation(), u(!0));
        },
        ArrowDown: (t, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), u(!0));
        },
        ArrowUp: (t, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), u(!1));
        },
        Tab: (t, i, n) => {
          var z, H;
          if (ge(document) !== r.current) {
            const V = (z = v.current) == null ? void 0 : z.wrapperRef.current, g = (H = f.current) == null ? void 0 : H.wrapperRef.current;
            s === "palette" && V ? h(n, V) : s === "gradient" && g ? h(n, g) : s === "combo" && g && h(n, g.parentElement);
          }
        }
      }
    }
  }), [u, c]), ae = e.useCallback(M.triggerKeyboardEvent.bind(M), []), re = e.useCallback(() => {
    c || (f.current && f.current.wrapperRef.current ? be(f.current.wrapperRef.current) : v.current && v.current.focus());
  }, [c]), le = e.useCallback(() => {
    u(!k, !0);
  }, [k]), ie = e.useCallback(
    (t) => {
      R && R.call(void 0, {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        value: l
      });
    },
    [R, l]
  ), se = e.useCallback(
    (t) => {
      p.current ? (clearTimeout(p.current), p.current = void 0) : x(!0), P && P.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [P]
  ), ce = e.useCallback(() => {
    u(!1, !0), x(!1), p.current = void 0;
  }, []), ue = e.useCallback(
    (t) => {
      clearTimeout(p.current), p.current = window.setTimeout(ce), I && I.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [I]
  ), N = e.useCallback(
    (t, i) => {
      const n = i ? t.rgbaValue : t.value;
      D || te(n), S && S.call(void 0, {
        value: n,
        nativeEvent: t.nativeEvent,
        syntheticEvent: t.syntheticEvent
      });
    },
    [D, S]
  ), pe = e.useCallback(
    (t) => N(t, !0),
    [F, N]
  ), O = Ee(r, a.dir), de = q !== !1;
  return /* @__PURE__ */ e.createElement(
    "span",
    {
      id: a.id,
      role: "combobox",
      "aria-label": a.ariaLabel,
      "aria-labelledby": a.ariaLabelledBy,
      "aria-describedby": a.ariaDescribedBy,
      "aria-haspopup": "dialog",
      "aria-expanded": k,
      "aria-disabled": w ? "true" : void 0,
      className: A("k-colorpicker", "k-picker", "k-icon-picker", {
        [`k-picker-${_.sizeMap[E] || E}`]: E,
        [`k-picker-${L}`]: L,
        [`k-rounded-${_.roundedMap[C] || C}`]: C,
        "k-invalid": !de,
        "k-disabled": w,
        "k-focus": Y,
        className: Q
      }),
      ref: r,
      tabIndex: Ce(J, w),
      title: a.title,
      onKeyDown: ae,
      onFocus: se,
      onBlur: ue,
      dir: O
    },
    /* @__PURE__ */ e.createElement(
      Se,
      {
        dir: O,
        open: k,
        onOpen: re,
        popupAnchor: r.current || void 0,
        popupSettings: { ...j },
        input: /* @__PURE__ */ e.createElement("span", { onClick: ie, className: "k-input-inner" }, /* @__PURE__ */ e.createElement(
          "span",
          {
            className: A("k-value-icon", "k-color-preview", {
              "k-no-color": !l,
              "k-icon-color-preview": y || T || m
            })
          },
          m && /* @__PURE__ */ e.createElement("span", { className: A("k-color-preview-icon", m) }),
          !m && (y || T) && /* @__PURE__ */ e.createElement(we, { name: y, icon: T }),
          /* @__PURE__ */ e.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: l } })
        )),
        button: /* @__PURE__ */ e.createElement(
          Ne,
          {
            tabIndex: -1,
            type: "button",
            onClick: le,
            className: "k-input-button",
            rounded: null,
            icon: "caret-alt-down",
            svgIcon: he,
            "aria-label": $.toLanguageString(
              K,
              Ae[K]
            )
          }
        ),
        content: /* @__PURE__ */ e.createElement(e.Fragment, null, (s === "combo" || s === "gradient") && /* @__PURE__ */ e.createElement(
          Pe,
          {
            ...W,
            ref: f,
            isInsidePopup: !0,
            value: l,
            onChange: N
          }
        ), (s === "combo" || s === "palette") && /* @__PURE__ */ e.createElement(
          Ie,
          {
            ...Z,
            ref: v,
            value: l,
            onChange: pe
          }
        ))
      }
    )
  );
});
U.propTypes = {
  value: o.string,
  defaultValue: o.string,
  disabled: o.bool,
  view: o.oneOf(["gradient", "palette", "combo"]),
  dir: o.string,
  id: o.string,
  icon: o.string,
  svgIcon: ye,
  ariaLabelledBy: o.string,
  ariaDescribedBy: o.string,
  size: o.oneOf([null, "small", "medium", "large"]),
  rounded: o.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: o.oneOf([null, "solid", "flat", "outline"]),
  className: o.string
};
const d = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  view: "palette",
  gradientSettings: Le,
  paletteSettings: xe
};
U.displayName = "KendoColorPicker";
export {
  U as ColorPicker,
  Be as ColorPickerPropsContext
};
