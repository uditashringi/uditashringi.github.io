/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as r from "react";
import o from "prop-types";
import { validatePackage as L, Navigation as m, getActiveElement as u, disableNavigatableContainer as C, keepFocusInContainer as F, TABBABLE_ELEMENTS as G, focusFirstFocusableChild as A, enableNavigatableContainer as N, getTabIndex as S, classNames as I, Draggable as T, createPropsContext as M, withIdHOC as _, withPropsContext as B } from "@progress/kendo-react-common";
import { packageMetadata as P } from "../package-metadata.mjs";
import { Slider as k } from "../slider/Slider.mjs";
import { isPresent as R, fitIntoBounds as y } from "./utils/misc.mjs";
import { getHSV as b, getColorFromHue as c, getRGBA as p, getColorFromRGBA as V, parseColor as d, getColorFromHSV as K } from "./utils/color-parser.mjs";
import { cacheHex as U, cacheRgba as O, removeCachedColor as W, cacheHsva as $, getCachedHsva as j, getCachedRgba as X, getCachedHex as Y } from "./utils/color-cache.mjs";
import z from "./ColorInput.mjs";
import { ColorContrastLabels as q } from "./ColorContrastLabels.mjs";
import { ColorContrastSvg as J } from "./ColorContrastSvg.mjs";
import { provideLocalizationService as Q } from "@progress/kendo-react-intl";
import { colorGradientHueSliderLabel as E, messages as x, colorGradientAlphaSliderLabel as H } from "../messages/index.mjs";
const Z = "rgba", w = "rgba(255, 255, 255, 1)", g = 2, v = 5, h = class h extends r.Component {
  constructor(t) {
    super(t), this.wrapperRef = r.createRef(), this.hsvGradientRef = r.createRef(), this.focus = () => {
      this.wrapperRef && this.wrapperRef.current && this.wrapperRef.current.focus();
    }, this.onHexChange = (e, s, i) => {
      if (this.isUncontrolled) {
        const n = b(s);
        this.setState({ hsva: n, backgroundColor: c(n.h), rgba: p(s), hex: e });
      } else
        U(this.state.guid, s, e);
      this.dispatchChangeEvent(s, i, i.nativeEvent);
    }, this.onRgbaChange = (e, s) => {
      const i = V(e);
      if (this.isUncontrolled) {
        const n = b(i), l = d(i, "hex");
        this.setState({ hsva: n, backgroundColor: c(n.h), rgba: e, hex: l });
      } else
        O(this.state.guid, i, e);
      this.dispatchChangeEvent(i, s.syntheticEvent, s.nativeEvent);
    }, this.onAlphaSliderChange = (e) => {
      this.handleHsvaChange(
        Object.assign({}, this.state.hsva, { a: e.value / 100 }),
        e.syntheticEvent,
        e.nativeEvent
      );
    }, this.onHueSliderChange = (e) => {
      this.handleHsvaChange(
        Object.assign({}, this.state.hsva, { h: e.value }),
        e.syntheticEvent,
        e.nativeEvent
      );
    }, this.onDrag = (e) => {
      this.gradientWrapper.classList.add("k-dragging"), this.changePosition(e.event);
    }, this.onRelease = () => {
      this.gradientWrapper.classList.remove("k-dragging");
    }, this.onGradientWrapperClick = (e) => {
      this.changePosition(e);
    }, this.onHsvGradientKeyDown = (e) => {
      var s;
      (s = this.hsvNavigation) == null || s.triggerKeyboardEvent(e);
    }, this.onHsvGradientValueChange = (e, s, i) => {
      const n = parseInt(e.style.top, 10) + i, l = parseInt(e.style.left, 10) + s;
      e.style.top = `${n}px`, e.style.left = `${l}px`, this.moveDragHandle(l, n);
    }, this.changePosition = (e) => {
      const s = this.getGradientRectMetrics(), i = e.clientX - s.left, n = e.clientY - s.top;
      this.moveDragHandle(i, n);
    }, this.onFocus = (e) => {
      this.props.onFocus && this.props.onFocus.call(void 0, { nativeEvent: e, target: this });
    }, this.onKeyDown = (e) => {
      var s;
      (s = this.navigation) == null || s.triggerKeyboardEvent(e);
    }, L(P);
    const a = t.value || t.defaultValue || d(w, Z);
    this.state = Object.assign({}, h.getStateFromValue(a), {
      isFirstRender: !0,
      guid: this.props.id
    });
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t, a) {
    return t.value && !a.isFirstRender ? h.getStateFromValue(t.value, a.guid) : null;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    if (this.setAlphaSliderBackground(this.state.backgroundColor), this.state.isFirstRender && this.setState({ isFirstRender: !1 }), this.wrapperRef && this.hsvGradientRef) {
      let t = 0, a = 0;
      this.hsvNavigation = new m({
        tabIndex: 0,
        root: this.hsvGradientRef,
        selectors: [".k-hsv-rectangle .k-hsv-draghandle"],
        keyboardEvents: {
          keydown: {
            ArrowDown: (e, s, i) => {
              a = i.shiftKey ? this.props.gradientSliderSmallStep || g : this.props.gradientSliderStep || v, this.onHsvGradientValueChange(e, 0, a);
            },
            ArrowUp: (e, s, i) => {
              a = i.shiftKey ? -(this.props.gradientSliderSmallStep || g) : -(this.props.gradientSliderStep || v), this.onHsvGradientValueChange(e, 0, a);
            },
            ArrowLeft: (e, s, i) => {
              t = i.shiftKey ? -(this.props.gradientSliderSmallStep || g) : -(this.props.gradientSliderStep || v), this.onHsvGradientValueChange(e, t, 0);
            },
            ArrowRight: (e, s, i) => {
              t = i.shiftKey ? this.props.gradientSliderSmallStep || g : this.props.gradientSliderStep || v, this.onHsvGradientValueChange(e, t, 0);
            }
          }
        }
      });
    }
    this.wrapperRef && this.wrapperRef.current && (this.props.isInsidePopup ? this.hsvGradientRef.current && this.hsvGradientRef.current.focus() : this.navigation = new m({
      tabIndex: 0,
      root: this.wrapperRef,
      selectors: [".k-colorgradient"],
      keyboardEvents: {
        keydown: {
          Tab: (t, a, e) => {
            u(document) === t ? C(t) : F(e, t, G);
          },
          Enter: (t, a, e) => {
            u(document) === t && (A(t), N(t));
          },
          Escape: (t, a, e) => {
            u(document) !== t && (t.focus(), C(t));
          }
        }
      }
    }));
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    W(this.state.guid);
  }
  /**
   * @hidden
   */
  componentDidUpdate(t, a) {
    a.backgroundColor !== this.state.backgroundColor && this.setAlphaSliderBackground(this.state.backgroundColor);
  }
  /**
   * @hidden
   */
  renderRectangleDragHandle() {
    const t = {};
    if (!this.state.isFirstRender) {
      const a = this.getGradientRectMetrics(), e = (1 - this.state.hsva.v) * a.height, s = this.state.hsva.s * a.width;
      t.top = `${e}px`, t.left = `${s}px`;
    }
    return /* @__PURE__ */ r.createElement(
      "div",
      {
        ref: this.hsvGradientRef,
        role: "slider",
        tabIndex: S(this.props.tabIndex, this.props.disabled),
        "aria-valuetext": this.props.ariaValueText,
        "aria-valuenow": parseInt(this.state.hex.substring(1), 16),
        "aria-label": this.props.ariaLabelHSV,
        "aria-orientation": void 0,
        "aria-disabled": this.props.disabled ? "true" : void 0,
        className: "k-hsv-draghandle k-draghandle",
        style: t,
        onKeyDown: this.onHsvGradientKeyDown
      }
    );
  }
  /**
   * @hidden
   */
  moveDragHandle(t, a) {
    const e = this.getGradientRectMetrics(), s = e.width, i = e.height, n = y(a, 0, i), l = y(t, 0, s), D = Object.assign({}, this.state.hsva, {
      s: l / s,
      v: 1 - n / i
    });
    this.handleHsvaChange(D, {}, {});
  }
  /**
   * @hidden
   */
  handleHsvaChange(t, a, e) {
    const s = K(t), i = d(s, "hex");
    this.isUncontrolled || $(this.state.guid, s, t), this.setState({ hsva: t, backgroundColor: c(t.h), rgba: p(s), hex: i }), this.dispatchChangeEvent(s, a, e);
  }
  /**
   * @hidden
   */
  dispatchChangeEvent(t, a, e) {
    this.props.onChange && this.props.onChange.call(void 0, {
      syntheticEvent: a,
      nativeEvent: e,
      target: this,
      value: t
    });
  }
  /**
   * @hidden
   */
  static getStateFromValue(t, a) {
    R(d(t, "hex")) || (t = w);
    const e = j(a, t) || b(t), s = X(a, t) || p(t), i = Y(a, t) || d(t, "hex"), n = c(e.h);
    return { hsva: e, backgroundColor: n, rgba: s, hex: i };
  }
  /**
   * @hidden
   */
  setAlphaSliderBackground(t) {
    this.props.opacity && this.alphaSlider && this.alphaSlider.sliderTrack && (this.alphaSlider.sliderTrack.style.background = `linear-gradient(to top, transparent, ${t})`);
  }
  /**
   * @hidden
   */
  get isUncontrolled() {
    return this.props.value === void 0;
  }
  /**
   * @hidden
   */
  getGradientRectMetrics() {
    return this.gradientWrapper.getBoundingClientRect();
  }
  /**
   * @hidden
   */
  render() {
    const t = Q(this), a = I("k-colorgradient", { "k-disabled": this.props.disabled }, this.props.className);
    return /* @__PURE__ */ r.createElement(
      "div",
      {
        id: this.props.id,
        role: this.props.role,
        className: a,
        "aria-disabled": this.props.disabled ? "true" : void 0,
        style: this.props.style,
        ref: this.wrapperRef,
        tabIndex: S(this.props.tabIndex, this.props.disabled),
        "aria-label": this.props.ariaLabel,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        onFocus: this.onFocus,
        onKeyDown: this.onKeyDown
      },
      /* @__PURE__ */ r.createElement("div", { className: "k-colorgradient-canvas k-hstack" }, /* @__PURE__ */ r.createElement("div", { className: "k-hsv-rectangle", style: { background: this.state.backgroundColor } }, /* @__PURE__ */ r.createElement(
        T,
        {
          onDrag: this.onDrag,
          onRelease: this.onRelease,
          ref: (e) => this.gradientWrapper = e ? e.element : void 0
        },
        /* @__PURE__ */ r.createElement(
          "div",
          {
            className: "k-hsv-gradient",
            style: { touchAction: "none" },
            onClick: this.onGradientWrapperClick
          },
          this.renderRectangleDragHandle()
        )
      ), this.props.backgroundColor && !this.state.isFirstRender && /* @__PURE__ */ r.createElement(
        J,
        {
          metrics: this.gradientWrapper ? this.getGradientRectMetrics() : void 0,
          hsva: this.state.hsva,
          backgroundColor: this.props.backgroundColor
        }
      )), /* @__PURE__ */ r.createElement("div", { className: "k-hsv-controls k-hstack" }, /* @__PURE__ */ r.createElement(
        k,
        {
          value: this.state.hsva.h,
          buttons: !1,
          vertical: !0,
          min: 0,
          max: 360,
          step: 5,
          onChange: this.onHueSliderChange,
          className: "k-hue-slider k-colorgradient-slider",
          disabled: this.props.disabled,
          ariaLabel: t.toLanguageString(
            E,
            x[E]
          )
        }
      ), this.props.opacity && /* @__PURE__ */ r.createElement(
        k,
        {
          value: R(this.state.hsva.a) ? this.state.hsva.a * 100 : 100,
          buttons: !1,
          vertical: !0,
          min: 0,
          max: 100,
          step: 1,
          ariaLabel: t.toLanguageString(
            H,
            x[H]
          ),
          onChange: this.onAlphaSliderChange,
          className: "k-alpha-slider k-colorgradient-slider",
          disabled: this.props.disabled,
          ref: (e) => this.alphaSlider = e
        }
      ))),
      /* @__PURE__ */ r.createElement(
        z,
        {
          rgba: this.state.rgba,
          onRgbaChange: this.onRgbaChange,
          hex: this.state.hex,
          onHexChange: this.onHexChange,
          opacity: this.props.opacity,
          disabled: this.props.disabled,
          defaultInputMode: this.props.format
        }
      ),
      this.props.backgroundColor && /* @__PURE__ */ r.createElement(q, { bgColor: p(this.props.backgroundColor), rgba: this.state.rgba })
    );
  }
};
h.displayName = "ColorGradient", h.propTypes = {
  defaultValue: o.string,
  value: o.string,
  onChange: o.func,
  onFocus: o.func,
  opacity: o.bool,
  backgroundColor: o.string,
  format: o.any,
  disabled: o.bool,
  style: o.any,
  id: o.string,
  role: o.string,
  ariaLabel: o.string,
  ariaLabelledBy: o.string,
  ariaDescribedBy: o.string,
  className: o.string
}, h.defaultProps = {
  opacity: !0,
  role: "textbox",
  format: "rgb"
};
let f = h;
const ee = M(), te = _(
  B(
    ee,
    f
  )
);
te.displayName = "KendoReactColorGradient";
export {
  te as ColorGradient,
  ee as ColorGradientPropsContext,
  f as ColorGradientWithoutContext
};
